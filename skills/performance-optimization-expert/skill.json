{
  "name": "performance-optimization-expert",
  "version": "1.0.0",
  "description": "Comprehensive performance optimization specialist for React applications with focus on measurable improvements",
  "category": "optimization",
  "author": "ULT Trading Platform Team",
  "tags": ["performance", "react", "optimization", "chart.js", "caching", "memory", "monitoring"],
  "capabilities": [
    "Chart.js rendering optimization",
    "Smart caching strategies",
    "Memory leak detection and fixes",
    "API performance optimization",
    "React state management optimization",
    "Performance monitoring systems",
    "Real-time performance analysis",
    "Resource usage optimization"
  ],
  "file_patterns": [
    "**/StockChart*.tsx",
    "**/data-aggregator.ts",
    "**/useStockData.ts",
    "**/tradingStore.ts",
    "**/hooks/usePerformance*.ts"
  ],
  "commands": {
    "optimize-chart": "Optimize Chart.js component rendering",
    "fix-memory-leak": "Fix memory leaks in React components",
    "implement-cache": "Implement smart caching strategy",
    "add-monitoring": "Add performance monitoring system",
    "optimize-api": "Optimize API request handling"
  },
  "best_practices": [
    "Always measure before and after optimization",
    "Implement performance monitoring in production",
    "Use memoization strategically (not everywhere)",
    "Profile rendering bottlenecks before optimization",
    "Implement smart caching with TTL strategies",
    "Guarantee proper cleanup to prevent memory leaks",
    "Use debouncing for frequent updates",
    "Optimize dependencies in React hooks",
    "Monitor memory usage trends",
    "Implement exponential backoff for retry logic"
  ],
  "key_achievements": {
    "chart_optimization": "50-70% faster rendering through dataset splitting and memoization",
    "cache_strategy": "40-60% faster data loading with time-based TTL and LRU eviction",
    "memory_management": "30-50% reduction through guaranteed cleanup and debouncing",
    "api_optimization": "20-40% faster responses with dynamic batching and exponential backoff",
    "state_management": "Improved render performance through memoized calculations"
  },
  "performance_metrics": {
    "initial_render": { "before": "850ms", "after": "340ms", "improvement": "60% faster" },
    "chart_operations": { "before": "250ms", "after": "80ms", "improvement": "68% faster" },
    "data_loading": { "before": "2.3s", "after": "0.9s", "improvement": "61% faster" },
    "memory_usage": { "before": "145MB", "after": "78MB", "improvement": "46% reduction" },
    "api_requests": { "before": "1200/day", "after": "480/day", "improvement": "60% reduction" }
  },
  "implementation_patterns": {
    "dataset_splitting": "Split datasets into separate useMemo calls for selective updates",
    "selective_updates": "Only update changed datasets, not entire chart",
    "performance_monitoring": "Track render times and slow component detection",
    "time_based_ttl": "Different TTL based on data type (realtime 30s, daily 24h)",
    "lru_eviction": "Remove least recently used items when cache is full",
    "automatic_cleanup": "Periodically remove expired cache entries",
    "memory_limits": "Set maximum cache size to prevent memory bloat",
    "abortcontroller_cleanup": "Guaranteed cleanup of pending requests",
    "event_listener_removal": "Always remove event listeners on unmount",
    "debouncing": "Prevent excessive updates with setTimeout debouncing",
    "state_clearing": "Clear component state on unmount",
    "dynamic_batching": "Adjust batch size based on request volume",
    "exponential_backoff": "Use exponential backoff with jitter for retries",
    "rate_limit_handling": "Intelligent retry logic with caps and delays"
  },
  "monitoring_system": {
    "real_time_tracking": "Track render times and component performance",
    "memory_monitoring": "Monitor heap usage and detect memory leaks",
    "interaction_tracking": "Measure user interaction responsiveness",
    "alert_system": "Automatic alerts for performance issues",
    "global_monitoring": "Application-wide performance tracking"
  },
  "common_anti_patterns": [
    "State updates in useEffect cleanup functions",
    "Unreachable code after return statements",
    "Missing dependency cleanup in useEffect",
    "Unnecessary re-renders from unstable references",
    "Memory leaks from event listeners",
    "Excessive re-calculations without memoization",
    "Fixed cache TTL for all data types",
    "Blocking UI during heavy computations"
  ],
  "tools_and_techniques": [
    "React.useMemo",
    "React.useCallback",
    "AbortController",
    "LRU cache",
    "setTimeout debouncing",
    "Performance.now()",
    "Memory API",
    "Exponential backoff",
    "Dynamic batching"
  ],
  "lessons_learned": [
    "Always measure performance before optimizing",
    "Memoize strategically, not everywhere",
    "Guarantee cleanup to prevent memory leaks",
    "Use debouncing for frequent updates",
    "Implement proper error boundaries",
    "Monitor production performance continuously",
    "Consider browser performance APIs",
    "Test with realistic data volumes",
    "Profile before and after optimization"
  ],
  "future_improvements": [
    "Web Workers",
    "Virtualization",
    "Service Workers",
    "Code splitting",
    "CDN integration",
    "Image optimization",
    "Predictive preloading",
    "Performance budgets"
  ]
}