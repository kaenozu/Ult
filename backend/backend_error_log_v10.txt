============================= test session starts =============================
platform win32 -- Python 3.11.0, pytest-7.4.2, pluggy-1.6.0
benchmark: 5.1.0 (defaults: timer=time.perf_counter disable_gc=False min_rounds=5 min_time=0.000005 max_time=1.0 calibration_precision=10 warmup=False warmup_iterations=100000)
rootdir: C:\gemini-desktop\Ult\backend
plugins: anyio-4.9.0, dash-3.1.1, Faker-37.5.3, logfire-4.0.0, asyncio-0.23.7, benchmark-5.1.0, cov-4.1.0, mock-3.14.1, timeout-2.4.0, xdist-3.8.0, requests-mock-1.12.1, respx-0.22.0, typeguard-4.4.4
asyncio: mode=Mode.STRICT
collected 80 items

tests\test_agents.py FFFFFFF                                             [  8%]
tests\test_api_endpoints.py .F.FF.F.F                                    [ 20%]
tests\test_api_integration.py FFFF..FF                                   [ 30%]
tests\test_approval_persistence.py .                                     [ 31%]
tests\test_auto_trader.py ...                                            [ 35%]
tests\test_chaos.py FF                                                   [ 37%]
tests\test_config.py F..F.FFF.                                           [ 48%]
tests\test_database.py .....                                             [ 55%]
tests\test_genetic_optimizer.py .                                        [ 56%]
tests\test_vibe_trading.py ...............                               [ 75%]
tests\test_websocket.py FFFF.                                            [ 81%]
tests\core\test_agent_loop.py ..                                         [ 83%]
tests\core\test_schemas.py ....                                          [ 88%]
tests\security\test_circuit_breaker.py ......                            [ 96%]
tests\services\test_approval_service.py ...                              [100%]

================================== FAILURES ===================================
_______________ TestAgents.test_autonomous_agent_initialization _______________

args = (<test_agents.TestAgents object at 0x000001AA13A61190>,)
keywargs = {'mock_config': <MagicMock id='1829987433232'>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\unittest\mock.py:1356: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\contextlib.py:137: in __enter__
    return next(self.gen)
C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\unittest\mock.py:1338: in decoration_helper
    arg = exit_stack.enter_context(patching)
C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\contextlib.py:502: in enter_context
    result = _enter(cm)
C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\unittest\mock.py:1427: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x000001AA13A5AB50>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.core.agent_loop' from 'C:\\gemini-desktop\\Ult\\backend\\src\\core\\agent_loop.py'> does not have the attribute 'app_settings'

C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\unittest\mock.py:1400: AttributeError
_______________ TestAgents.test_consensus_engine_initialization _______________

args = (<test_agents.TestAgents object at 0x000001AA13A14050>,)
keywargs = {'mock_config': <MagicMock id='1829986584528'>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\unittest\mock.py:1356: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\contextlib.py:137: in __enter__
    return next(self.gen)
C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\unittest\mock.py:1338: in decoration_helper
    arg = exit_stack.enter_context(patching)
C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\contextlib.py:502: in enter_context
    result = _enter(cm)
C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\unittest\mock.py:1427: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x000001AA13A5AD10>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.agents.consensus_engine' from 'C:\\gemini-desktop\\Ult\\backend\\src\\agents\\consensus_engine.py'> does not have the attribute 'app_settings'

C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\unittest\mock.py:1400: AttributeError
_________________ TestAgents.test_consensus_engine_add_agent __________________

args = (<test_agents.TestAgents object at 0x000001AA13A62010>,)
keywargs = {'mock_config': <MagicMock id='1830920558800'>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\unittest\mock.py:1356: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\contextlib.py:137: in __enter__
    return next(self.gen)
C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\unittest\mock.py:1338: in decoration_helper
    arg = exit_stack.enter_context(patching)
C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\contextlib.py:502: in enter_context
    result = _enter(cm)
C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\unittest\mock.py:1427: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x000001AA13A5AED0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.agents.consensus_engine' from 'C:\\gemini-desktop\\Ult\\backend\\src\\agents\\consensus_engine.py'> does not have the attribute 'app_settings'

C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\unittest\mock.py:1400: AttributeError
_______________ TestAgents.test_consensus_engine_make_decision ________________

args = (<test_agents.TestAgents object at 0x000001AA13A62790>,)
keywargs = {'mock_config': <MagicMock id='1830939166352'>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\unittest\mock.py:1356: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\contextlib.py:137: in __enter__
    return next(self.gen)
C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\unittest\mock.py:1338: in decoration_helper
    arg = exit_stack.enter_context(patching)
C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\contextlib.py:502: in enter_context
    result = _enter(cm)
C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\unittest\mock.py:1427: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x000001AA13A5B0D0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.agents.consensus_engine' from 'C:\\gemini-desktop\\Ult\\backend\\src\\agents\\consensus_engine.py'> does not have the attribute 'app_settings'

C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\unittest\mock.py:1400: AttributeError
________________ TestAgents.test_news_agent_sentiment_analysis ________________

args = (<test_agents.TestAgents object at 0x000001AA13A62ED0>,)
keywargs = {'mock_config': <MagicMock id='1830940558352'>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\unittest\mock.py:1356: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\contextlib.py:137: in __enter__
    return next(self.gen)
C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\unittest\mock.py:1338: in decoration_helper
    arg = exit_stack.enter_context(patching)
C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\contextlib.py:502: in enter_context
    result = _enter(cm)
C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\unittest\mock.py:1427: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x000001AA13A5B610>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.agents.news_agent' from 'C:\\gemini-desktop\\Ult\\backend\\src\\agents\\news_agent.py'> does not have the attribute 'app_settings'

C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\unittest\mock.py:1400: AttributeError
_________________ TestAgents.test_vision_agent_initialization _________________

args = (<test_agents.TestAgents object at 0x000001AA13A63610>,)
keywargs = {'mock_config': <MagicMock id='1830940263632'>}

    @wraps(func)
    def patched(*args, **keywargs):
>       with self.decoration_helper(patched,
                                    args,
                                    keywargs) as (newargs, newkeywargs):

C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\unittest\mock.py:1356: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\contextlib.py:137: in __enter__
    return next(self.gen)
C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\unittest\mock.py:1338: in decoration_helper
    arg = exit_stack.enter_context(patching)
C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\contextlib.py:502: in enter_context
    result = _enter(cm)
C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\unittest\mock.py:1427: in __enter__
    original, local = self.get_original()
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <unittest.mock._patch object at 0x000001AA13A5B8D0>

    def get_original(self):
        target = self.getter()
        name = self.attribute
    
        original = DEFAULT
        local = False
    
        try:
            original = target.__dict__[name]
        except (AttributeError, KeyError):
            original = getattr(target, name, DEFAULT)
        else:
            local = True
    
        if name in _builtins and isinstance(target, ModuleType):
            self.create = True
    
        if not self.create and original is DEFAULT:
>           raise AttributeError(
                "%s does not have the attribute %r" % (target, name)
            )
E           AttributeError: <module 'src.agents.vision_agent' from 'C:\\gemini-desktop\\Ult\\backend\\src\\agents\\vision_agent.py'> does not have the attribute 'app_settings'

C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\unittest\mock.py:1400: AttributeError
___________________ TestAgents.test_agent_state_transitions ___________________

self = <test_agents.TestAgents object at 0x000001AA13A63D90>

    def test_agent_state_transitions(self):
        """Test agent state management."""
        from src.core.schemas import AgentState
    
        # Test state enum values
>       assert AgentState.IDLE.value == "idle"

tests\test_agents.py:123: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <class 'src.core.schemas.AgentState'>, item = 'IDLE'

    def __getattr__(self, item: str) -> Any:
        """This is necessary to keep attribute access working for class attribute access."""
        private_attributes = self.__dict__.get('__private_attributes__')
        if private_attributes and item in private_attributes:
            return private_attributes[item]
>       raise AttributeError(item)
E       AttributeError: IDLE

C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\site-packages\pydantic\_internal\_model_construction.py:271: AttributeError
____________________ TestAPIEndpoints.test_health_endpoint ____________________

self = <test_api_endpoints.TestAPIEndpoints object at 0x000001AA13A6F950>
client = <starlette.testclient.TestClient object at 0x000001AA4CA0CDD0>

    def test_health_endpoint(self, client):
        """Test detailed health endpoint."""
        response = client.get("/api/v1/health")
        assert response.status_code == 200
        data = response.json()
>       assert data["status"] == "healthy"
E       KeyError: 'status'

tests\test_api_endpoints.py:36: KeyError
---------------------------- Captured stderr call -----------------------------
2026-01-21 16:45:51,325 - httpx - INFO - HTTP Request: GET http://testserver/api/v1/health "HTTP/1.1 200 OK"
------------------------------ Captured log call ------------------------------
INFO     httpx:_client.py:1025 HTTP Request: GET http://testserver/api/v1/health "HTTP/1.1 200 OK"
__________________ TestAPIEndpoints.test_portfolio_endpoints __________________

self = <test_api_endpoints.TestAPIEndpoints object at 0x000001AA13A88750>
client = <starlette.testclient.TestClient object at 0x000001AA4B73ACD0>

    def test_portfolio_endpoints(self, client):
        """Test portfolio API endpoints structure."""
        # These endpoints may require authentication, but we test the routing
        response = client.get("/api/v1/portfolio")
        # Expect 401 or 404 depending on auth implementation
>       assert response.status_code in [
            401,
            404,
            405,
        ]  # Not implemented or auth required
E       assert 200 in [401, 404, 405]
E        +  where 200 = <Response [200 OK]>.status_code

tests\test_api_endpoints.py:52: AssertionError
---------------------------- Captured stderr call -----------------------------
2026-01-21 16:45:51,382 - httpx - INFO - HTTP Request: GET http://testserver/api/v1/portfolio "HTTP/1.1 200 OK"
------------------------------ Captured log call ------------------------------
INFO     httpx:_client.py:1025 HTTP Request: GET http://testserver/api/v1/portfolio "HTTP/1.1 200 OK"
___________________ TestAPIEndpoints.test_market_endpoints ____________________

self = <test_api_endpoints.TestAPIEndpoints object at 0x000001AA13A88E90>
client = <starlette.testclient.TestClient object at 0x000001AA4B6AB450>

    def test_market_endpoints(self, client):
        """Test market data API endpoints."""
        response = client.get("/api/v1/market/status")
>       assert response.status_code in [200, 401, 404]  # May require auth
E       assert 400 in [200, 401, 404]
E        +  where 400 = <Response [400 Bad Request]>.status_code

tests\test_api_endpoints.py:61: AssertionError
---------------------------- Captured stderr call -----------------------------
2026-01-21 16:45:51,409 - src.data_temp.data_loader - INFO - Using sync loader for 1 tickers
2026-01-21 16:45:51,410 - src.data_temp.data_loader - ERROR - Error loading cached data for status: 'NoneType' object has no attribute 'empty'
2026-01-21 16:45:51,411 - src.data_temp.data_loader - INFO - Downloading 1 tickers via yfinance
2026-01-21 16:45:53,408 - yfinance - ERROR - HTTP Error 404: {"quoteSummary":{"result":null,"error":{"code":"Not Found","description":"Quote not found for symbol: STATUS"}}}
2026-01-21 16:45:54,020 - yfinance - ERROR - $STATUS: possibly delisted; no price data found  (period=5d) (Yahoo error = "No data found, symbol may be delisted")

[*********************100%***********************]  1 of 1 completed
2026-01-21 16:45:54,023 - yfinance - ERROR - 
1 Failed download:
2026-01-21 16:45:54,023 - yfinance - ERROR - ['STATUS']: possibly delisted; no price data found  (period=5d) (Yahoo error = "No data found, symbol may be delisted")
2026-01-21 16:45:54,026 - src.api.server - WARNING - HTTP exception: 404 - Ticker not found
2026-01-21 16:45:54,028 - httpx - INFO - HTTP Request: GET http://testserver/api/v1/market/status "HTTP/1.1 400 Bad Request"
------------------------------ Captured log call ------------------------------
INFO     src.data_temp.data_loader:data_loader.py:489 Using sync loader for 1 tickers
ERROR    src.data_temp.data_loader:data_loader.py:518 Error loading cached data for status: 'NoneType' object has no attribute 'empty'
INFO     src.data_temp.data_loader:data_loader.py:272 Downloading 1 tickers via yfinance
ERROR    yfinance:quote.py:592 HTTP Error 404: {"quoteSummary":{"result":null,"error":{"code":"Not Found","description":"Quote not found for symbol: STATUS"}}}
ERROR    yfinance:history.py:276 $STATUS: possibly delisted; no price data found  (period=5d) (Yahoo error = "No data found, symbol may be delisted")
ERROR    yfinance:multi.py:176 
1 Failed download:
ERROR    yfinance:multi.py:189 ['STATUS']: possibly delisted; no price data found  (period=5d) (Yahoo error = "No data found, symbol may be delisted")
WARNING  src.api.server:server.py:196 HTTP exception: 404 - Ticker not found
INFO     httpx:_client.py:1025 HTTP Request: GET http://testserver/api/v1/market/status "HTTP/1.1 400 Bad Request"
____________________ TestAPIEndpoints.test_error_handling _____________________

self = <test_api_endpoints.TestAPIEndpoints object at 0x000001AA13A89D90>
client = <starlette.testclient.TestClient object at 0x000001AA4B789FD0>

    def test_error_handling(self, client):
        """Test error response format."""
        response = client.get("/api/v1/nonexistent")
        assert response.status_code == 404
        # Check if error response follows standard format
        if response.content:
            data = response.json()
>           assert "status" in data
E           AssertionError: assert 'status' in {'detail': 'Not Found'}

tests\test_api_endpoints.py:75: AssertionError
---------------------------- Captured stderr call -----------------------------
2026-01-21 16:45:54,090 - httpx - INFO - HTTP Request: GET http://testserver/api/v1/nonexistent "HTTP/1.1 404 Not Found"
------------------------------ Captured log call ------------------------------
INFO     httpx:_client.py:1025 HTTP Request: GET http://testserver/api/v1/nonexistent "HTTP/1.1 404 Not Found"
___________________ TestAPIEndpoints.test_security_headers ____________________

self = <test_api_endpoints.TestAPIEndpoints object at 0x000001AA13A8AD90>
client = <starlette.testclient.TestClient object at 0x000001AA4B789950>

    def test_security_headers(self, client):
        """Test security headers."""
        response = client.get("/")
        headers = response.headers
    
        # Check for security headers
>       assert "x-content-type-options" in headers
E       AssertionError: assert 'x-content-type-options' in Headers({'content-length': '79', 'content-type': 'application/json'})

tests\test_api_endpoints.py:91: AssertionError
---------------------------- Captured stderr call -----------------------------
2026-01-21 16:45:54,142 - httpx - INFO - HTTP Request: GET http://testserver/ "HTTP/1.1 200 OK"
------------------------------ Captured log call ------------------------------
INFO     httpx:_client.py:1025 HTTP Request: GET http://testserver/ "HTTP/1.1 200 OK"
___________________ TestAPIIntegration.test_health_endpoint ___________________

self = <test_api_integration.TestAPIIntegration object at 0x000001AA13A99A10>

    def test_health_endpoint(self):
        """ヘルスチェックエンドポイントテスト"""
        response = self.client.get("/health")
    
>       assert response.status_code == 200
E       assert 404 == 200
E        +  where 404 = <Response [404 Not Found]>.status_code

tests\test_api_integration.py:28: AssertionError
---------------------------- Captured stderr call -----------------------------
2026-01-21 16:45:54,171 - httpx - INFO - HTTP Request: GET http://testserver/health "HTTP/1.1 404 Not Found"
------------------------------ Captured log call ------------------------------
INFO     httpx:_client.py:1025 HTTP Request: GET http://testserver/health "HTTP/1.1 404 Not Found"
____________________ TestAPIIntegration.test_root_endpoint ____________________

self = <test_api_integration.TestAPIIntegration object at 0x000001AA13A9A210>

    def test_root_endpoint(self):
        """ルートエンドポイントテスト"""
        response = self.client.get("/")
    
        assert response.status_code == 200
        data = response.json()
>       assert "name" in data
E       AssertionError: assert 'name' in {'status': 'healthy', 'timestamp': '2026-01-21T16:45:54.203591', 'version': '1.0.0'}

tests\test_api_integration.py:41: AssertionError
---------------------------- Captured stderr call -----------------------------
2026-01-21 16:45:54,205 - httpx - INFO - HTTP Request: GET http://testserver/ "HTTP/1.1 200 OK"
------------------------------ Captured log call ------------------------------
INFO     httpx:_client.py:1025 HTTP Request: GET http://testserver/ "HTTP/1.1 200 OK"
_______________ TestAPIIntegration.test_trade_endpoint_success ________________

self = <test_api_integration.TestAPIIntegration object at 0x000001AA13A88A50>
mock_pm = <MagicMock name='get_portfolio_manager' id='1830939654736'>
mock_pt = <MagicMock name='get_paper_trader' id='1830941475152'>
mock_get_price = <AsyncMock name='get_stock_price' id='1830942426128'>

    @patch("src.services.trading_service.TradingService.get_stock_price")
    @patch("src.api.dependencies.get_paper_trader")
    @patch("src.api.dependencies.get_portfolio_manager")
    def test_trade_endpoint_success(self, mock_pm, mock_pt, mock_get_price):
        """取引エンドポイント成功ケーステスト"""
        # モック設定
        mock_get_price.return_value = 150.0
        mock_pt.return_value.execute_trade.return_value = True
        mock_pm.return_value.lock = MagicMock()
        mock_pm.return_value.lock.__aenter__ = MagicMock()
        mock_pm.return_value.lock.__aexit__ = MagicMock()
    
        trade_request = {
            "ticker": "AAPL",
            "action": "buy",
            "quantity": 10,
            "price": None,
            "strategy": "test",
        }
    
        response = self.client.post("/api/v1/trade", json=trade_request)
    
>       assert response.status_code == 200
E       assert 400 == 200
E        +  where 400 = <Response [400 Bad Request]>.status_code

tests\test_api_integration.py:67: AssertionError
---------------------------- Captured stderr call -----------------------------
2026-01-21 16:45:54,256 - src.api.server - WARNING - Validation error: [{'type': 'string_pattern_mismatch', 'loc': ('body', 'action'), 'msg': "String should match pattern '^(BUY|SELL)$'", 'input': 'buy', 'ctx': {'pattern': '^(BUY|SELL)$'}}]
2026-01-21 16:45:54,258 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/trade "HTTP/1.1 400 Bad Request"
------------------------------ Captured log call ------------------------------
WARNING  src.api.server:server.py:211 Validation error: [{'type': 'string_pattern_mismatch', 'loc': ('body', 'action'), 'msg': "String should match pattern '^(BUY|SELL)$'", 'input': 'buy', 'ctx': {'pattern': '^(BUY|SELL)$'}}]
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/v1/trade "HTTP/1.1 400 Bad Request"
___________ TestAPIIntegration.test_trade_endpoint_validation_error ___________

self = <test_api_integration.TestAPIIntegration object at 0x000001AA13A99450>

    def test_trade_endpoint_validation_error(self):
        """取引エンドポイントバリデーションエラーテスト"""
        trade_request = {
            "ticker": "",  # 無効なティッカー
            "action": "buy",
            "quantity": -10,  # 無効な数量
            "price": -100,  # 無効な価格
        }
    
        response = self.client.post("/api/v1/trade", json=trade_request)
    
        assert response.status_code == 400
        data = response.json()
>       assert "error" in data
E       AssertionError: assert 'error' in {'data': None, 'error_code': 'VALIDATION_ERROR', 'errors': [{'code': 'VALIDATION_ERROR', 'details': None, 'field': 'bo..., 'field': 'body.quantity', 'message': 'Input should be greater than 0'}], 'message': 'Request validation failed', ...}

tests\test_api_integration.py:85: AssertionError
---------------------------- Captured stderr call -----------------------------
2026-01-21 16:45:54,297 - src.api.server - WARNING - Validation error: [{'type': 'string_pattern_mismatch', 'loc': ('body', 'action'), 'msg': "String should match pattern '^(BUY|SELL)$'", 'input': 'buy', 'ctx': {'pattern': '^(BUY|SELL)$'}}, {'type': 'greater_than', 'loc': ('body', 'quantity'), 'msg': 'Input should be greater than 0', 'input': -10, 'ctx': {'gt': 0}}]
2026-01-21 16:45:54,297 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/trade "HTTP/1.1 400 Bad Request"
------------------------------ Captured log call ------------------------------
WARNING  src.api.server:server.py:211 Validation error: [{'type': 'string_pattern_mismatch', 'loc': ('body', 'action'), 'msg': "String should match pattern '^(BUY|SELL)$'", 'input': 'buy', 'ctx': {'pattern': '^(BUY|SELL)$'}}, {'type': 'greater_than', 'loc': ('body', 'quantity'), 'msg': 'Input should be greater than 0', 'input': -10, 'ctx': {'gt': 0}}]
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/v1/trade "HTTP/1.1 400 Bad Request"
_______________ TestErrorHandling.test_internal_error_handling ________________

self = <test_api_integration.TestErrorHandling object at 0x000001AA13A9B4D0>
mock_trade = <AsyncMock name='execute_trade_with_validation' id='1830944290384'>

    @patch("src.services.trading_service.TradingService.execute_trade_with_validation")
    def test_internal_error_handling(self, mock_trade):
        """内部エラーの適切なハンドリングテスト"""
        # サービス層で例外が発生
        mock_trade.side_effect = Exception("Database connection failed")
    
        trade_request = {"ticker": "AAPL", "action": "buy", "quantity": 10}
    
        response = self.client.post("/api/v1/trade", json=trade_request)
    
>       assert response.status_code == 500
E       assert 400 == 500
E        +  where 400 = <Response [400 Bad Request]>.status_code

tests\test_api_integration.py:136: AssertionError
---------------------------- Captured stderr call -----------------------------
2026-01-21 16:45:54,386 - src.api.server - WARNING - Validation error: [{'type': 'string_pattern_mismatch', 'loc': ('body', 'action'), 'msg': "String should match pattern '^(BUY|SELL)$'", 'input': 'buy', 'ctx': {'pattern': '^(BUY|SELL)$'}}]
2026-01-21 16:45:54,387 - httpx - INFO - HTTP Request: POST http://testserver/api/v1/trade "HTTP/1.1 400 Bad Request"
------------------------------ Captured log call ------------------------------
WARNING  src.api.server:server.py:211 Validation error: [{'type': 'string_pattern_mismatch', 'loc': ('body', 'action'), 'msg': "String should match pattern '^(BUY|SELL)$'", 'input': 'buy', 'ctx': {'pattern': '^(BUY|SELL)$'}}]
INFO     httpx:_client.py:1025 HTTP Request: POST http://testserver/api/v1/trade "HTTP/1.1 400 Bad Request"
_______________ TestPortfolioEndpoints.test_portfolio_endpoint ________________

self = <test_api_integration.TestPortfolioEndpoints object at 0x000001AA13AA4050>
mock_pfm = <MagicMock name='get_portfolio_manager' id='1830944803344'>

    @patch("src.api.routers.portfolio.get_portfolio_manager")
    def test_portfolio_endpoint(self, mock_pfm):
        """ポートフォリオエンドポイントテスト"""
        mock_pfm.return_value.get_portfolio_summary.return_value = {
            "total_value": 10000.0,
            "cash": 5000.0,
            "positions": [],
        }
    
        response = self.client.get("/api/v1/portfolio")
    
        assert response.status_code == 200
        data = response.json()
>       assert "total_value" in data
E       AssertionError: assert 'total_value' in {'cash': 1000000.0, 'invested_amount': 0.0, 'position_count': 0, 'total_equity': 1000000.0, ...}

tests\test_api_integration.py:164: AssertionError
---------------------------- Captured stderr call -----------------------------
2026-01-21 16:45:54,425 - httpx - INFO - HTTP Request: GET http://testserver/api/v1/portfolio "HTTP/1.1 200 OK"
------------------------------ Captured log call ------------------------------
INFO     httpx:_client.py:1025 HTTP Request: GET http://testserver/api/v1/portfolio "HTTP/1.1 200 OK"
__________________ TestChaosDrill.test_flash_crash_handling ___________________

self = <test_chaos.TestChaosDrill testMethod=test_flash_crash_handling>
mock_fetch = <MagicMock name='fetch_stock_data' id='1830952308688'>

    @patch('src.portfolio_manager.fetch_stock_data')
    def test_flash_crash_handling(self, mock_fetch):
        """
        Scenario: Flash Crash (-99% drop).
        Rebalancer logic is 'Equal Weight', so it might try to BUY the dip.
        We verify that it calculates correctly without math errors (div by zero etc).
        """
        # 1. Setup: Holding 7203.T @ 2000
        self.mock_db.get_trades.return_value = [
            {'symbol': '7203.T', 'action': 'BUY', 'quantity': 1000, 'price': 2000, 'total': 2000000, 'timestamp': '2024-01-01'}
        ]
    
        # 2. Mock Flash Crash: Price drops to 20 JPY (-99%)
        import pandas as pd
        mock_fetch.return_value = {
            '7203.T': pd.DataFrame({'Close': [20.0]})
        }
        mock_fetch.side_effect = None # Reset side effect
    
        # 3. Rebalance
        # Total Equity ~ 20 * 1000 + Cash (10M - 2M) = 20k + 8M = 8.02M
        # Target per asset (1 asset) = 8.02M * 0.95 = 7.6M
        # Current Value = 20k
        # Diff = +7.58M -> Should BUY heavily
    
        orders = self.pm.rebalance_portfolio()
    
        # 4. Verify Order Generation (Buying the dip)
>       self.assertTrue(len(orders) > 0)
E       AssertionError: False is not true

tests\test_chaos.py:76: AssertionError
_______________ TestChaosDrill.test_network_zombie_price_fetch ________________

self = <test_chaos.TestChaosDrill testMethod=test_network_zombie_price_fetch>
mock_fetch = <MagicMock name='fetch_stock_data' id='1830952236304'>

    @patch('src.portfolio_manager.fetch_stock_data')
    def test_network_zombie_price_fetch(self, mock_fetch):
        """
        Scenario: Price API is down (Zombie Network).
        System should gracefully skip tickers with missing data, not crash.
        """
        # 1. Setup Portfolio with 2 positions
        self.mock_db.get_trades.return_value = [
            {'symbol': '7203.T', 'action': 'BUY', 'quantity': 100, 'price': 2000, 'total': 200000, 'timestamp': '2024-01-01'},
            {'symbol': '9984.T', 'action': 'BUY', 'quantity': 100, 'price': 6000, 'total': 600000, 'timestamp': '2024-01-01'}
        ]
    
        # 2. Mock API Failure (Raise Exception)
        mock_fetch.side_effect = ConnectionError("Network Down")
    
        # 3. Calculate Portfolio
        # Should not raise exception
        data = self.pm.calculate_portfolio()
    
        # 4. Verify Safe Fallback
        # Tickers should be present but with current_price=0.0 or effectively filtered in Rebalance
        positions = data['positions']
>       self.assertIn('7203.T', positions)
E       AssertionError: '7203.T' not found in {}

tests\test_chaos.py:41: AssertionError
_______________ TestConfiguration.test_system_settings_defaults _______________

self = <test_config.TestConfiguration object at 0x000001AA13AA4490>
clean_env = None

    def test_system_settings_defaults(self, clean_env):
        """Test system settings with defaults."""
        settings = SystemSettings()
    
>       assert settings.cors_origins == [
            "http://localhost:3000",
            "http://localhost:3001",
        ]
E       AssertionError: assert ['http://loca...7.0.0.1:8000'] == ['http://loca...calhost:3001']
E         Left contains 4 more items, first extra item: 'http://127.0.0.1:3000'
E         Use -v to get more diff

tests\test_config.py:27: AssertionError
______________ TestConfiguration.test_trading_settings_defaults _______________

self = <test_config.TestConfiguration object at 0x000001AA13AE2D10>
clean_env = None

    def test_trading_settings_defaults(self, clean_env):
        """Test trading settings defaults."""
        settings = TradingSettings()
    
        assert settings.max_position_size > 0
>       assert settings.max_daily_loss > 0

tests\test_config.py:55: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = TradingSettings(max_daily_trades=5, daily_loss_limit_pct=-5.0, max_position_size=0.2, max_total_invested=200000.0, min...ct=0.1, trailing_stop_activation_pct=0.03, trailing_stop_callback_pct=0.02, default_period='2y', default_interval='1d')
item = 'max_daily_loss'

    def __getattr__(self, item: str) -> Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
>                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'TradingSettings' object has no attribute 'max_daily_loss'

C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\site-packages\pydantic\main.py:991: AttributeError
__________ TestConfiguration.test_config_validation_missing_api_keys __________

self = <test_config.TestConfiguration object at 0x000001AA13AE3C90>
clean_env = None

    @patch.dict(os.environ, {"GEMINI_API_KEY": "", "OPENAI_API_KEY": ""}, clear=True)
    def test_config_validation_missing_api_keys(self, clean_env):
        """Test config validation when API keys are missing."""
        # This should work since API keys are optional at config level
        # Validation happens at app startup
        config = Config()
    
>       assert config.gemini_api_key is None
E       AssertionError: assert '' is None
E        +  where '' = Config(trading=TradingSettings(max_daily_trades=5, daily_loss_limit_pct=-5.0, max_position_size=0.2, max_total_investe...'', tickers_jp=['7203.T', '9984.T', '6758.T', '8035.T', '6861.T'], tickers_us=['AAPL', 'MSFT', 'AMZN', 'NVDA', 'TSLA']).gemini_api_key

tests\test_config.py:84: AssertionError
_________ TestConfiguration.test_config_validation_cors_empty_strings _________

self = <test_config.TestConfiguration object at 0x000001AA13AE44D0>
clean_env = None

    def test_config_validation_cors_empty_strings(self, clean_env):
        """Test CORS filtering of empty strings."""
        os.environ["CORS_ORIGINS"] = '["http://localhost:3000", "", "https://example.com", ""]'
    
        config = Config()
        # Empty strings should be filtered out
>       assert config.system.cors_origins == [
            "http://localhost:3000",
            "https://example.com",
        ]
E       AssertionError: assert ['http://loca...mple.com', ''] == ['http://loca.../example.com']
E         At index 1 diff: '' != 'https://example.com'
E         Left contains 2 more items, first extra item: 'https://example.com'
E         Use -v to get more diff

tests\test_config.py:93: AssertionError
__________________ TestConfiguration.test_config_data_types ___________________

self = <test_config.TestConfiguration object at 0x000001AA13AE4CD0>
clean_env = None

    def test_config_data_types(self, clean_env):
        """Test configuration data types."""
        config = Config()
    
        # Test that all fields have correct types
        assert isinstance(config.system.cors_origins, list)
        assert isinstance(config.system.log_level, str)
        assert isinstance(config.trading.max_position_size, (int, float))
>       assert isinstance(config.trading.tickers_jp, list)

tests\test_config.py:106: 
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = TradingSettings(max_daily_trades=5, daily_loss_limit_pct=-5.0, max_position_size=0.2, max_total_invested=200000.0, min...ct=0.1, trailing_stop_activation_pct=0.03, trailing_stop_callback_pct=0.02, default_period='2y', default_interval='1d')
item = 'tickers_jp'

    def __getattr__(self, item: str) -> Any:
        private_attributes = object.__getattribute__(self, '__private_attributes__')
        if item in private_attributes:
            attribute = private_attributes[item]
            if hasattr(attribute, '__get__'):
                return attribute.__get__(self, type(self))  # type: ignore
    
            try:
                # Note: self.__pydantic_private__ cannot be None if self.__private_attributes__ has items
                return self.__pydantic_private__[item]  # type: ignore
            except KeyError as exc:
                raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
        else:
            # `__pydantic_extra__` can fail to be set if the model is not yet fully initialized.
            # See `BaseModel.__repr_args__` for more details
            try:
                pydantic_extra = object.__getattribute__(self, '__pydantic_extra__')
            except AttributeError:
                pydantic_extra = None
    
            if pydantic_extra:
                try:
                    return pydantic_extra[item]
                except KeyError as exc:
                    raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}') from exc
            else:
                if hasattr(self.__class__, item):
                    return super().__getattribute__(item)  # Raises AttributeError if appropriate
                else:
                    # this is the current error
>                   raise AttributeError(f'{type(self).__name__!r} object has no attribute {item!r}')
E                   AttributeError: 'TradingSettings' object has no attribute 'tickers_jp'

C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\site-packages\pydantic\main.py:991: AttributeError
__________________________ test_websocket_connection __________________________

    @pytest.mark.asyncio
    async def test_websocket_connection():
        """Test that WebSocket endpoint accepts connections."""
        app = create_app()
        client = TestClient(app)
    
        # Test that the WebSocket endpoint exists (basic connectivity test)
        # Note: FastAPI TestClient doesn't fully support WebSocket testing
        # This is a basic smoke test
    
        response = client.get("/api/v1/health")
        assert response.status_code == 200
>       assert response.json()["status"] == "healthy"
E       KeyError: 'status'

tests\test_websocket.py:24: KeyError
---------------------------- Captured stderr call -----------------------------
2026-01-21 16:45:55,656 - httpx - INFO - HTTP Request: GET http://testserver/api/v1/health "HTTP/1.1 200 OK"
------------------------------ Captured log call ------------------------------
INFO     httpx:_client.py:1025 HTTP Request: GET http://testserver/api/v1/health "HTTP/1.1 200 OK"
_____________________ test_regime_detector_initialization _____________________

    def test_regime_detector_initialization():
        """Test that regime detector can be initialized."""
>       from src.api.routers.websocket import regime_detector
E       ImportError: cannot import name 'regime_detector' from 'src.api.routers.websocket' (C:\gemini-desktop\Ult\backend\src\api\routers\websocket.py)

tests\test_websocket.py:29: ImportError
________________________ test_websocket_router_import _________________________

    def test_websocket_router_import():
        """Test that WebSocket router can be imported."""
        from src.api.routers.websocket import router
    
        assert router is not None
        # Check that it has the WebSocket endpoint
        routes = [route.path for route in router.routes]
>       assert "/ws/regime" in routes
E       AssertionError: assert '/ws/regime' in ['/ws/synapse', '/ws/status']

tests\test_websocket.py:43: AssertionError
___________________________ test_broadcast_function ___________________________

    def test_broadcast_function():
        """Test the broadcast function doesn't crash."""
>       from src.api.routers.websocket import broadcast_regime_update
E       ImportError: cannot import name 'broadcast_regime_update' from 'src.api.routers.websocket' (C:\gemini-desktop\Ult\backend\src\api\routers\websocket.py)

tests\test_websocket.py:48: ImportError
============================== warnings summary ===============================
..\..\..\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\site-packages\pydantic\fields.py:1093
..\..\..\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\site-packages\pydantic\fields.py:1093
  C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\site-packages\pydantic\fields.py:1093: PydanticDeprecatedSince20: Using extra keyword arguments on `Field` is deprecated and will be removed. Use `json_schema_extra` instead. (Extra keys: 'env'). Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warn(

..\..\..\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\site-packages\pydantic\_internal\_config.py:323
  C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\site-packages\pydantic\_internal\_config.py:323: PydanticDeprecatedSince20: Support for class-based `config` is deprecated, use ConfigDict instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warnings.warn(DEPRECATION_MESSAGE, DeprecationWarning)

..\..\..\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\site-packages\pydantic\_internal\_generate_schema.py:298
..\..\..\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\site-packages\pydantic\_internal\_generate_schema.py:298
..\..\..\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\site-packages\pydantic\_internal\_generate_schema.py:298
..\..\..\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\site-packages\pydantic\_internal\_generate_schema.py:298
..\..\..\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\site-packages\pydantic\_internal\_generate_schema.py:298
  C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\site-packages\pydantic\_internal\_generate_schema.py:298: PydanticDeprecatedSince20: `json_encoders` is deprecated. See https://docs.pydantic.dev/2.11/concepts/serialization/#custom-serializers for alternatives. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    warnings.warn(

..\..\..\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\site-packages\streamlit\elements\image.py:22
  C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\site-packages\streamlit\elements\image.py:22: DeprecationWarning: 'imghdr' is deprecated and slated for removal in Python 3.13
    import imghdr

tests/test_config.py::TestConfiguration::test_config_json_serialization
  C:\gemini-desktop\Ult\backend\tests\test_config.py:114: PydanticDeprecatedSince20: The `json` method is deprecated; use `model_dump_json` instead. Deprecated in Pydantic V2.0 to be removed in V3.0. See Pydantic V2 Migration Guide at https://errors.pydantic.dev/2.11/migration/
    json_str = config.json()

-- Docs: https://docs.pytest.org/en/stable/how-to/capture-warnings.html
=========================== short test summary info ===========================
FAILED tests/test_agents.py::TestAgents::test_autonomous_agent_initialization
FAILED tests/test_agents.py::TestAgents::test_consensus_engine_initialization
FAILED tests/test_agents.py::TestAgents::test_consensus_engine_add_agent - At...
FAILED tests/test_agents.py::TestAgents::test_consensus_engine_make_decision
FAILED tests/test_agents.py::TestAgents::test_news_agent_sentiment_analysis
FAILED tests/test_agents.py::TestAgents::test_vision_agent_initialization - A...
FAILED tests/test_agents.py::TestAgents::test_agent_state_transitions - Attri...
FAILED tests/test_api_endpoints.py::TestAPIEndpoints::test_health_endpoint - ...
FAILED tests/test_api_endpoints.py::TestAPIEndpoints::test_portfolio_endpoints
FAILED tests/test_api_endpoints.py::TestAPIEndpoints::test_market_endpoints
FAILED tests/test_api_endpoints.py::TestAPIEndpoints::test_error_handling - A...
FAILED tests/test_api_endpoints.py::TestAPIEndpoints::test_security_headers
FAILED tests/test_api_integration.py::TestAPIIntegration::test_health_endpoint
FAILED tests/test_api_integration.py::TestAPIIntegration::test_root_endpoint
FAILED tests/test_api_integration.py::TestAPIIntegration::test_trade_endpoint_success
FAILED tests/test_api_integration.py::TestAPIIntegration::test_trade_endpoint_validation_error
FAILED tests/test_api_integration.py::TestErrorHandling::test_internal_error_handling
FAILED tests/test_api_integration.py::TestPortfolioEndpoints::test_portfolio_endpoint
FAILED tests/test_chaos.py::TestChaosDrill::test_flash_crash_handling - Asser...
FAILED tests/test_chaos.py::TestChaosDrill::test_network_zombie_price_fetch
FAILED tests/test_config.py::TestConfiguration::test_system_settings_defaults
FAILED tests/test_config.py::TestConfiguration::test_trading_settings_defaults
FAILED tests/test_config.py::TestConfiguration::test_config_validation_missing_api_keys
FAILED tests/test_config.py::TestConfiguration::test_config_validation_cors_empty_strings
FAILED tests/test_config.py::TestConfiguration::test_config_data_types - Attr...
FAILED tests/test_websocket.py::test_websocket_connection - KeyError: 'status'
FAILED tests/test_websocket.py::test_regime_detector_initialization - ImportE...
FAILED tests/test_websocket.py::test_websocket_router_import - AssertionError...
FAILED tests/test_websocket.py::test_broadcast_function - ImportError: cannot...
================= 29 failed, 51 passed, 10 warnings in 11.35s =================

[*********************100%***********************]  1 of 1 completed
[*********************100%***********************]  1 of 1 completed

--- Logging error ---
Traceback (most recent call last):
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\logging\__init__.py", line 1113, in emit
    stream.write(msg + self.terminator)
ValueError: I/O operation on closed file.
Call stack:
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\threading.py", line 995, in _bootstrap
    self._bootstrap_inner()
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\threading.py", line 1038, in _bootstrap_inner
    self.run()
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\threading.py", line 975, in run
    self._target(*self._args, **self._kwargs)
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\concurrent\futures\thread.py", line 83, in _worker
    work_item.run()
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\concurrent\futures\thread.py", line 58, in run
    result = self.fn(*self.args, **self.kwargs)
  File "C:\gemini-desktop\Ult\backend\src\core\agent_loop.py", line 202, in _perceive
    data_map = fetch_stock_data([self.target_ticker], period="1y", interval="1d")
  File "C:\gemini-desktop\Ult\backend\src\utils\error_handler.py", line 309, in wrapper
    return ErrorRecovery.retry_with_backoff(
  File "C:\gemini-desktop\Ult\backend\src\utils\error_handler.py", line 136, in retry_with_backoff
    return func()
  File "C:\gemini-desktop\Ult\backend\src\utils\error_handler.py", line 310, in <lambda>
    lambda: f(*args, **kwargs),
  File "C:\gemini-desktop\Ult\backend\src\data_temp\data_loader.py", line 497, in fetch_stock_data
    downloaded = _download_missing_data(need_refresh, period, interval, start_date, db)
  File "C:\gemini-desktop\Ult\backend\src\data_temp\data_loader.py", line 531, in _download_missing_data
    return _download_and_cache_missing(tickers, period, interval, start_date, db)
  File "C:\gemini-desktop\Ult\backend\src\data_temp\data_loader.py", line 298, in _download_and_cache_missing
    processed = process_downloaded_data(raw, tickers)
  File "C:\gemini-desktop\Ult\backend\src\data_temp\data_loader.py", line 362, in process_downloaded_data
    logger.info(
Message: "Ticker 7203.T downloaded 245 points. Columns: ['Open', 'High', 'Low', 'Close', 'Volume']"
Arguments: ()
--- Logging error ---
Traceback (most recent call last):
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\logging\__init__.py", line 1113, in emit
    stream.write(msg + self.terminator)
ValueError: I/O operation on closed file.
Call stack:
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\threading.py", line 995, in _bootstrap
    self._bootstrap_inner()
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\threading.py", line 1038, in _bootstrap_inner
    self.run()
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\threading.py", line 975, in run
    self._target(*self._args, **self._kwargs)
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\concurrent\futures\thread.py", line 83, in _worker
    work_item.run()
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\concurrent\futures\thread.py", line 58, in run
    result = self.fn(*self.args, **self.kwargs)
  File "C:\gemini-desktop\Ult\backend\src\core\agent_loop.py", line 202, in _perceive
    data_map = fetch_stock_data([self.target_ticker], period="1y", interval="1d")
  File "C:\gemini-desktop\Ult\backend\src\utils\error_handler.py", line 309, in wrapper
    return ErrorRecovery.retry_with_backoff(
  File "C:\gemini-desktop\Ult\backend\src\utils\error_handler.py", line 136, in retry_with_backoff
    return func()
  File "C:\gemini-desktop\Ult\backend\src\utils\error_handler.py", line 310, in <lambda>
    lambda: f(*args, **kwargs),
  File "C:\gemini-desktop\Ult\backend\src\data_temp\data_loader.py", line 497, in fetch_stock_data
    downloaded = _download_missing_data(need_refresh, period, interval, start_date, db)
  File "C:\gemini-desktop\Ult\backend\src\data_temp\data_loader.py", line 531, in _download_missing_data
    return _download_and_cache_missing(tickers, period, interval, start_date, db)
  File "C:\gemini-desktop\Ult\backend\src\data_temp\data_loader.py", line 298, in _download_and_cache_missing
    processed = process_downloaded_data(raw, tickers)
  File "C:\gemini-desktop\Ult\backend\src\data_temp\data_loader.py", line 362, in process_downloaded_data
    logger.info(
Message: "Ticker 7203.T downloaded 245 points. Columns: ['Open', 'High', 'Low', 'Close', 'Volume']"
Arguments: ()
--- Logging error ---
Traceback (most recent call last):
  File "C:\gemini-desktop\Ult\backend\src\data_temp\data_manager.py", line 82, in save_data
    cursor.execute(f"DELETE FROM stock_prices WHERE ticker = '{ticker}'")
sqlite3.OperationalError: no such table: stock_prices

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\logging\__init__.py", line 1113, in emit
    stream.write(msg + self.terminator)
ValueError: I/O operation on closed file.
Call stack:
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\threading.py", line 995, in _bootstrap
    self._bootstrap_inner()
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\threading.py", line 1038, in _bootstrap_inner
    self.run()
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\threading.py", line 975, in run
    self._target(*self._args, **self._kwargs)
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\concurrent\futures\thread.py", line 83, in _worker
    work_item.run()
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\concurrent\futures\thread.py", line 58, in run
    result = self.fn(*self.args, **self.kwargs)
  File "C:\gemini-desktop\Ult\backend\src\core\agent_loop.py", line 202, in _perceive
    data_map = fetch_stock_data([self.target_ticker], period="1y", interval="1d")
  File "C:\gemini-desktop\Ult\backend\src\utils\error_handler.py", line 309, in wrapper
    return ErrorRecovery.retry_with_backoff(
  File "C:\gemini-desktop\Ult\backend\src\utils\error_handler.py", line 136, in retry_with_backoff
    return func()
  File "C:\gemini-desktop\Ult\backend\src\utils\error_handler.py", line 310, in <lambda>
    lambda: f(*args, **kwargs),
  File "C:\gemini-desktop\Ult\backend\src\data_temp\data_loader.py", line 497, in fetch_stock_data
    downloaded = _download_missing_data(need_refresh, period, interval, start_date, db)
  File "C:\gemini-desktop\Ult\backend\src\data_temp\data_loader.py", line 531, in _download_missing_data
    return _download_and_cache_missing(tickers, period, interval, start_date, db)
  File "C:\gemini-desktop\Ult\backend\src\data_temp\data_loader.py", line 305, in _download_and_cache_missing
    db.save_data(df, ticker)
  File "C:\gemini-desktop\Ult\backend\src\data_temp\data_manager.py", line 90, in save_data
    logger.error(f"Error saving data for {ticker}: {e}")
Message: 'Error saving data for 7203.T: no such table: stock_prices'
Arguments: ()
--- Logging error ---
Traceback (most recent call last):
  File "C:\gemini-desktop\Ult\backend\src\data_temp\data_manager.py", line 82, in save_data
    cursor.execute(f"DELETE FROM stock_prices WHERE ticker = '{ticker}'")
sqlite3.OperationalError: no such table: stock_prices

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\logging\__init__.py", line 1113, in emit
    stream.write(msg + self.terminator)
ValueError: I/O operation on closed file.
Call stack:
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\threading.py", line 995, in _bootstrap
    self._bootstrap_inner()
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\threading.py", line 1038, in _bootstrap_inner
    self.run()
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\threading.py", line 975, in run
    self._target(*self._args, **self._kwargs)
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\concurrent\futures\thread.py", line 83, in _worker
    work_item.run()
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\concurrent\futures\thread.py", line 58, in run
    result = self.fn(*self.args, **self.kwargs)
  File "C:\gemini-desktop\Ult\backend\src\core\agent_loop.py", line 202, in _perceive
    data_map = fetch_stock_data([self.target_ticker], period="1y", interval="1d")
  File "C:\gemini-desktop\Ult\backend\src\utils\error_handler.py", line 309, in wrapper
    return ErrorRecovery.retry_with_backoff(
  File "C:\gemini-desktop\Ult\backend\src\utils\error_handler.py", line 136, in retry_with_backoff
    return func()
  File "C:\gemini-desktop\Ult\backend\src\utils\error_handler.py", line 310, in <lambda>
    lambda: f(*args, **kwargs),
  File "C:\gemini-desktop\Ult\backend\src\data_temp\data_loader.py", line 497, in fetch_stock_data
    downloaded = _download_missing_data(need_refresh, period, interval, start_date, db)
  File "C:\gemini-desktop\Ult\backend\src\data_temp\data_loader.py", line 531, in _download_missing_data
    return _download_and_cache_missing(tickers, period, interval, start_date, db)
  File "C:\gemini-desktop\Ult\backend\src\data_temp\data_loader.py", line 305, in _download_and_cache_missing
    db.save_data(df, ticker)
  File "C:\gemini-desktop\Ult\backend\src\data_temp\data_manager.py", line 90, in save_data
    logger.error(f"Error saving data for {ticker}: {e}")
Message: 'Error saving data for 7203.T: no such table: stock_prices'
Arguments: ()
--- Logging error ---
Traceback (most recent call last):
  File "C:\gemini-desktop\Ult\backend\src\data_temp\data_loader.py", line 307, in _download_and_cache_missing
    if not refreshed.empty:
           ^^^^^^^^^^^^^^^
AttributeError: 'NoneType' object has no attribute 'empty'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\logging\__init__.py", line 1113, in emit
    stream.write(msg + self.terminator)
ValueError: I/O operation on closed file.
Call stack:
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\threading.py", line 995, in _bootstrap
    self._bootstrap_inner()
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\threading.py", line 1038, in _bootstrap_inner
    self.run()
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\threading.py", line 975, in run
    self._target(*self._args, **self._kwargs)
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\concurrent\futures\thread.py", line 83, in _worker
    work_item.run()
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\concurrent\futures\thread.py", line 58, in run
    result = self.fn(*self.args, **self.kwargs)
  File "C:\gemini-desktop\Ult\backend\src\core\agent_loop.py", line 202, in _perceive
    data_map = fetch_stock_data([self.target_ticker], period="1y", interval="1d")
  File "C:\gemini-desktop\Ult\backend\src\utils\error_handler.py", line 309, in wrapper
    return ErrorRecovery.retry_with_backoff(
  File "C:\gemini-desktop\Ult\backend\src\utils\error_handler.py", line 136, in retry_with_backoff
    return func()
  File "C:\gemini-desktop\Ult\backend\src\utils\error_handler.py", line 310, in <lambda>
    lambda: f(*args, **kwargs),
  File "C:\gemini-desktop\Ult\backend\src\data_temp\data_loader.py", line 497, in fetch_stock_data
    downloaded = _download_missing_data(need_refresh, period, interval, start_date, db)
  File "C:\gemini-desktop\Ult\backend\src\data_temp\data_loader.py", line 531, in _download_missing_data
    return _download_and_cache_missing(tickers, period, interval, start_date, db)
  File "C:\gemini-desktop\Ult\backend\src\data_temp\data_loader.py", line 310, in _download_and_cache_missing
    logger.error("Error saving/loading data for %s: %s", ticker, exc)
Message: 'Error saving/loading data for %s: %s'
Arguments: ('7203.T', AttributeError("'NoneType' object has no attribute 'empty'"))
--- Logging error ---
Traceback (most recent call last):
  File "C:\gemini-desktop\Ult\backend\src\data_temp\data_loader.py", line 307, in _download_and_cache_missing
    if not refreshed.empty:
           ^^^^^^^^^^^^^^^
AttributeError: 'NoneType' object has no attribute 'empty'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\logging\__init__.py", line 1113, in emit
    stream.write(msg + self.terminator)
ValueError: I/O operation on closed file.
Call stack:
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\threading.py", line 995, in _bootstrap
    self._bootstrap_inner()
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\threading.py", line 1038, in _bootstrap_inner
    self.run()
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\threading.py", line 975, in run
    self._target(*self._args, **self._kwargs)
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\concurrent\futures\thread.py", line 83, in _worker
    work_item.run()
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\concurrent\futures\thread.py", line 58, in run
    result = self.fn(*self.args, **self.kwargs)
  File "C:\gemini-desktop\Ult\backend\src\core\agent_loop.py", line 202, in _perceive
    data_map = fetch_stock_data([self.target_ticker], period="1y", interval="1d")
  File "C:\gemini-desktop\Ult\backend\src\utils\error_handler.py", line 309, in wrapper
    return ErrorRecovery.retry_with_backoff(
  File "C:\gemini-desktop\Ult\backend\src\utils\error_handler.py", line 136, in retry_with_backoff
    return func()
  File "C:\gemini-desktop\Ult\backend\src\utils\error_handler.py", line 310, in <lambda>
    lambda: f(*args, **kwargs),
  File "C:\gemini-desktop\Ult\backend\src\data_temp\data_loader.py", line 497, in fetch_stock_data
    downloaded = _download_missing_data(need_refresh, period, interval, start_date, db)
  File "C:\gemini-desktop\Ult\backend\src\data_temp\data_loader.py", line 531, in _download_missing_data
    return _download_and_cache_missing(tickers, period, interval, start_date, db)
  File "C:\gemini-desktop\Ult\backend\src\data_temp\data_loader.py", line 310, in _download_and_cache_missing
    logger.error("Error saving/loading data for %s: %s", ticker, exc)
Message: 'Error saving/loading data for %s: %s'
Arguments: ('7203.T', AttributeError("'NoneType' object has no attribute 'empty'"))
--- Logging error ---
Traceback (most recent call last):
  File "C:\gemini-desktop\Ult\backend\src\data_temp\data_loader.py", line 307, in _download_and_cache_missing
    if not refreshed.empty:
           ^^^^^^^^^^^^^^^
AttributeError: 'NoneType' object has no attribute 'empty'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\gemini-desktop\Ult\backend\src\data_temp\data_loader.py", line 531, in _download_missing_data
    return _download_and_cache_missing(tickers, period, interval, start_date, db)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\gemini-desktop\Ult\backend\src\data_temp\data_loader.py", line 311, in _download_and_cache_missing
    from .errors import DataLoadError
ModuleNotFoundError: No module named 'src.data_temp.errors'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\logging\__init__.py", line 1113, in emit
    stream.write(msg + self.terminator)
ValueError: I/O operation on closed file.
Call stack:
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\threading.py", line 995, in _bootstrap
    self._bootstrap_inner()
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\threading.py", line 1038, in _bootstrap_inner
    self.run()
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\threading.py", line 975, in run
    self._target(*self._args, **self._kwargs)
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\concurrent\futures\thread.py", line 83, in _worker
    work_item.run()
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\concurrent\futures\thread.py", line 58, in run
    result = self.fn(*self.args, **self.kwargs)
  File "C:\gemini-desktop\Ult\backend\src\core\agent_loop.py", line 202, in _perceive
    data_map = fetch_stock_data([self.target_ticker], period="1y", interval="1d")
  File "C:\gemini-desktop\Ult\backend\src\utils\error_handler.py", line 309, in wrapper
    return ErrorRecovery.retry_with_backoff(
  File "C:\gemini-desktop\Ult\backend\src\utils\error_handler.py", line 136, in retry_with_backoff
    return func()
  File "C:\gemini-desktop\Ult\backend\src\utils\error_handler.py", line 310, in <lambda>
    lambda: f(*args, **kwargs),
  File "C:\gemini-desktop\Ult\backend\src\data_temp\data_loader.py", line 497, in fetch_stock_data
    downloaded = _download_missing_data(need_refresh, period, interval, start_date, db)
  File "C:\gemini-desktop\Ult\backend\src\data_temp\data_loader.py", line 533, in _download_missing_data
    logger.error(f"Error downloading and caching missing data: {e}")
Message: "Error downloading and caching missing data: No module named 'src.data_temp.errors'"
Arguments: ()
--- Logging error ---
Traceback (most recent call last):
  File "C:\gemini-desktop\Ult\backend\src\data_temp\data_loader.py", line 307, in _download_and_cache_missing
    if not refreshed.empty:
           ^^^^^^^^^^^^^^^
AttributeError: 'NoneType' object has no attribute 'empty'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\gemini-desktop\Ult\backend\src\data_temp\data_loader.py", line 531, in _download_missing_data
    return _download_and_cache_missing(tickers, period, interval, start_date, db)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "C:\gemini-desktop\Ult\backend\src\data_temp\data_loader.py", line 311, in _download_and_cache_missing
    from .errors import DataLoadError
ModuleNotFoundError: No module named 'src.data_temp.errors'

During handling of the above exception, another exception occurred:

Traceback (most recent call last):
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\logging\__init__.py", line 1113, in emit
    stream.write(msg + self.terminator)
ValueError: I/O operation on closed file.
Call stack:
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\threading.py", line 995, in _bootstrap
    self._bootstrap_inner()
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\threading.py", line 1038, in _bootstrap_inner
    self.run()
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\threading.py", line 975, in run
    self._target(*self._args, **self._kwargs)
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\concurrent\futures\thread.py", line 83, in _worker
    work_item.run()
  File "C:\Users\neoen\AppData\Local\Programs\Python\Python311\Lib\concurrent\futures\thread.py", line 58, in run
    result = self.fn(*self.args, **self.kwargs)
  File "C:\gemini-desktop\Ult\backend\src\core\agent_loop.py", line 202, in _perceive
    data_map = fetch_stock_data([self.target_ticker], period="1y", interval="1d")
  File "C:\gemini-desktop\Ult\backend\src\utils\error_handler.py", line 309, in wrapper
    return ErrorRecovery.retry_with_backoff(
  File "C:\gemini-desktop\Ult\backend\src\utils\error_handler.py", line 136, in retry_with_backoff
    return func()
  File "C:\gemini-desktop\Ult\backend\src\utils\error_handler.py", line 310, in <lambda>
    lambda: f(*args, **kwargs),
  File "C:\gemini-desktop\Ult\backend\src\data_temp\data_loader.py", line 497, in fetch_stock_data
    downloaded = _download_missing_data(need_refresh, period, interval, start_date, db)
  File "C:\gemini-desktop\Ult\backend\src\data_temp\data_loader.py", line 533, in _download_missing_data
    logger.error(f"Error downloading and caching missing data: {e}")
Message: "Error downloading and caching missing data: No module named 'src.data_temp.errors'"
Arguments: ()
