
> trading-platform@0.1.0 test
> jest

PASS app/lib/risk/__tests__/AdvancedRiskManager.test.ts
PASS app/lib/services/__tests__/feature-calculation-service.test.ts
PASS app/lib/execution/__tests__/SlippageMonitor.test.ts
  ● Console

    console.warn
      [2026-02-08T08:47:04.290Z] [WARN]  [SlippageMonitor] Order non-existent not found

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at SlippageMonitor.warn [as recordExecution] (app/lib/execution/SlippageMonitor.ts:123:14)
      at Object.recordExecution (app/lib/execution/__tests__/SlippageMonitor.test.ts:725:30)

FAIL app/api/trading/__tests__/route.test.ts
  ● Console

    console.error
      [2026-02-08T08:47:04.821Z] [ERROR]  [2026-02-08T08:47:04.794Z] [trading/api] Error: Error: Failed to start
          at Object.<anonymous> (/app/trading-platform/app/api/trading/__tests__/route.test.ts:85:55)
          at Promise.then.completed (/app/trading-platform/node_modules/jest-circus/build/utils.js:298:28)
          at new Promise (<anonymous>)
          at callAsyncCircusFn (/app/trading-platform/node_modules/jest-circus/build/utils.js:231:10)
          at _callCircusTest (/app/trading-platform/node_modules/jest-circus/build/run.js:316:40)
          at processTicksAndRejections (node:internal/process/task_queues:105:5)
          at _runTest (/app/trading-platform/node_modules/jest-circus/build/run.js:252:3)
          at _runTestsForDescribeBlock (/app/trading-platform/node_modules/jest-circus/build/run.js:126:9)
          at _runTestsForDescribeBlock (/app/trading-platform/node_modules/jest-circus/build/run.js:121:9)
          at _runTestsForDescribeBlock (/app/trading-platform/node_modules/jest-circus/build/run.js:121:9)
          at run (/app/trading-platform/node_modules/jest-circus/build/run.js:71:3)
          at runAndTransformResultsToJestFormat (/app/trading-platform/node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapterInit.js:122:21)
          at jestAdapter (/app/trading-platform/node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapter.js:79:19)
          at runTestInternal (/app/trading-platform/node_modules/jest-runner/build/runTest.js:367:16)
          at runTest (/app/trading-platform/node_modules/jest-runner/build/runTest.js:444:34)
          at Object.worker (/app/trading-platform/node_modules/jest-runner/build/testWorker.js:106:12)

      94 |     const formatted = this.formatMessage('error', message, context);
      95 |     if (this.config.enableConsole) {
    > 96 |       console.error(formatted, error?.stack ?? error?.message ?? '');
         |               ^
      97 |     }
      98 |     this.addLog({
      99 |       timestamp: new Date(),

      at Logger.error (app/core/logger.ts:96:15)
      at error (app/lib/errors.ts:557:12)
      at handleApiError (app/lib/error-handler.ts:248:21)
      at POST (app/api/trading/route.ts:358:26)
      at Object.<anonymous> (app/api/trading/__tests__/route.test.ts:88:19)

    console.error
      [2026-02-08T08:47:04.841Z] [ERROR]  [2026-02-08T08:47:04.840Z] [trading/api] Error: Error: Failed to stop
          at Object.<anonymous> (/app/trading-platform/app/api/trading/__tests__/route.test.ts:108:54)
          at Promise.then.completed (/app/trading-platform/node_modules/jest-circus/build/utils.js:298:28)
          at new Promise (<anonymous>)
          at callAsyncCircusFn (/app/trading-platform/node_modules/jest-circus/build/utils.js:231:10)
          at _callCircusTest (/app/trading-platform/node_modules/jest-circus/build/run.js:316:40)
          at processTicksAndRejections (node:internal/process/task_queues:105:5)
          at _runTest (/app/trading-platform/node_modules/jest-circus/build/run.js:252:3)
          at _runTestsForDescribeBlock (/app/trading-platform/node_modules/jest-circus/build/run.js:126:9)
          at _runTestsForDescribeBlock (/app/trading-platform/node_modules/jest-circus/build/run.js:121:9)
          at _runTestsForDescribeBlock (/app/trading-platform/node_modules/jest-circus/build/run.js:121:9)
          at run (/app/trading-platform/node_modules/jest-circus/build/run.js:71:3)
          at runAndTransformResultsToJestFormat (/app/trading-platform/node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapterInit.js:122:21)
          at jestAdapter (/app/trading-platform/node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapter.js:79:19)
          at runTestInternal (/app/trading-platform/node_modules/jest-runner/build/runTest.js:367:16)
          at runTest (/app/trading-platform/node_modules/jest-runner/build/runTest.js:444:34)
          at Object.worker (/app/trading-platform/node_modules/jest-runner/build/testWorker.js:106:12)

      94 |     const formatted = this.formatMessage('error', message, context);
      95 |     if (this.config.enableConsole) {
    > 96 |       console.error(formatted, error?.stack ?? error?.message ?? '');
         |               ^
      97 |     }
      98 |     this.addLog({
      99 |       timestamp: new Date(),

      at Logger.error (app/core/logger.ts:96:15)
      at error (app/lib/errors.ts:557:12)
      at handleApiError (app/lib/error-handler.ts:248:21)
      at POST (app/api/trading/route.ts:358:26)
      at Object.<anonymous> (app/api/trading/__tests__/route.test.ts:111:19)

    console.error
      [2026-02-08T08:47:04.886Z] [ERROR]  [2026-02-08T08:47:04.886Z] [trading/api] Error: Error: Insufficient funds
          at Object.<anonymous> (/app/trading-platform/app/api/trading/__tests__/route.test.ts:313:9)
          at Promise.then.completed (/app/trading-platform/node_modules/jest-circus/build/utils.js:298:28)
          at new Promise (<anonymous>)
          at callAsyncCircusFn (/app/trading-platform/node_modules/jest-circus/build/utils.js:231:10)
          at _callCircusTest (/app/trading-platform/node_modules/jest-circus/build/run.js:316:40)
          at processTicksAndRejections (node:internal/process/task_queues:105:5)
          at _runTest (/app/trading-platform/node_modules/jest-circus/build/run.js:252:3)
          at _runTestsForDescribeBlock (/app/trading-platform/node_modules/jest-circus/build/run.js:126:9)
          at _runTestsForDescribeBlock (/app/trading-platform/node_modules/jest-circus/build/run.js:121:9)
          at _runTestsForDescribeBlock (/app/trading-platform/node_modules/jest-circus/build/run.js:121:9)
          at run (/app/trading-platform/node_modules/jest-circus/build/run.js:71:3)
          at runAndTransformResultsToJestFormat (/app/trading-platform/node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapterInit.js:122:21)
          at jestAdapter (/app/trading-platform/node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapter.js:79:19)
          at runTestInternal (/app/trading-platform/node_modules/jest-runner/build/runTest.js:367:16)
          at runTest (/app/trading-platform/node_modules/jest-runner/build/runTest.js:444:34)
          at Object.worker (/app/trading-platform/node_modules/jest-runner/build/testWorker.js:106:12)

      94 |     const formatted = this.formatMessage('error', message, context);
      95 |     if (this.config.enableConsole) {
    > 96 |       console.error(formatted, error?.stack ?? error?.message ?? '');
         |               ^
      97 |     }
      98 |     this.addLog({
      99 |       timestamp: new Date(),

      at Logger.error (app/core/logger.ts:96:15)
      at error (app/lib/errors.ts:557:12)
      at handleApiError (app/lib/error-handler.ts:248:21)
      at POST (app/api/trading/route.ts:358:26)
      at Object.<anonymous> (app/api/trading/__tests__/route.test.ts:322:19)

    console.error
      [2026-02-08T08:47:04.894Z] [ERROR]  [2026-02-08T08:47:04.894Z] [trading/api] Error: Error: Position not found
          at Object.<anonymous> (/app/trading-platform/app/api/trading/__tests__/route.test.ts:370:9)
          at Promise.then.completed (/app/trading-platform/node_modules/jest-circus/build/utils.js:298:28)
          at new Promise (<anonymous>)
          at callAsyncCircusFn (/app/trading-platform/node_modules/jest-circus/build/utils.js:231:10)
          at _callCircusTest (/app/trading-platform/node_modules/jest-circus/build/run.js:316:40)
          at processTicksAndRejections (node:internal/process/task_queues:105:5)
          at _runTest (/app/trading-platform/node_modules/jest-circus/build/run.js:252:3)
          at _runTestsForDescribeBlock (/app/trading-platform/node_modules/jest-circus/build/run.js:126:9)
          at _runTestsForDescribeBlock (/app/trading-platform/node_modules/jest-circus/build/run.js:121:9)
          at _runTestsForDescribeBlock (/app/trading-platform/node_modules/jest-circus/build/run.js:121:9)
          at run (/app/trading-platform/node_modules/jest-circus/build/run.js:71:3)
          at runAndTransformResultsToJestFormat (/app/trading-platform/node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapterInit.js:122:21)
          at jestAdapter (/app/trading-platform/node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapter.js:79:19)
          at runTestInternal (/app/trading-platform/node_modules/jest-runner/build/runTest.js:367:16)
          at runTest (/app/trading-platform/node_modules/jest-runner/build/runTest.js:444:34)
          at Object.worker (/app/trading-platform/node_modules/jest-runner/build/testWorker.js:106:12)

      94 |     const formatted = this.formatMessage('error', message, context);
      95 |     if (this.config.enableConsole) {
    > 96 |       console.error(formatted, error?.stack ?? error?.message ?? '');
         |               ^
      97 |     }
      98 |     this.addLog({
      99 |       timestamp: new Date(),

      at Logger.error (app/core/logger.ts:96:15)
      at error (app/lib/errors.ts:557:12)
      at handleApiError (app/lib/error-handler.ts:248:21)
      at POST (app/api/trading/route.ts:358:26)
      at Object.<anonymous> (app/api/trading/__tests__/route.test.ts:377:19)

    console.error
      [2026-02-08T08:47:04.931Z] [ERROR]  [2026-02-08T08:47:04.931Z] [trading/api] Unknown error: Error: String error
          at logError (/app/trading-platform/app/lib/errors.ts:559:97)
          at handleApiError (/app/trading-platform/app/lib/error-handler.ts:248:21)
          at POST (/app/trading-platform/app/api/trading/route.ts:358:26)
          at processTicksAndRejections (node:internal/process/task_queues:105:5)
          at Object.<anonymous> (/app/trading-platform/app/api/trading/__tests__/route.test.ts:657:19)

      94 |     const formatted = this.formatMessage('error', message, context);
      95 |     if (this.config.enableConsole) {
    > 96 |       console.error(formatted, error?.stack ?? error?.message ?? '');
         |               ^
      97 |     }
      98 |     this.addLog({
      99 |       timestamp: new Date(),

      at Logger.error (app/core/logger.ts:96:15)
      at error (app/lib/errors.ts:559:12)
      at handleApiError (app/lib/error-handler.ts:248:21)
      at POST (app/api/trading/route.ts:358:26)
      at Object.<anonymous> (app/api/trading/__tests__/route.test.ts:657:19)

    console.error
      [2026-02-08T08:47:04.976Z] [ERROR]  [2026-02-08T08:47:04.975Z] [trading/api] Error: Error: Platform error
          at Object.<anonymous> (/app/trading-platform/app/api/trading/__tests__/route.test.ts:693:13)
          at /app/trading-platform/node_modules/jest-environment-node/node_modules/jest-mock/build/index.js:397:39
          at Object.<anonymous> (/app/trading-platform/node_modules/jest-environment-node/node_modules/jest-mock/build/index.js:404:13)
          at Object.mockConstructor [as getStatus] (/app/trading-platform/node_modules/jest-environment-node/node_modules/jest-mock/build/index.js:148:19)
          at getStatus (/app/trading-platform/app/api/trading/route.ts:122:29)
          at Object.<anonymous> (/app/trading-platform/app/api/trading/__tests__/route.test.ts:697:26)
          at Promise.then.completed (/app/trading-platform/node_modules/jest-circus/build/utils.js:298:28)
          at new Promise (<anonymous>)
          at callAsyncCircusFn (/app/trading-platform/node_modules/jest-circus/build/utils.js:231:10)
          at _callCircusTest (/app/trading-platform/node_modules/jest-circus/build/run.js:316:40)
          at processTicksAndRejections (node:internal/process/task_queues:105:5)
          at _runTest (/app/trading-platform/node_modules/jest-circus/build/run.js:252:3)
          at _runTestsForDescribeBlock (/app/trading-platform/node_modules/jest-circus/build/run.js:126:9)
          at _runTestsForDescribeBlock (/app/trading-platform/node_modules/jest-circus/build/run.js:121:9)
          at run (/app/trading-platform/node_modules/jest-circus/build/run.js:71:3)
          at runAndTransformResultsToJestFormat (/app/trading-platform/node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapterInit.js:122:21)
          at jestAdapter (/app/trading-platform/node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapter.js:79:19)
          at runTestInternal (/app/trading-platform/node_modules/jest-runner/build/runTest.js:367:16)
          at runTest (/app/trading-platform/node_modules/jest-runner/build/runTest.js:444:34)
          at Object.worker (/app/trading-platform/node_modules/jest-runner/build/testWorker.js:106:12)

      94 |     const formatted = this.formatMessage('error', message, context);
      95 |     if (this.config.enableConsole) {
    > 96 |       console.error(formatted, error?.stack ?? error?.message ?? '');
         |               ^
      97 |     }
      98 |     this.addLog({
      99 |       timestamp: new Date(),

      at Logger.error (app/core/logger.ts:96:15)
      at error (app/lib/errors.ts:557:12)
      at handleApiError (app/lib/error-handler.ts:248:21)
      at GET (app/api/trading/route.ts:148:26)
      at Object.<anonymous> (app/api/trading/__tests__/route.test.ts:697:26)

  ● POST /api/trading › start action › should handle start errors gracefully

    expect(received).toBe(expected) // Object.is equality

    Expected: "Failed to start"
    Received: "Internal server error"

      90 |
      91 |       expect(res.status).toBe(500);
    > 92 |       expect(data.error).toBe('Failed to start');
         |                          ^
      93 |     });
      94 |   });
      95 |

      at Object.toBe (app/api/trading/__tests__/route.test.ts:92:26)

  ● POST /api/trading › stop action › should handle stop errors gracefully

    expect(received).toBe(expected) // Object.is equality

    Expected: "Failed to stop"
    Received: "Internal server error"

      113 |
      114 |       expect(res.status).toBe(500);
    > 115 |       expect(data.error).toBe('Failed to stop');
          |                          ^
      116 |     });
      117 |   });
      118 |

      at Object.toBe (app/api/trading/__tests__/route.test.ts:115:26)

  ● POST /api/trading › place_order action › should reject order with empty symbol

    expect(received).toContain(expected) // indexOf

    Expected substring: "Invalid symbol"
    Received string:    "Invalid request data"

      182 |
      183 |       expect(res.status).toBe(400);
    > 184 |       expect(data.error).toContain('Invalid symbol');
          |                          ^
      185 |     });
      186 |
      187 |     it('should reject order with whitespace-only symbol', async () => {

      at Object.toContain (app/api/trading/__tests__/route.test.ts:184:26)

  ● POST /api/trading › place_order action › should reject order with whitespace-only symbol

    expect(received).toBe(expected) // Object.is equality

    Expected: 400
    Received: 200

      195 |       const data = await res.json();
      196 |
    > 197 |       expect(res.status).toBe(400);
          |                          ^
      198 |       expect(data.error).toContain('Invalid symbol');
      199 |     });
      200 |

      at Object.toBe (app/api/trading/__tests__/route.test.ts:197:26)

  ● POST /api/trading › place_order action › should reject order with missing symbol

    expect(received).toContain(expected) // indexOf

    Expected substring: "Invalid symbol"
    Received string:    "Invalid request data"

      209 |
      210 |       expect(res.status).toBe(400);
    > 211 |       expect(data.error).toContain('Invalid symbol');
          |                          ^
      212 |     });
      213 |
      214 |     it('should reject order with invalid side', async () => {

      at Object.toContain (app/api/trading/__tests__/route.test.ts:211:26)

  ● POST /api/trading › place_order action › should reject order with invalid side

    expect(received).toContain(expected) // indexOf

    Expected substring: "Invalid side"
    Received string:    "Invalid request data"

      223 |
      224 |       expect(res.status).toBe(400);
    > 225 |       expect(data.error).toContain('Invalid side');
          |                          ^
      226 |     });
      227 |
      228 |     it('should reject order with missing side', async () => {

      at Object.toContain (app/api/trading/__tests__/route.test.ts:225:26)

  ● POST /api/trading › place_order action › should reject order with missing side

    expect(received).toContain(expected) // indexOf

    Expected substring: "Invalid side"
    Received string:    "Invalid request data"

      236 |
      237 |       expect(res.status).toBe(400);
    > 238 |       expect(data.error).toContain('Invalid side');
          |                          ^
      239 |     });
      240 |
      241 |     it('should reject order with zero quantity', async () => {

      at Object.toContain (app/api/trading/__tests__/route.test.ts:238:26)

  ● POST /api/trading › place_order action › should reject order with zero quantity

    expect(received).toContain(expected) // indexOf

    Expected substring: "Invalid quantity"
    Received string:    "Invalid request data"

      250 |
      251 |       expect(res.status).toBe(400);
    > 252 |       expect(data.error).toContain('Invalid quantity');
          |                          ^
      253 |     });
      254 |
      255 |     it('should reject order with negative quantity', async () => {

      at Object.toContain (app/api/trading/__tests__/route.test.ts:252:26)

  ● POST /api/trading › place_order action › should reject order with negative quantity

    expect(received).toContain(expected) // indexOf

    Expected substring: "Invalid quantity"
    Received string:    "Invalid request data"

      264 |
      265 |       expect(res.status).toBe(400);
    > 266 |       expect(data.error).toContain('Invalid quantity');
          |                          ^
      267 |     });
      268 |
      269 |     it('should reject order with Infinity quantity', async () => {

      at Object.toContain (app/api/trading/__tests__/route.test.ts:266:26)

  ● POST /api/trading › place_order action › should reject order with Infinity quantity

    expect(received).toContain(expected) // indexOf

    Expected substring: "Invalid quantity"
    Received string:    "Invalid request data"

      278 |
      279 |       expect(res.status).toBe(400);
    > 280 |       expect(data.error).toContain('Invalid quantity');
          |                          ^
      281 |     });
      282 |
      283 |     it('should reject order with NaN quantity', async () => {

      at Object.toContain (app/api/trading/__tests__/route.test.ts:280:26)

  ● POST /api/trading › place_order action › should reject order with NaN quantity

    expect(received).toContain(expected) // indexOf

    Expected substring: "Invalid quantity"
    Received string:    "Invalid request data"

      292 |
      293 |       expect(res.status).toBe(400);
    > 294 |       expect(data.error).toContain('Invalid quantity');
          |                          ^
      295 |     });
      296 |
      297 |     it('should reject order with string quantity', async () => {

      at Object.toContain (app/api/trading/__tests__/route.test.ts:294:26)

  ● POST /api/trading › place_order action › should reject order with string quantity

    expect(received).toContain(expected) // indexOf

    Expected substring: "Invalid quantity"
    Received string:    "Invalid request data"

      306 |
      307 |       expect(res.status).toBe(400);
    > 308 |       expect(data.error).toContain('Invalid quantity');
          |                          ^
      309 |     });
      310 |
      311 |     it('should handle order placement errors', async () => {

      at Object.toContain (app/api/trading/__tests__/route.test.ts:308:26)

  ● POST /api/trading › place_order action › should handle order placement errors

    expect(received).toBe(expected) // Object.is equality

    Expected: "Insufficient funds"
    Received: "Internal server error"

      324 |
      325 |       expect(res.status).toBe(500);
    > 326 |       expect(data.error).toBe('Insufficient funds');
          |                          ^
      327 |     });
      328 |   });
      329 |

      at Object.toBe (app/api/trading/__tests__/route.test.ts:326:26)

  ● POST /api/trading › close_position action › should reject with empty symbol

    expect(received).toContain(expected) // indexOf

    Expected substring: "Invalid symbol"
    Received string:    "Invalid request data"

      351 |
      352 |       expect(res.status).toBe(400);
    > 353 |       expect(data.error).toContain('Invalid symbol');
          |                          ^
      354 |     });
      355 |
      356 |     it('should reject with whitespace-only symbol', async () => {

      at Object.toContain (app/api/trading/__tests__/route.test.ts:353:26)

  ● POST /api/trading › close_position action › should reject with whitespace-only symbol

    expect(received).toBe(expected) // Object.is equality

    Expected: 400
    Received: 200

      362 |       const data = await res.json();
      363 |
    > 364 |       expect(res.status).toBe(400);
          |                          ^
      365 |       expect(data.error).toContain('Invalid symbol');
      366 |     });
      367 |

      at Object.toBe (app/api/trading/__tests__/route.test.ts:364:26)

  ● POST /api/trading › close_position action › should handle position closure errors

    expect(received).toBe(expected) // Object.is equality

    Expected: "Position not found"
    Received: "Internal server error"

      379 |
      380 |       expect(res.status).toBe(500);
    > 381 |       expect(data.error).toBe('Position not found');
          |                          ^
      382 |     });
      383 |   });
      384 |

      at Object.toBe (app/api/trading/__tests__/route.test.ts:381:26)

  ● POST /api/trading › create_alert action › should create an alert successfully

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    Expected: "Price Alert", "AAPL", "price", ">", 150
    Received: "Price Alert", "AAPL", "price", "above", 150

    Number of calls: 1

      398 |       expect(res.status).toBe(200);
      399 |       expect(data.success).toBe(true);
    > 400 |       expect(mockTradingPlatform.createAlert).toHaveBeenCalledWith(
          |                                               ^
      401 |         'Price Alert',
      402 |         'AAPL',
      403 |         'price',

      at Object.toHaveBeenCalledWith (app/api/trading/__tests__/route.test.ts:400:47)

  ● POST /api/trading › create_alert action › should reject alert with empty name

    expect(received).toContain(expected) // indexOf

    Expected substring: "Invalid name"
    Received string:    "Invalid request data"

      420 |
      421 |       expect(res.status).toBe(400);
    > 422 |       expect(data.error).toContain('Invalid name');
          |                          ^
      423 |     });
      424 |
      425 |     it('should reject alert with whitespace-only name', async () => {

      at Object.toContain (app/api/trading/__tests__/route.test.ts:422:26)

  ● POST /api/trading › create_alert action › should reject alert with whitespace-only name

    expect(received).toBe(expected) // Object.is equality

    Expected: 400
    Received: 200

      435 |       const data = await res.json();
      436 |
    > 437 |       expect(res.status).toBe(400);
          |                          ^
      438 |       expect(data.error).toContain('Invalid name');
      439 |     });
      440 |

      at Object.toBe (app/api/trading/__tests__/route.test.ts:437:26)

  ● POST /api/trading › create_alert action › should reject alert with empty symbol

    expect(received).toContain(expected) // indexOf

    Expected substring: "Invalid symbol"
    Received string:    "Invalid request data"

      452 |
      453 |       expect(res.status).toBe(400);
    > 454 |       expect(data.error).toContain('Invalid symbol');
          |                          ^
      455 |     });
      456 |
      457 |     it('should reject alert with missing type', async () => {

      at Object.toContain (app/api/trading/__tests__/route.test.ts:454:26)

  ● POST /api/trading › create_alert action › should reject alert with missing type

    expect(received).toContain(expected) // indexOf

    Expected substring: "Invalid type"
    Received string:    "Invalid request data"

      467 |
      468 |       expect(res.status).toBe(400);
    > 469 |       expect(data.error).toContain('Invalid type');
          |                          ^
      470 |     });
      471 |
      472 |     it('should reject alert with missing operator', async () => {

      at Object.toContain (app/api/trading/__tests__/route.test.ts:469:26)

  ● POST /api/trading › create_alert action › should reject alert with missing operator

    expect(received).toContain(expected) // indexOf

    Expected substring: "Invalid operator"
    Received string:    "Invalid request data"

      482 |
      483 |       expect(res.status).toBe(400);
    > 484 |       expect(data.error).toContain('Invalid operator');
          |                          ^
      485 |     });
      486 |
      487 |     it('should reject alert with null value', async () => {

      at Object.toContain (app/api/trading/__tests__/route.test.ts:484:26)

  ● POST /api/trading › create_alert action › should reject alert with null value

    expect(received).toContain(expected) // indexOf

    Expected substring: "Invalid value"
    Received string:    "Invalid request data"

      498 |
      499 |       expect(res.status).toBe(400);
    > 500 |       expect(data.error).toContain('Invalid value');
          |                          ^
      501 |     });
      502 |
      503 |     it('should reject alert with undefined value', async () => {

      at Object.toContain (app/api/trading/__tests__/route.test.ts:500:26)

  ● POST /api/trading › create_alert action › should reject alert with undefined value

    expect(received).toContain(expected) // indexOf

    Expected substring: "Invalid value"
    Received string:    "Invalid request data"

      513 |
      514 |       expect(res.status).toBe(400);
    > 515 |       expect(data.error).toContain('Invalid value');
          |                          ^
      516 |     });
      517 |
      518 |     it('should reject alert with Infinity value', async () => {

      at Object.toContain (app/api/trading/__tests__/route.test.ts:515:26)

  ● POST /api/trading › create_alert action › should reject alert with Infinity value

    expect(received).toContain(expected) // indexOf

    Expected substring: "Invalid value"
    Received string:    "Invalid request data"

      529 |
      530 |       expect(res.status).toBe(400);
    > 531 |       expect(data.error).toContain('Invalid value');
          |                          ^
      532 |     });
      533 |
      534 |     it('should reject alert with NaN value', async () => {

      at Object.toContain (app/api/trading/__tests__/route.test.ts:531:26)

  ● POST /api/trading › create_alert action › should reject alert with NaN value

    expect(received).toContain(expected) // indexOf

    Expected substring: "Invalid value"
    Received string:    "Invalid request data"

      545 |
      546 |       expect(res.status).toBe(400);
    > 547 |       expect(data.error).toContain('Invalid value');
          |                          ^
      548 |     });
      549 |   });
      550 |

      at Object.toContain (app/api/trading/__tests__/route.test.ts:547:26)

  ● POST /api/trading › update_config action › should reject non-object config

    expect(received).toContain(expected) // indexOf

    Expected substring: "Invalid config"
    Received string:    "Invalid request data"

      577 |
      578 |       expect(res.status).toBe(400);
    > 579 |       expect(data.error).toContain('Invalid config');
          |                          ^
      580 |     });
      581 |
      582 |     it('should reject invalid mode', async () => {

      at Object.toContain (app/api/trading/__tests__/route.test.ts:579:26)

  ● POST /api/trading › update_config action › should reject invalid mode

    expect(received).toBe(expected) // Object.is equality

    Expected: 400
    Received: 200

      588 |       const data = await res.json();
      589 |
    > 590 |       expect(res.status).toBe(400);
          |                          ^
      591 |       expect(data.error).toContain('Invalid mode');
      592 |     });
      593 |

      at Object.toBe (app/api/trading/__tests__/route.test.ts:590:26)

  ● POST /api/trading › update_config action › should reject negative initialCapital

    expect(received).toBe(expected) // Object.is equality

    Expected: 400
    Received: 200

      600 |       const data = await res.json();
      601 |
    > 602 |       expect(res.status).toBe(400);
          |                          ^
      603 |       expect(data.error).toContain('Invalid initialCapital');
      604 |     });
      605 |

      at Object.toBe (app/api/trading/__tests__/route.test.ts:602:26)

  ● POST /api/trading › update_config action › should reject invalid riskLimits

    expect(received).toBe(expected) // Object.is equality

    Expected: 400
    Received: 200

      612 |       const data = await res.json();
      613 |
    > 614 |       expect(res.status).toBe(400);
          |                          ^
      615 |       expect(data.error).toContain('Invalid riskLimits');
      616 |     });
      617 |

      at Object.toBe (app/api/trading/__tests__/route.test.ts:614:26)

  ● POST /api/trading › update_config action › should sanitize unknown keys

    expect(jest.fn()).toHaveBeenCalledWith(...expected)

    - Expected
    + Received

      Object {
        "mode": "paper",
    +   "unknown_key": "malicious_value",
      },

    Number of calls: 1

      631 |       expect(data.success).toBe(true);
      632 |       // Should verify that unknown_key and __proto__ were stripped
    > 633 |       expect(mockTradingPlatform.updateConfig).toHaveBeenCalledWith({
          |                                                ^
      634 |         mode: 'paper'
      635 |       });
      636 |     });

      at Object.toHaveBeenCalledWith (app/api/trading/__tests__/route.test.ts:633:48)

  ● POST /api/trading › unknown action › should reject unknown action

    expect(received).toBe(expected) // Object.is equality

    Expected: "Unknown action"
    Received: "Invalid request data"

      646 |
      647 |       expect(res.status).toBe(400);
    > 648 |       expect(data.error).toBe('Unknown action');
          |                          ^
      649 |     });
      650 |   });
      651 |

      at Object.toBe (app/api/trading/__tests__/route.test.ts:648:26)

  ● POST /api/trading › error handling › should handle non-Error exceptions

    expect(received).toBe(expected) // Object.is equality

    Expected: "String error"
    Received: "Internal server error"

      659 |
      660 |       expect(res.status).toBe(500);
    > 661 |       expect(data.error).toBe('String error');
          |                          ^
      662 |     });
      663 |   });
      664 | });

      at Object.toBe (app/api/trading/__tests__/route.test.ts:661:26)

  ● GET /api/trading › should handle errors gracefully

    expect(received).toBe(expected) // Object.is equality

    Expected: "Platform error"
    Received: "Internal server error"

      699 |
      700 |     expect(res.status).toBe(500);
    > 701 |     expect(data.error).toBe('Platform error');
          |                        ^
      702 |   });
      703 | });
      704 |

      at Object.toBe (app/api/trading/__tests__/route.test.ts:701:24)

FAIL app/__tests__/Screener.test.tsx
  ● Screener Page › renders and fetches initial quotes

    TypeError: _tradingStore.useTradingStore.setState is not a function

      63 |         });
      64 |
    > 65 |         (useTradingStore as unknown as MockStore).setState({
         |                                                   ^
      66 |             addToWatchlist: mockAddToWatchlist,
      67 |             setSelectedStock: mockSetSelectedStock,
      68 |         });

      at Object.setState (app/__tests__/Screener.test.tsx:65:51)

  ● Screener Page › filters stocks by price range

    TypeError: _tradingStore.useTradingStore.setState is not a function

      63 |         });
      64 |
    > 65 |         (useTradingStore as unknown as MockStore).setState({
         |                                                   ^
      66 |             addToWatchlist: mockAddToWatchlist,
      67 |             setSelectedStock: mockSetSelectedStock,
      68 |         });

      at Object.setState (app/__tests__/Screener.test.tsx:65:51)

  ● Screener Page › filters stocks by change, market and sector

    TypeError: _tradingStore.useTradingStore.setState is not a function

      63 |         });
      64 |
    > 65 |         (useTradingStore as unknown as MockStore).setState({
         |                                                   ^
      66 |             addToWatchlist: mockAddToWatchlist,
      67 |             setSelectedStock: mockSetSelectedStock,
      68 |         });

      at Object.setState (app/__tests__/Screener.test.tsx:65:51)

  ● Screener Page › filters by AI signal and confidence after analysis

    TypeError: _tradingStore.useTradingStore.setState is not a function

      63 |         });
      64 |
    > 65 |         (useTradingStore as unknown as MockStore).setState({
         |                                                   ^
      66 |             addToWatchlist: mockAddToWatchlist,
      67 |             setSelectedStock: mockSetSelectedStock,
      68 |         });

      at Object.setState (app/__tests__/Screener.test.tsx:65:51)

  ● Screener Page › handles sort changes (symbol and price)

    TypeError: _tradingStore.useTradingStore.setState is not a function

      63 |         });
      64 |
    > 65 |         (useTradingStore as unknown as MockStore).setState({
         |                                                   ^
      66 |             addToWatchlist: mockAddToWatchlist,
      67 |             setSelectedStock: mockSetSelectedStock,
      68 |         });

      at Object.setState (app/__tests__/Screener.test.tsx:65:51)

  ● Screener Page › performs AI screening successfully

    TypeError: _tradingStore.useTradingStore.setState is not a function

      63 |         });
      64 |
    > 65 |         (useTradingStore as unknown as MockStore).setState({
         |                                                   ^
      66 |             addToWatchlist: mockAddToWatchlist,
      67 |             setSelectedStock: mockSetSelectedStock,
      68 |         });

      at Object.setState (app/__tests__/Screener.test.tsx:65:51)

  ● Screener Page › handles filter changes (confidence and trend)

    TypeError: _tradingStore.useTradingStore.setState is not a function

      63 |         });
      64 |
    > 65 |         (useTradingStore as unknown as MockStore).setState({
         |                                                   ^
      66 |             addToWatchlist: mockAddToWatchlist,
      67 |             setSelectedStock: mockSetSelectedStock,
      68 |         });

      at Object.setState (app/__tests__/Screener.test.tsx:65:51)

  ● Screener Page › covers additional sort fields

    TypeError: _tradingStore.useTradingStore.setState is not a function

      63 |         });
      64 |
    > 65 |         (useTradingStore as unknown as MockStore).setState({
         |                                                   ^
      66 |             addToWatchlist: mockAddToWatchlist,
      67 |             setSelectedStock: mockSetSelectedStock,
      68 |         });

      at Object.setState (app/__tests__/Screener.test.tsx:65:51)

  ● Screener Page › handles all types of regular filters

    TypeError: _tradingStore.useTradingStore.setState is not a function

      63 |         });
      64 |
    > 65 |         (useTradingStore as unknown as MockStore).setState({
         |                                                   ^
      66 |             addToWatchlist: mockAddToWatchlist,
      67 |             setSelectedStock: mockSetSelectedStock,
      68 |         });

      at Object.setState (app/__tests__/Screener.test.tsx:65:51)

  ● Screener Page › handles technical analysis failure

    TypeError: _tradingStore.useTradingStore.setState is not a function

      63 |         });
      64 |
    > 65 |         (useTradingStore as unknown as MockStore).setState({
         |                                                   ^
      66 |             addToWatchlist: mockAddToWatchlist,
      67 |             setSelectedStock: mockSetSelectedStock,
      68 |         });

      at Object.setState (app/__tests__/Screener.test.tsx:65:51)

  ● Screener Page › handles sidebar toggle and overlay

    TypeError: _tradingStore.useTradingStore.setState is not a function

      63 |         });
      64 |
    > 65 |         (useTradingStore as unknown as MockStore).setState({
         |                                                   ^
      66 |             addToWatchlist: mockAddToWatchlist,
      67 |             setSelectedStock: mockSetSelectedStock,
      68 |         });

      at Object.setState (app/__tests__/Screener.test.tsx:65:51)

  ● Screener Page › applies presets (oversold, uptrend, overbought, downtrend)

    TypeError: _tradingStore.useTradingStore.setState is not a function

      63 |         });
      64 |
    > 65 |         (useTradingStore as unknown as MockStore).setState({
         |                                                   ^
      66 |             addToWatchlist: mockAddToWatchlist,
      67 |             setSelectedStock: mockSetSelectedStock,
      68 |         });

      at Object.setState (app/__tests__/Screener.test.tsx:65:51)

  ● Screener Page › navigates on stock click

    TypeError: _tradingStore.useTradingStore.setState is not a function

      63 |         });
      64 |
    > 65 |         (useTradingStore as unknown as MockStore).setState({
         |                                                   ^
      66 |             addToWatchlist: mockAddToWatchlist,
      67 |             setSelectedStock: mockSetSelectedStock,
      68 |         });

      at Object.setState (app/__tests__/Screener.test.tsx:65:51)

  ● Screener Page › resets filters

    TypeError: _tradingStore.useTradingStore.setState is not a function

      63 |         });
      64 |
    > 65 |         (useTradingStore as unknown as MockStore).setState({
         |                                                   ^
      66 |             addToWatchlist: mockAddToWatchlist,
      67 |             setSelectedStock: mockSetSelectedStock,
      68 |         });

      at Object.setState (app/__tests__/Screener.test.tsx:65:51)

  ● Screener Page › covers missing quote data during initial fetch

    TypeError: _tradingStore.useTradingStore.setState is not a function

      63 |         });
      64 |
    > 65 |         (useTradingStore as unknown as MockStore).setState({
         |                                                   ^
      66 |             addToWatchlist: mockAddToWatchlist,
      67 |             setSelectedStock: mockSetSelectedStock,
      68 |         });

      at Object.setState (app/__tests__/Screener.test.tsx:65:51)

PASS app/lib/services/__tests__/dynamic-position-sizing-service.test.ts
PASS app/lib/aiAnalytics/__tests__/EnsembleModel.test.ts
PASS app/types/__tests__/optimized-data.test.ts
PASS app/lib/__tests__/TechnicalIndicatorService.property.test.ts
FAIL app/api/market/__tests__/error-cases.test.ts
  ● Console

    console.error
      [2026-02-08T08:47:07.341Z] [ERROR]  [2026-02-08T08:47:07.340Z] [market/history] Error: Error: Request timeout
          at Object.<anonymous> (/app/trading-platform/app/api/market/__tests__/error-cases.test.ts:111:39)
          at Promise.then.completed (/app/trading-platform/node_modules/jest-circus/build/utils.js:298:28)
          at new Promise (<anonymous>)
          at callAsyncCircusFn (/app/trading-platform/node_modules/jest-circus/build/utils.js:231:10)
          at _callCircusTest (/app/trading-platform/node_modules/jest-circus/build/run.js:316:40)
          at processTicksAndRejections (node:internal/process/task_queues:105:5)
          at _runTest (/app/trading-platform/node_modules/jest-circus/build/run.js:252:3)
          at _runTestsForDescribeBlock (/app/trading-platform/node_modules/jest-circus/build/run.js:126:9)
          at _runTestsForDescribeBlock (/app/trading-platform/node_modules/jest-circus/build/run.js:121:9)
          at _runTestsForDescribeBlock (/app/trading-platform/node_modules/jest-circus/build/run.js:121:9)
          at run (/app/trading-platform/node_modules/jest-circus/build/run.js:71:3)
          at runAndTransformResultsToJestFormat (/app/trading-platform/node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapterInit.js:122:21)
          at jestAdapter (/app/trading-platform/node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapter.js:79:19)
          at runTestInternal (/app/trading-platform/node_modules/jest-runner/build/runTest.js:367:16)
          at runTest (/app/trading-platform/node_modules/jest-runner/build/runTest.js:444:34)
          at Object.worker (/app/trading-platform/node_modules/jest-runner/build/testWorker.js:106:12)

      94 |     const formatted = this.formatMessage('error', message, context);
      95 |     if (this.config.enableConsole) {
    > 96 |       console.error(formatted, error?.stack ?? error?.message ?? '');
         |               ^
      97 |     }
      98 |     this.addLog({
      99 |       timestamp: new Date(),

      at Logger.error (app/core/logger.ts:96:15)
      at error (app/lib/errors.ts:557:12)
      at handleApiError (app/lib/error-handler.ts:248:21)
      at GET (app/api/market/route.ts:242:30)
      at Object.<anonymous> (app/api/market/__tests__/error-cases.test.ts:114:19)

    console.error
      [2026-02-08T08:47:07.347Z] [ERROR]  [2026-02-08T08:47:07.346Z] [market/quote] Error: Error: API error
          at Object.<anonymous> (/app/trading-platform/app/api/market/__tests__/error-cases.test.ts:122:39)
          at Promise.then.completed (/app/trading-platform/node_modules/jest-circus/build/utils.js:298:28)
          at new Promise (<anonymous>)
          at callAsyncCircusFn (/app/trading-platform/node_modules/jest-circus/build/utils.js:231:10)
          at _callCircusTest (/app/trading-platform/node_modules/jest-circus/build/run.js:316:40)
          at processTicksAndRejections (node:internal/process/task_queues:105:5)
          at _runTest (/app/trading-platform/node_modules/jest-circus/build/run.js:252:3)
          at _runTestsForDescribeBlock (/app/trading-platform/node_modules/jest-circus/build/run.js:126:9)
          at _runTestsForDescribeBlock (/app/trading-platform/node_modules/jest-circus/build/run.js:121:9)
          at _runTestsForDescribeBlock (/app/trading-platform/node_modules/jest-circus/build/run.js:121:9)
          at run (/app/trading-platform/node_modules/jest-circus/build/run.js:71:3)
          at runAndTransformResultsToJestFormat (/app/trading-platform/node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapterInit.js:122:21)
          at jestAdapter (/app/trading-platform/node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapter.js:79:19)
          at runTestInternal (/app/trading-platform/node_modules/jest-runner/build/runTest.js:367:16)
          at runTest (/app/trading-platform/node_modules/jest-runner/build/runTest.js:444:34)
          at Object.worker (/app/trading-platform/node_modules/jest-runner/build/testWorker.js:106:12)

      94 |     const formatted = this.formatMessage('error', message, context);
      95 |     if (this.config.enableConsole) {
    > 96 |       console.error(formatted, error?.stack ?? error?.message ?? '');
         |               ^
      97 |     }
      98 |     this.addLog({
      99 |       timestamp: new Date(),

      at Logger.error (app/core/logger.ts:96:15)
      at error (app/lib/errors.ts:557:12)
      at handleApiError (app/lib/error-handler.ts:248:21)
      at GET (app/api/market/route.ts:265:32)
      at Object.<anonymous> (app/api/market/__tests__/error-cases.test.ts:125:19)

    console.error
      [2026-02-08T08:47:07.349Z] [ERROR]  [2026-02-08T08:47:07.349Z] [market/quote] Error: Error: Network error
          at Object.<anonymous> (/app/trading-platform/app/api/market/__tests__/error-cases.test.ts:133:39)
          at Promise.then.completed (/app/trading-platform/node_modules/jest-circus/build/utils.js:298:28)
          at new Promise (<anonymous>)
          at callAsyncCircusFn (/app/trading-platform/node_modules/jest-circus/build/utils.js:231:10)
          at _callCircusTest (/app/trading-platform/node_modules/jest-circus/build/run.js:316:40)
          at processTicksAndRejections (node:internal/process/task_queues:105:5)
          at _runTest (/app/trading-platform/node_modules/jest-circus/build/run.js:252:3)
          at _runTestsForDescribeBlock (/app/trading-platform/node_modules/jest-circus/build/run.js:126:9)
          at _runTestsForDescribeBlock (/app/trading-platform/node_modules/jest-circus/build/run.js:121:9)
          at _runTestsForDescribeBlock (/app/trading-platform/node_modules/jest-circus/build/run.js:121:9)
          at run (/app/trading-platform/node_modules/jest-circus/build/run.js:71:3)
          at runAndTransformResultsToJestFormat (/app/trading-platform/node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapterInit.js:122:21)
          at jestAdapter (/app/trading-platform/node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapter.js:79:19)
          at runTestInternal (/app/trading-platform/node_modules/jest-runner/build/runTest.js:367:16)
          at runTest (/app/trading-platform/node_modules/jest-runner/build/runTest.js:444:34)
          at Object.worker (/app/trading-platform/node_modules/jest-runner/build/testWorker.js:106:12)

      94 |     const formatted = this.formatMessage('error', message, context);
      95 |     if (this.config.enableConsole) {
    > 96 |       console.error(formatted, error?.stack ?? error?.message ?? '');
         |               ^
      97 |     }
      98 |     this.addLog({
      99 |       timestamp: new Date(),

      at Logger.error (app/core/logger.ts:96:15)
      at error (app/lib/errors.ts:557:12)
      at handleApiError (app/lib/error-handler.ts:248:21)
      at GET (app/api/market/route.ts:265:32)
      at Object.<anonymous> (app/api/market/__tests__/error-cases.test.ts:136:19)

    console.error
      [2026-02-08T08:47:07.351Z] [ERROR]  [2026-02-08T08:47:07.350Z] [market/batch-quote] Error: Error: Network error
          at Object.<anonymous> (/app/trading-platform/app/api/market/__tests__/error-cases.test.ts:142:39)
          at Promise.then.completed (/app/trading-platform/node_modules/jest-circus/build/utils.js:298:28)
          at new Promise (<anonymous>)
          at callAsyncCircusFn (/app/trading-platform/node_modules/jest-circus/build/utils.js:231:10)
          at _callCircusTest (/app/trading-platform/node_modules/jest-circus/build/run.js:316:40)
          at processTicksAndRejections (node:internal/process/task_queues:105:5)
          at _runTest (/app/trading-platform/node_modules/jest-circus/build/run.js:252:3)
          at _runTestsForDescribeBlock (/app/trading-platform/node_modules/jest-circus/build/run.js:126:9)
          at _runTestsForDescribeBlock (/app/trading-platform/node_modules/jest-circus/build/run.js:121:9)
          at _runTestsForDescribeBlock (/app/trading-platform/node_modules/jest-circus/build/run.js:121:9)
          at run (/app/trading-platform/node_modules/jest-circus/build/run.js:71:3)
          at runAndTransformResultsToJestFormat (/app/trading-platform/node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapterInit.js:122:21)
          at jestAdapter (/app/trading-platform/node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapter.js:79:19)
          at runTestInternal (/app/trading-platform/node_modules/jest-runner/build/runTest.js:367:16)
          at runTest (/app/trading-platform/node_modules/jest-runner/build/runTest.js:444:34)
          at Object.worker (/app/trading-platform/node_modules/jest-runner/build/testWorker.js:106:12)

      94 |     const formatted = this.formatMessage('error', message, context);
      95 |     if (this.config.enableConsole) {
    > 96 |       console.error(formatted, error?.stack ?? error?.message ?? '');
         |               ^
      97 |     }
      98 |     this.addLog({
      99 |       timestamp: new Date(),

      at Logger.error (app/core/logger.ts:96:15)
      at error (app/lib/errors.ts:557:12)
      at handleApiError (app/lib/error-handler.ts:248:21)
      at GET (app/api/market/route.ts:286:32)
      at Object.<anonymous> (app/api/market/__tests__/error-cases.test.ts:145:19)

    console.error
      [2026-02-08T08:47:07.361Z] [ERROR]  [2026-02-08T08:47:07.353Z] [market/history] Error: Error: Upstream API data schema mismatch
          at GET (/app/trading-platform/app/api/market/route.ts:187:33)
          at processTicksAndRejections (node:internal/process/task_queues:105:5)
          at Object.<anonymous> (/app/trading-platform/app/api/market/__tests__/error-cases.test.ts:156:19)

      94 |     const formatted = this.formatMessage('error', message, context);
      95 |     if (this.config.enableConsole) {
    > 96 |       console.error(formatted, error?.stack ?? error?.message ?? '');
         |               ^
      97 |     }
      98 |     this.addLog({
      99 |       timestamp: new Date(),

      at Logger.error (app/core/logger.ts:96:15)
      at error (app/lib/errors.ts:557:12)
      at handleApiError (app/lib/error-handler.ts:248:21)
      at GET (app/api/market/route.ts:187:32)
      at Object.<anonymous> (app/api/market/__tests__/error-cases.test.ts:156:19)

    console.error
      [2026-02-08T08:47:07.363Z] [ERROR]  [2026-02-08T08:47:07.363Z] [market/history] Error: Error: Upstream API data schema mismatch
          at GET (/app/trading-platform/app/api/market/route.ts:187:33)
          at processTicksAndRejections (node:internal/process/task_queues:105:5)
          at Object.<anonymous> (/app/trading-platform/app/api/market/__tests__/error-cases.test.ts:168:19)

      94 |     const formatted = this.formatMessage('error', message, context);
      95 |     if (this.config.enableConsole) {
    > 96 |       console.error(formatted, error?.stack ?? error?.message ?? '');
         |               ^
      97 |     }
      98 |     this.addLog({
      99 |       timestamp: new Date(),

      at Logger.error (app/core/logger.ts:96:15)
      at error (app/lib/errors.ts:557:12)
      at handleApiError (app/lib/error-handler.ts:248:21)
      at GET (app/api/market/route.ts:187:32)
      at Object.<anonymous> (app/api/market/__tests__/error-cases.test.ts:168:19)

    console.error
      [2026-02-08T08:47:07.364Z] [ERROR]  [2026-02-08T08:47:07.364Z] [market/quote] Error: Error: Symbol not found
          at GET (/app/trading-platform/app/api/market/route.ts:253:43)
          at processTicksAndRejections (node:internal/process/task_queues:105:5)
          at Object.<anonymous> (/app/trading-platform/app/api/market/__tests__/error-cases.test.ts:179:19)

      94 |     const formatted = this.formatMessage('error', message, context);
      95 |     if (this.config.enableConsole) {
    > 96 |       console.error(formatted, error?.stack ?? error?.message ?? '');
         |               ^
      97 |     }
      98 |     this.addLog({
      99 |       timestamp: new Date(),

      at Logger.error (app/core/logger.ts:96:15)
      at error (app/lib/errors.ts:557:12)
      at handleApiError (app/lib/error-handler.ts:248:21)
      at GET (app/api/market/route.ts:265:32)
      at Object.<anonymous> (app/api/market/__tests__/error-cases.test.ts:179:19)

    console.error
      [2026-02-08T08:47:07.433Z] [ERROR]  [2026-02-08T08:47:07.433Z] [market/quote] Error: Error: API error
          at Object.<anonymous> (/app/trading-platform/app/api/market/__tests__/error-cases.test.ts:364:32)
          at Promise.then.completed (/app/trading-platform/node_modules/jest-circus/build/utils.js:298:28)
          at new Promise (<anonymous>)
          at callAsyncCircusFn (/app/trading-platform/node_modules/jest-circus/build/utils.js:231:10)
          at _callCircusTest (/app/trading-platform/node_modules/jest-circus/build/run.js:316:40)
          at processTicksAndRejections (node:internal/process/task_queues:105:5)
          at _runTest (/app/trading-platform/node_modules/jest-circus/build/run.js:252:3)
          at _runTestsForDescribeBlock (/app/trading-platform/node_modules/jest-circus/build/run.js:126:9)
          at _runTestsForDescribeBlock (/app/trading-platform/node_modules/jest-circus/build/run.js:121:9)
          at _runTestsForDescribeBlock (/app/trading-platform/node_modules/jest-circus/build/run.js:121:9)
          at run (/app/trading-platform/node_modules/jest-circus/build/run.js:71:3)
          at runAndTransformResultsToJestFormat (/app/trading-platform/node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapterInit.js:122:21)
          at jestAdapter (/app/trading-platform/node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapter.js:79:19)
          at runTestInternal (/app/trading-platform/node_modules/jest-runner/build/runTest.js:367:16)
          at runTest (/app/trading-platform/node_modules/jest-runner/build/runTest.js:444:34)
          at Object.worker (/app/trading-platform/node_modules/jest-runner/build/testWorker.js:106:12)

      94 |     const formatted = this.formatMessage('error', message, context);
      95 |     if (this.config.enableConsole) {
    > 96 |       console.error(formatted, error?.stack ?? error?.message ?? '');
         |               ^
      97 |     }
      98 |     this.addLog({
      99 |       timestamp: new Date(),

      at Logger.error (app/core/logger.ts:96:15)
      at error (app/lib/errors.ts:557:12)
      at handleApiError (app/lib/error-handler.ts:248:21)
      at GET (app/api/market/route.ts:265:32)
          at async Promise.all (index 1)
      at Object.<anonymous> (app/api/market/__tests__/error-cases.test.ts:373:25)

    console.error
      [2026-02-08T08:47:07.440Z] [ERROR]  [2026-02-08T08:47:07.440Z] [market/history] Unknown error: Error: [object Object]
          at logError (/app/trading-platform/app/lib/errors.ts:559:97)
          at handleApiError (/app/trading-platform/app/lib/error-handler.ts:248:21)
          at GET (/app/trading-platform/app/api/market/route.ts:242:30)
          at Object.<anonymous> (/app/trading-platform/app/api/market/__tests__/error-cases.test.ts:457:28)
          at Promise.then.completed (/app/trading-platform/node_modules/jest-circus/build/utils.js:298:28)
          at new Promise (<anonymous>)
          at callAsyncCircusFn (/app/trading-platform/node_modules/jest-circus/build/utils.js:231:10)
          at _callCircusTest (/app/trading-platform/node_modules/jest-circus/build/run.js:316:40)
          at processTicksAndRejections (node:internal/process/task_queues:105:5)
          at _runTest (/app/trading-platform/node_modules/jest-circus/build/run.js:252:3)
          at _runTestsForDescribeBlock (/app/trading-platform/node_modules/jest-circus/build/run.js:126:9)
          at _runTestsForDescribeBlock (/app/trading-platform/node_modules/jest-circus/build/run.js:121:9)
          at _runTestsForDescribeBlock (/app/trading-platform/node_modules/jest-circus/build/run.js:121:9)
          at run (/app/trading-platform/node_modules/jest-circus/build/run.js:71:3)
          at runAndTransformResultsToJestFormat (/app/trading-platform/node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapterInit.js:122:21)
          at jestAdapter (/app/trading-platform/node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapter.js:79:19)
          at runTestInternal (/app/trading-platform/node_modules/jest-runner/build/runTest.js:367:16)
          at runTest (/app/trading-platform/node_modules/jest-runner/build/runTest.js:444:34)
          at Object.worker (/app/trading-platform/node_modules/jest-runner/build/testWorker.js:106:12)

      94 |     const formatted = this.formatMessage('error', message, context);
      95 |     if (this.config.enableConsole) {
    > 96 |       console.error(formatted, error?.stack ?? error?.message ?? '');
         |               ^
      97 |     }
      98 |     this.addLog({
      99 |       timestamp: new Date(),

      at Logger.error (app/core/logger.ts:96:15)
      at error (app/lib/errors.ts:559:12)
      at handleApiError (app/lib/error-handler.ts:248:21)
      at GET (app/api/market/route.ts:242:30)
      at Object.<anonymous> (app/api/market/__tests__/error-cases.test.ts:457:28)

  ● Market API Error Cases › Missing parameters › should reject request with missing symbol

    expect(received).toContain(expected) // indexOf

    Expected substring: "Symbol is required"
    Received string:    "Invalid request parameters"

      46 |
      47 |       expect(res.status).toBe(400);
    > 48 |       expect(data.error).toContain('Symbol is required');
         |                          ^
      49 |     });
      50 |
      51 |     it('should reject request with empty symbol', async () => {

      at Object.toContain (app/api/market/__tests__/error-cases.test.ts:48:26)

  ● Market API Error Cases › Missing parameters › should reject request with empty symbol

    expect(received).toContain(expected) // indexOf

    Expected substring: "Symbol is required"
    Received string:    "Invalid request parameters"

      55 |
      56 |       expect(res.status).toBe(400);
    > 57 |       expect(data.error).toContain('Symbol is required');
         |                          ^
      58 |     });
      59 |   });
      60 |

      at Object.toContain (app/api/market/__tests__/error-cases.test.ts:57:26)

  ● Market API Error Cases › Invalid parameters › should reject invalid symbol format with special characters

    expect(received).toBe(expected) // Object.is equality

    Expected: 400
    Received: 200

      65 |       const data = await res.json();
      66 |
    > 67 |       expect(res.status).toBe(400);
         |                          ^
      68 |       expect(data.error).toContain('Invalid symbol format');
      69 |     });
      70 |

      at Object.toBe (app/api/market/__tests__/error-cases.test.ts:67:26)

  ● Market API Error Cases › Invalid parameters › should reject invalid type parameter

    expect(received).toContain(expected) // indexOf

    Expected substring: "Invalid type parameter"
    Received string:    "Invalid request parameters"

      75 |
      76 |       expect(res.status).toBe(400);
    > 77 |       expect(data.error).toContain('Invalid type parameter');
         |                          ^
      78 |     });
      79 |
      80 |     it('should reject invalid market parameter', async () => {

      at Object.toContain (app/api/market/__tests__/error-cases.test.ts:77:26)

  ● Market API Error Cases › Invalid parameters › should reject invalid market parameter

    expect(received).toContain(expected) // indexOf

    Expected substring: "Invalid market parameter"
    Received string:    "Invalid request parameters"

      84 |
      85 |       expect(res.status).toBe(400);
    > 86 |       expect(data.error).toContain('Invalid market parameter');
         |                          ^
      87 |     });
      88 |
      89 |     it('should reject invalid interval parameter', async () => {

      at Object.toContain (app/api/market/__tests__/error-cases.test.ts:86:26)

  ● Market API Error Cases › Invalid parameters › should reject invalid interval parameter

    expect(received).toContain(expected) // indexOf

    Expected substring: "Invalid interval"
    Received string:    "Invalid request parameters"

      93 |
      94 |       expect(res.status).toBe(400);
    > 95 |       expect(data.error).toContain('Invalid interval');
         |                          ^
      96 |     });
      97 |
      98 |     it('should accept valid intervals', async () => {

      at Object.toContain (app/api/market/__tests__/error-cases.test.ts:95:26)

  ● Market API Error Cases › Invalid data responses › should handle empty chart response

    expect(received).toBe(expected) // Object.is equality

    Expected: 200
    Received: 502

      157 |       const data = await res.json();
      158 |
    > 159 |       expect(res.status).toBe(200);
          |                          ^
      160 |       expect(data.data).toEqual([]);
      161 |       expect(data.warning).toBe('No historical data found');
      162 |     });

      at Object.toBe (app/api/market/__tests__/error-cases.test.ts:159:26)

  ● Market API Error Cases › Invalid data responses › should handle null chart response

    expect(received).toBe(expected) // Object.is equality

    Expected: 200
    Received: 502

      169 |       const data = await res.json();
      170 |
    > 171 |       expect(res.status).toBe(200);
          |                          ^
      172 |       expect(data.data).toEqual([]);
      173 |     });
      174 |

      at Object.toBe (app/api/market/__tests__/error-cases.test.ts:171:26)

  ● Market API Error Cases › Date validation › should reject invalid date format

    expect(received).toContain(expected) // indexOf

    Expected substring: "Invalid startDate format"
    Received string:    "Invalid request parameters"

      323 |
      324 |       expect(res.status).toBe(400);
    > 325 |       expect(data.error).toContain('Invalid startDate format');
          |                          ^
      326 |     });
      327 |
      328 |     it('should reject partial date format', async () => {

      at Object.toContain (app/api/market/__tests__/error-cases.test.ts:325:26)

  ● Market API Error Cases › Date validation › should reject partial date format

    expect(received).toContain(expected) // indexOf

    Expected substring: "Invalid startDate format"
    Received string:    "Invalid request parameters"

      332 |
      333 |       expect(res.status).toBe(400);
    > 334 |       expect(data.error).toContain('Invalid startDate format');
          |                          ^
      335 |     });
      336 |
      337 |     it('should accept valid YYYY-MM-DD date', async () => {

      at Object.toContain (app/api/market/__tests__/error-cases.test.ts:334:26)

  ● Market API Error Cases › Edge cases › should handle missing type parameter

    expect(received).toBe(expected) // Object.is equality

    Expected: 400
    Received: 200

      385 |       const data = await res.json();
      386 |
    > 387 |       expect(res.status).toBe(400);
          |                          ^
      388 |       expect(data.error).toContain('Invalid type parameter');
      389 |     });
      390 |

      at Object.toBe (app/api/market/__tests__/error-cases.test.ts:387:26)

  ● Market API Error Cases › Edge cases › should handle batch quotes with missing symbol fields

    expect(received).toHaveLength(expected)

    Expected length: 2
    Received length: 1
    Received array:  [{"change": 0, "changePercent": 0, "marketState": "UNKNOWN", "price": 150, "symbol": "AAPL", "volume": 0}]

      427 |
      428 |       expect(res.status).toBe(200);
    > 429 |       expect(data.data).toHaveLength(2);
          |                         ^
      430 |       expect(data.data[1].symbol).toBe('UNKNOWN');
      431 |     });
      432 |

      at Object.toHaveLength (app/api/market/__tests__/error-cases.test.ts:429:25)

FAIL app/lib/aiAnalytics/ReinforcementLearning/__tests__/ReinforcementLearning.test.ts
  ● TradingAgent › saveModel / loadModel › モデルを保存・読み込みできる

    expect(received).toBe(expected) // Object.is equality

    Expected: 0
    Received: 6

      377 |
      378 |       const action2 = newAgent.selectAction(state, false);
    > 379 |       expect(action2.type).toBe(action1.type);
          |                            ^
      380 |     });
      381 |   });
      382 | });

      at Object.toBe (app/lib/aiAnalytics/ReinforcementLearning/__tests__/ReinforcementLearning.test.ts:379:28)

PASS app/lib/aiAnalytics/__tests__/ModelMonitor.test.ts
FAIL app/domains/backtest/engine/__tests__/RealisticBacktestEngine.test.ts
  ● Console

    console.log
      [BacktestEngine] Running backtest for TEST with strategy: Simple Buy Strategy

      at RealisticBacktestEngine.log (app/domains/backtest/engine/AdvancedBacktestEngine.ts:177:13)

    console.log
      [BacktestEngine] Running backtest for TEST with strategy: Simple Buy Strategy

      at RealisticBacktestEngine.log (app/domains/backtest/engine/AdvancedBacktestEngine.ts:177:13)

    console.log
      [BacktestEngine] Running backtest for TEST with strategy: Simple Buy Strategy

      at RealisticBacktestEngine.log (app/domains/backtest/engine/AdvancedBacktestEngine.ts:177:13)

    console.log
      [BacktestEngine] Running backtest for TEST with strategy: Simple Buy Strategy

      at RealisticBacktestEngine.log (app/domains/backtest/engine/AdvancedBacktestEngine.ts:177:13)

    console.log
      [BacktestEngine] Running backtest for TEST with strategy: Simple Buy Strategy

      at RealisticBacktestEngine.log (app/domains/backtest/engine/AdvancedBacktestEngine.ts:177:13)

    console.log
      [BacktestEngine] Running backtest for TEST with strategy: Simple Buy Strategy

      at RealisticBacktestEngine.log (app/domains/backtest/engine/AdvancedBacktestEngine.ts:177:13)

    console.log
      [BacktestEngine] Running backtest for TEST with strategy: Simple Buy Strategy

      at RealisticBacktestEngine.log (app/domains/backtest/engine/AdvancedBacktestEngine.ts:177:13)

    console.log
      [BacktestEngine] Running backtest for TEST with strategy: High Frequency Strategy

      at RealisticBacktestEngine.log (app/domains/backtest/engine/AdvancedBacktestEngine.ts:177:13)

    console.log
      [BacktestEngine] Running backtest for TEST with strategy: High Frequency Strategy

      at RealisticBacktestEngine.log (app/domains/backtest/engine/AdvancedBacktestEngine.ts:177:13)

    console.log
      [BacktestEngine] Running backtest for TEST with strategy: High Frequency Strategy

      at RealisticBacktestEngine.log (app/domains/backtest/engine/AdvancedBacktestEngine.ts:177:13)

    console.log
      [BacktestEngine] Running backtest for TEST with strategy: High Frequency Strategy

      at RealisticBacktestEngine.log (app/domains/backtest/engine/AdvancedBacktestEngine.ts:177:13)

    console.log
      [BacktestEngine] Running backtest for TEST with strategy: High Frequency Strategy

      at RealisticBacktestEngine.log (app/domains/backtest/engine/AdvancedBacktestEngine.ts:177:13)

    console.log
      [BacktestEngine] Running backtest for TEST with strategy: High Frequency Strategy

      at RealisticBacktestEngine.log (app/domains/backtest/engine/AdvancedBacktestEngine.ts:177:13)

    console.log
      [BacktestEngine] Running backtest for TEST with strategy: High Frequency Strategy

      at RealisticBacktestEngine.log (app/domains/backtest/engine/AdvancedBacktestEngine.ts:177:13)

  ● RealisticBacktestEngine › Market Impact Calculation › should apply market impact based on order size

    expect(received).toBeGreaterThanOrEqual(expected)

    Matcher error: received value must be a number or bigint

    Received has value: undefined

      36 |       // Check that market impact was calculated
      37 |       const firstTrade = result.trades[0];
    > 38 |       expect(firstTrade.marketImpact).toBeGreaterThanOrEqual(0);
         |                                       ^
      39 |       expect(firstTrade.effectiveSlippage).toBeGreaterThan(0);
      40 |     });
      41 |

      at Object.toBeGreaterThanOrEqual (app/domains/backtest/engine/__tests__/RealisticBacktestEngine.test.ts:38:39)

  ● RealisticBacktestEngine › Time-of-Day Slippage › should apply higher slippage at market open

    expect(received).toBeDefined()

    Received: undefined

       95 |       // Check time-of-day factor was applied
       96 |       const trade = result.trades[0];
    >  97 |       expect(trade.timeOfDayFactor).toBeDefined();
          |                                     ^
       98 |       if (trade.timeOfDayFactor) {
       99 |         expect(trade.timeOfDayFactor).toBeGreaterThanOrEqual(1.0);
      100 |       }

      at Object.toBeDefined (app/domains/backtest/engine/__tests__/RealisticBacktestEngine.test.ts:97:37)

  ● RealisticBacktestEngine › Volatility-Based Slippage › should apply higher slippage during high volatility

    expect(received).toBeDefined()

    Received: undefined

      142 |
      143 |       const trade = result.trades[0];
    > 144 |       expect(trade.volatilityFactor).toBeDefined();
          |                                      ^
      145 |       if (trade.volatilityFactor) {
      146 |         expect(trade.volatilityFactor).toBeGreaterThanOrEqual(0.5);
      147 |       }

      at Object.toBeDefined (app/domains/backtest/engine/__tests__/RealisticBacktestEngine.test.ts:144:38)

  ● RealisticBacktestEngine › Tiered Commission Structure › should use basic commission rate for low volume

    expect(received).toBe(expected) // Object.is equality

    Expected: 0
    Received: undefined

      169 |
      170 |       const firstTrade = result.trades[0];
    > 171 |       expect(firstTrade.commissionTier).toBe(0); // Should use lowest tier
          |                                         ^
      172 |     });
      173 |
      174 |     it('should reduce commission rate for high volume traders', async () => {

      at Object.toBe (app/domains/backtest/engine/__tests__/RealisticBacktestEngine.test.ts:171:41)

  ● RealisticBacktestEngine › Transaction Cost Analysis › should calculate comprehensive transaction costs

    expect(received).toBeGreaterThanOrEqual(expected)

    Expected: >= 0
    Received:    NaN

      215 |       expect(result.transactionCosts).toBeDefined();
      216 |       expect(result.transactionCosts.totalCommissions).toBeGreaterThanOrEqual(0);
    > 217 |       expect(result.transactionCosts.totalSlippage).toBeGreaterThanOrEqual(0);
          |                                                     ^
      218 |       expect(result.transactionCosts.totalMarketImpact).toBeGreaterThanOrEqual(0);
      219 |       expect(result.transactionCosts.totalSpread).toBeGreaterThanOrEqual(0);
      220 |     });

      at Object.toBeGreaterThanOrEqual (app/domains/backtest/engine/__tests__/RealisticBacktestEngine.test.ts:217:53)

  ● RealisticBacktestEngine › Transaction Cost Analysis › should calculate average costs per trade

    expect(received).toBeGreaterThanOrEqual(expected)

    Expected: >= 0
    Received:    NaN

      234 |       if (result.trades.length > 0) {
      235 |         expect(result.transactionCosts.avgCommissionPerTrade).toBeGreaterThanOrEqual(0);
    > 236 |         expect(result.transactionCosts.avgSlippagePerTrade).toBeGreaterThanOrEqual(0);
          |                                                             ^
      237 |         expect(result.transactionCosts.avgMarketImpactPerTrade).toBeGreaterThanOrEqual(0);
      238 |       }
      239 |     });

      at Object.toBeGreaterThanOrEqual (app/domains/backtest/engine/__tests__/RealisticBacktestEngine.test.ts:236:61)

  ● RealisticBacktestEngine › Execution Quality Metrics › should calculate execution quality metrics

    expect(received).toBeGreaterThanOrEqual(expected)

    Expected: >= 0
    Received:    NaN

      255 |
      256 |       expect(result.executionQuality).toBeDefined();
    > 257 |       expect(result.executionQuality.worstSlippage).toBeGreaterThanOrEqual(0);
          |                                                     ^
      258 |       expect(result.executionQuality.bestSlippage).toBeGreaterThanOrEqual(0);
      259 |       expect(result.executionQuality.slippageStdDev).toBeGreaterThanOrEqual(0);
      260 |     });

      at Object.toBeGreaterThanOrEqual (app/domains/backtest/engine/__tests__/RealisticBacktestEngine.test.ts:257:53)

  ● RealisticBacktestEngine › Combined Realistic Models › should apply all realistic features together

    expect(received).toBeDefined()

    Received: undefined

      298 |       // Check that trades have enhanced metrics
      299 |       const firstTrade = result.trades[0];
    > 300 |       expect(firstTrade.marketImpact).toBeDefined();
          |                                       ^
      301 |       expect(firstTrade.effectiveSlippage).toBeDefined();
      302 |     });
      303 |

      at Object.toBeDefined (app/domains/backtest/engine/__tests__/RealisticBacktestEngine.test.ts:300:39)

PASS app/lib/backtest/__tests__/RealisticBacktestEngine.test.ts
FAIL app/lib/psychology/__tests__/DisciplineMonitor.test.ts
  ● DisciplineMonitor › checkEntryForViolations › should detect plan deviation

    expect(received).toBeDefined()

    Received: undefined

      103 |       const violations = monitor.checkEntryForViolations(entryWithDeviation);
      104 |       const deviationViolation = violations.find(v => v.type === 'plan_deviation');
    > 105 |       expect(deviationViolation).toBeDefined();
          |                                  ^
      106 |       expect(deviationViolation?.severity).toBe('major');
      107 |     });
      108 |

      at Object.toBeDefined (app/lib/psychology/__tests__/DisciplineMonitor.test.ts:105:34)

  ● DisciplineMonitor › checkEntryForViolations › should store violations

    expect(received).toBeGreaterThan(expected)

    Expected: > 0
    Received:   0

      140 |
      141 |       const recentViolations = monitor.getRecentViolations(7);
    > 142 |       expect(recentViolations.length).toBeGreaterThan(0);
          |                                       ^
      143 |     });
      144 |
      145 |     it('should include violation impact', () => {

      at Object.toBeGreaterThan (app/lib/psychology/__tests__/DisciplineMonitor.test.ts:142:39)

  ● DisciplineMonitor › checkEntryForViolations › should include violation impact

    expect(received).toBeDefined()

    Received: undefined

      148 |       const deviationViolation = violations.find(v => v.type === 'plan_deviation');
      149 |
    > 150 |       expect(deviationViolation?.impact).toBeDefined();
          |                                          ^
      151 |       expect(deviationViolation?.impact?.actualLoss).toBeDefined();
      152 |     });
      153 |   });

      at Object.toBeDefined (app/lib/psychology/__tests__/DisciplineMonitor.test.ts:150:42)

  ● DisciplineMonitor › extractLearningPatterns › should identify successful behaviors

    expect(received).toBeGreaterThan(expected)

    Expected: > 0
    Received:   0

      199 |       const patterns = monitor.extractLearningPatterns(sampleEntries);
      200 |       const successPatterns = patterns.filter(p => p.patternType === 'successful_behavior');
    > 201 |       expect(successPatterns.length).toBeGreaterThan(0);
          |                                      ^
      202 |     });
      203 |
      204 |     it('should identify failure patterns', () => {

      at Object.toBeGreaterThan (app/lib/psychology/__tests__/DisciplineMonitor.test.ts:201:38)

  ● DisciplineMonitor › extractLearningPatterns › should identify failure patterns

    expect(received).toBeGreaterThan(expected)

    Expected: > 0
    Received:   0

      205 |       const patterns = monitor.extractLearningPatterns(sampleEntries);
      206 |       const failurePatterns = patterns.filter(p => p.patternType === 'failure_pattern');
    > 207 |       expect(failurePatterns.length).toBeGreaterThan(0);
          |                                      ^
      208 |     });
      209 |
      210 |     it('should identify improvement areas', () => {

      at Object.toBeGreaterThan (app/lib/psychology/__tests__/DisciplineMonitor.test.ts:207:38)

  ● DisciplineMonitor › getRecentViolations › should return violations within timeframe

    expect(received).toBeGreaterThan(expected)

    Expected: > 0
    Received:   0

      279 |
      280 |       const violations = monitor.getRecentViolations(7);
    > 281 |       expect(violations.length).toBeGreaterThan(0);
          |                                 ^
      282 |     });
      283 |
      284 |     it('should filter violations by date', () => {

      at Object.toBeGreaterThan (app/lib/psychology/__tests__/DisciplineMonitor.test.ts:281:33)

  ● DisciplineMonitor › clearViolations › should clear all violations

    expect(received).toBeGreaterThan(expected)

    Expected: > 0
    Received:   0

      297 |       monitor.checkEntryForViolations(sampleEntries[2]);
      298 |
    > 299 |       expect(monitor.getRecentViolations(7).length).toBeGreaterThan(0);
          |                                                     ^
      300 |
      301 |       monitor.clearViolations();
      302 |       expect(monitor.getRecentViolations(7)).toEqual([]);

      at Object.toBeGreaterThan (app/lib/psychology/__tests__/DisciplineMonitor.test.ts:299:53)

  ● DisciplineMonitor › Configuration › should use custom max position size

    expect(received).toBeDefined()

    Received: undefined

      316 |       const violations = customMonitor.getRecentViolations(7);
      317 |       const oversized = violations.find(v => v.type === 'oversized_position');
    > 318 |       expect(oversized).toBeDefined();
          |                         ^
      319 |     });
      320 |
      321 |     it('should use custom require stop loss setting', () => {

      at Object.toBeDefined (app/lib/psychology/__tests__/DisciplineMonitor.test.ts:318:25)

  ● DisciplineMonitor › Integration Tests › should analyze multiple entries correctly

    expect(received).toBeGreaterThan(expected)

    Expected: > 0
    Received:   0

      391 |
      392 |       expect(report.ruleCompliance.overall).toBeGreaterThanOrEqual(0);
    > 393 |       expect(report.violations.length).toBeGreaterThan(0);
          |                                        ^
      394 |       expect(report.learningPatterns.length).toBeGreaterThan(0);
      395 |       expect(report.recommendations.length).toBeGreaterThan(0);
      396 |     });

      at Object.toBeGreaterThan (app/lib/psychology/__tests__/DisciplineMonitor.test.ts:393:40)

  ● DisciplineMonitor › Integration Tests › should track violations over time

    expect(received).toBeGreaterThan(expected)

    Expected: > 0
    Received:   0

      420 |
      421 |       const violations = monitor.getRecentViolations(7);
    > 422 |       expect(violations.length).toBeGreaterThan(0);
          |                                 ^
      423 |
      424 |       // Verify violation types
      425 |       const violationTypes = new Set(violations.map(v => v.type));

      at Object.toBeGreaterThan (app/lib/psychology/__tests__/DisciplineMonitor.test.ts:422:33)

PASS app/lib/services/__tests__/enhanced-feature-service.test.ts
PASS app/lib/aiAnalytics/__tests__/CompositeTechnicalAnalysisEngine.test.ts
FAIL app/lib/__tests__/AITradeService.test.ts
  ● AITradeService › processTrades - New Trade Entry › should open a BUY trade with high confidence signal

    TypeError: crypto.randomUUID is not a function

      108 |             if (quantity > 0) {
      109 |                 const newTrade: PaperTrade = {
    > 110 |                     id: crypto.randomUUID(),
          |                                ^
      111 |                     symbol,
      112 |                     type: signal.type as 'BUY' | 'SELL',
      113 |                     entryPrice,

      at AITradeService.randomUUID [as processTrades] (app/lib/AITradeService.ts:110:32)
      at Object.processTrades (app/lib/__tests__/AITradeService.test.ts:36:37)

  ● AITradeService › processTrades - New Trade Entry › should open a SELL trade with high confidence signal

    TypeError: crypto.randomUUID is not a function

      108 |             if (quantity > 0) {
      109 |                 const newTrade: PaperTrade = {
    > 110 |                     id: crypto.randomUUID(),
          |                                ^
      111 |                     symbol,
      112 |                     type: signal.type as 'BUY' | 'SELL',
      113 |                     entryPrice,

      at AITradeService.randomUUID [as processTrades] (app/lib/AITradeService.ts:110:32)
      at Object.processTrades (app/lib/__tests__/AITradeService.test.ts:58:37)

  ● AITradeService › processTrades - New Trade Entry › should calculate entry price with slippage

    TypeError: crypto.randomUUID is not a function

      108 |             if (quantity > 0) {
      109 |                 const newTrade: PaperTrade = {
    > 110 |                     id: crypto.randomUUID(),
          |                                ^
      111 |                     symbol,
      112 |                     type: signal.type as 'BUY' | 'SELL',
      113 |                     entryPrice,

      at AITradeService.randomUUID [as processTrades] (app/lib/AITradeService.ts:110:32)
      at Object.processTrades (app/lib/__tests__/AITradeService.test.ts:132:37)

  ● AITradeService › processTrades - New Trade Entry › should calculate correct quantity based on position sizing

    TypeError: crypto.randomUUID is not a function

      108 |             if (quantity > 0) {
      109 |                 const newTrade: PaperTrade = {
    > 110 |                     id: crypto.randomUUID(),
          |                                ^
      111 |                     symbol,
      112 |                     type: signal.type as 'BUY' | 'SELL',
      113 |                     entryPrice,

      at AITradeService.randomUUID [as processTrades] (app/lib/AITradeService.ts:110:32)
      at Object.processTrades (app/lib/__tests__/AITradeService.test.ts:146:37)

FAIL app/lib/aiAnalytics/__tests__/PredictiveAnalyticsEngine.integration.test.ts
  ● PredictiveAnalyticsEngine Integration › Model Validation › should validate prediction after time period

    TypeError: engine.validatePrediction is not a function

      352 |
      353 |       // バリデーションを実行
    > 354 |       const validation = engine.validatePrediction(
          |                                 ^
      355 |         symbol,
      356 |         prediction.timestamp,
      357 |         actualPrice

      at Object.validatePrediction (app/lib/aiAnalytics/__tests__/PredictiveAnalyticsEngine.integration.test.ts:354:33)

FAIL app/domains/backtest/engine/__tests__/OverfittingDetector.test.ts
  ● OverfittingDetector › Performance Degradation Detection › should not flag as overfitting when performance is consistent

    expect(received).toBeLessThan(expected)

    Expected: < 0.3
    Received:   0.4

      46 |       expect(analysis.overfit).toBe(false);
      47 |       expect(analysis.overfittingScore).toBeLessThan(0.5);
    > 48 |       expect(analysis.indicators.performanceDegradation).toBeLessThan(0.3);
         |                                                          ^
      49 |     });
      50 |   });
      51 |

      at Object.toBeLessThan (app/domains/backtest/engine/__tests__/OverfittingDetector.test.ts:48:58)

  ● OverfittingDetector › Comprehensive Analysis › should provide positive feedback for robust strategy

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      260 |
      261 |       expect(analysis.overfit).toBe(false);
    > 262 |       expect(analysis.recommendations.some(r => r.includes('good generalization'))).toBe(true);
          |                                                                                     ^
      263 |     });
      264 |   });
      265 |

      at Object.toBe (app/domains/backtest/engine/__tests__/OverfittingDetector.test.ts:262:85)

FAIL app/lib/backtest/__tests__/OverfittingDetector.test.ts
  ● OverfittingDetector › Performance Degradation Detection › should not flag as overfitting when performance is consistent

    expect(received).toBeLessThan(expected)

    Expected: < 0.3
    Received:   0.4

      46 |       expect(analysis.overfit).toBe(false);
      47 |       expect(analysis.overfittingScore).toBeLessThan(0.5);
    > 48 |       expect(analysis.indicators.performanceDegradation).toBeLessThan(0.3);
         |                                                          ^
      49 |     });
      50 |   });
      51 |

      at Object.toBeLessThan (app/lib/backtest/__tests__/OverfittingDetector.test.ts:48:58)

  ● OverfittingDetector › Comprehensive Analysis › should provide positive feedback for robust strategy

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      260 |
      261 |       expect(analysis.overfit).toBe(false);
    > 262 |       expect(analysis.recommendations.some(r => r.includes('good generalization'))).toBe(true);
          |                                                                                     ^
      263 |     });
      264 |   });
      265 |

      at Object.toBe (app/lib/backtest/__tests__/OverfittingDetector.test.ts:262:85)

PASS app/lib/__tests__/ExitStrategy.test.ts
FAIL app/hooks/__tests__/useSignalAlerts.test.ts
  ● useSignalAlerts › hit rate monitoring › should store hit rate in localStorage

    expect(received).toBe(expected) // Object.is equality

    Expected: "80"
    Received: null

      89 |       );
      90 |
    > 91 |       expect(localStorageMock.getItem(`hitrate-${mockStock.symbol}`)).toBe('80');
         |                                                                       ^
      92 |     });
      93 |
      94 |     it('should detect accuracy drop and create alert', () => {

      at Object.toBe (app/hooks/__tests__/useSignalAlerts.test.ts:91:71)

  ● useSignalAlerts › hit rate monitoring › should handle first time hit rate tracking

    expect(received).toBe(expected) // Object.is equality

    Expected: "75"
    Received: null

      201 |       );
      202 |
    > 203 |       expect(localStorageMock.getItem(`hitrate-${mockStock.symbol}`)).toBe('75');
          |                                                                       ^
      204 |       expect(mockCreateStockAlert).not.toHaveBeenCalledWith(
      205 |         expect.objectContaining({
      206 |           alertType: 'ACCURACY_DROP'

      at Object.toBe (app/hooks/__tests__/useSignalAlerts.test.ts:203:71)

  ● useSignalAlerts › edge cases › should handle negative hit rates

    expect(received).toBe(expected) // Object.is equality

    Expected: "-10"
    Received: null

      559 |       );
      560 |
    > 561 |       expect(localStorageMock.getItem(`hitrate-${mockStock.symbol}`)).toBe('-10');
          |                                                                       ^
      562 |     });
      563 |
      564 |     it('should handle very high hit rates', () => {

      at Object.toBe (app/hooks/__tests__/useSignalAlerts.test.ts:561:71)

  ● useSignalAlerts › edge cases › should handle very high hit rates

    expect(received).toBe(expected) // Object.is equality

    Expected: "150"
    Received: null

      578 |       );
      579 |
    > 580 |       expect(localStorageMock.getItem(`hitrate-${mockStock.symbol}`)).toBe('150');
          |                                                                       ^
      581 |     });
      582 |   });
      583 | });

      at Object.toBe (app/hooks/__tests__/useSignalAlerts.test.ts:580:71)

FAIL app/domains/prediction/models/ml/__tests__/MLService.test.ts
  ● MLService › predict › should generate prediction result

    Invalid price data at index 8: close (1014.4126704417001) must be between low (1010.5670897968423) and high (1013.2550644513572)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at MLService.calculateAllFeatures [as predict] (app/domains/prediction/models/ml/MLService.ts:64:41)
      at Object.predict (app/domains/prediction/models/ml/__tests__/MLService.test.ts:53:38)

  ● MLService › predict › should include ensemble prediction

    Invalid price data at index 17: close (1010.2642614210646) must be between low (1004.0581588589439) and high (1009.4407239447146)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at MLService.calculateAllFeatures [as predict] (app/domains/prediction/models/ml/MLService.ts:64:41)
      at Object.predict (app/domains/prediction/models/ml/__tests__/MLService.test.ts:63:38)

  ● MLService › predict › should include features

    Invalid price data at index 27: close (1069.7435673174286) must be between low (1064.3473508428178) and high (1069.3656165552518)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at MLService.calculateAllFeatures [as predict] (app/domains/prediction/models/ml/MLService.ts:64:41)
      at Object.predict (app/domains/prediction/models/ml/__tests__/MLService.test.ts:71:38)

  ● MLService › predict › should include drift detection

    Invalid price data at index 22: close (1006.9246454837992) must be between low (1007.6819242799928) and high (1016.6217021528845)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at MLService.calculateAllFeatures [as predict] (app/domains/prediction/models/ml/MLService.ts:64:41)
      at Object.predict (app/domains/prediction/models/ml/__tests__/MLService.test.ts:79:38)

  ● MLService › predict › should accept macro and sentiment data

    Invalid price data at index 8: close (977.1432463584849) must be between low (979.3637232046785) and high (985.5807872261898)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at MLService.calculateAllFeatures [as predict] (app/domains/prediction/models/ml/MLService.ts:64:41)
      at Object.predict (app/domains/prediction/models/ml/__tests__/MLService.test.ts:110:38)

  ● MLService › recordPredictionResult › should record prediction result

    Invalid price data at index 2: close (1009.9006496270229) must be between low (998.6415189033949) and high (1008.177102077073)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at MLService.calculateAllFeatures [as predict] (app/domains/prediction/models/ml/MLService.ts:64:41)
      at Object.predict (app/domains/prediction/models/ml/__tests__/MLService.test.ts:119:23)

  ● MLService › recordPredictionResult › should record multiple results

    Invalid price data at index 5: close (1011.3186957877735) must be between low (1013.1351657982599) and high (1014.4477258663176)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at MLService.calculateAllFeatures [as predict] (app/domains/prediction/models/ml/MLService.ts:64:41)
      at Object.predict (app/domains/prediction/models/ml/__tests__/MLService.test.ts:128:23)

  ● MLService › evaluateRetrainingNeed › should recommend retraining after significant drift

    Invalid price data at index 5: close (999.4453215914073) must be between low (996.6030640816285) and high (998.8458862825757)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at MLService.calculateAllFeatures [as predict] (app/domains/prediction/models/ml/MLService.ts:64:41)
      at Object.predict (app/domains/prediction/models/ml/__tests__/MLService.test.ts:154:23)

  ● MLService › evaluateRetrainingNeed › should identify affected models

    Invalid price data at index 0: close (997.3563698678907) must be between low (997.5651776974937) and high (1003.7411464954855)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at MLService.calculateAllFeatures [as predict] (app/domains/prediction/models/ml/MLService.ts:64:41)
      at Object.predict (app/domains/prediction/models/ml/__tests__/MLService.test.ts:178:23)

  ● MLService › getModelPerformanceSummary › should return performance summary

    Invalid price data at index 18: close (1009.8829754113499) must be between low (999.9753042320573) and high (1009.4190306254457)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at MLService.calculateAllFeatures [as predict] (app/domains/prediction/models/ml/MLService.ts:64:41)
      at Object.predict (app/domains/prediction/models/ml/__tests__/MLService.test.ts:194:23)

  ● MLService › getModelPerformanceSummary › should include ensemble weights

    Invalid price data at index 0: close (1008.139160180249) must be between low (1009.1327655837562) and high (1011.7717572822497)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at MLService.calculateAllFeatures [as predict] (app/domains/prediction/models/ml/MLService.ts:64:41)
      at Object.predict (app/domains/prediction/models/ml/__tests__/MLService.test.ts:205:23)

  ● MLService › getModelPerformanceSummary › should include drift status

    Invalid price data at index 2: close (991.527387733602) must be between low (992.3463328225045) and high (997.5293656874031)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at MLService.calculateAllFeatures [as predict] (app/domains/prediction/models/ml/MLService.ts:64:41)
      at Object.predict (app/domains/prediction/models/ml/__tests__/MLService.test.ts:216:23)

  ● MLService › analyzeFeatureImportance › should analyze feature importance

    Invalid price data at index 0: close (990.6982948741161) must be between low (991.2274845907347) and high (995.6884071912931)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at MLService.calculateAllFeatures [as predict] (app/domains/prediction/models/ml/MLService.ts:64:41)
      at Object.predict (app/domains/prediction/models/ml/__tests__/MLService.test.ts:227:38)

  ● MLService › analyzeFeatureImportance › should categorize features by importance

    Invalid price data at index 0: close (996.0637583059996) must be between low (996.5840053535405) and high (1004.9273242487909)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at MLService.calculateAllFeatures [as predict] (app/domains/prediction/models/ml/MLService.ts:64:41)
      at Object.predict (app/domains/prediction/models/ml/__tests__/MLService.test.ts:235:38)

  ● MLService › healthCheck › should detect issues when drift occurs

    Invalid price data at index 5: close (989.2944390758771) must be between low (980.5316173828828) and high (989.2557830371316)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at MLService.calculateAllFeatures [as predict] (app/domains/prediction/models/ml/MLService.ts:64:41)
      at Object.predict (app/domains/prediction/models/ml/__tests__/MLService.test.ts:258:23)

  ● MLService › healthCheck › should provide recommendations

    Invalid price data at index 1: close (1002.1583926247688) must be between low (994.0635746278006) and high (1001.1984442515882)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at MLService.calculateAllFeatures [as predict] (app/domains/prediction/models/ml/MLService.ts:64:41)
      at Object.predict (app/domains/prediction/models/ml/__tests__/MLService.test.ts:275:23)

  ● MLService › reset › should reset all data

    Invalid price data at index 11: close (1014.3686265824855) must be between low (1007.6739819670111) and high (1013.917027990933)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at MLService.calculateAllFeatures [as predict] (app/domains/prediction/models/ml/MLService.ts:64:41)
      at Object.predict (app/domains/prediction/models/ml/__tests__/MLService.test.ts:286:23)

  ● MLService › reset › should reinitialize after reset

    Invalid price data at index 0: close (1003.5406558501821) must be between low (1003.714252163441) and high (1011.935694467673)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at MLService.calculateAllFeatures [as predict] (app/domains/prediction/models/ml/MLService.ts:64:41)
      at Object.predict (app/domains/prediction/models/ml/__tests__/MLService.test.ts:299:23)

  ● MLService › exportStatistics › should export statistics

    Invalid price data at index 4: close (1010.9114759960471) must be between low (1005.0980382300334) and high (1010.7678514439051)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at MLService.calculateAllFeatures [as predict] (app/domains/prediction/models/ml/MLService.ts:64:41)
      at Object.predict (app/domains/prediction/models/ml/__tests__/MLService.test.ts:310:23)

  ● MLService › exportStatistics › should include current weights

    Invalid price data at index 5: close (993.7191089260809) must be between low (995.4506697352392) and high (1000.8413611146417)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at MLService.calculateAllFeatures [as predict] (app/domains/prediction/models/ml/MLService.ts:64:41)
      at Object.predict (app/domains/prediction/models/ml/__tests__/MLService.test.ts:321:23)

  ● MLService › exportStatistics › should include performance summary

    Invalid price data at index 22: close (1039.5676685962187) must be between low (1039.949755408759) and high (1048.727645996767)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at MLService.calculateAllFeatures [as predict] (app/domains/prediction/models/ml/MLService.ts:64:41)
      at Object.predict (app/domains/prediction/models/ml/__tests__/MLService.test.ts:332:23)

  ● MLService › clearAllData › should clear all data

    Invalid price data at index 2: close (1005.9575453194822) must be between low (997.6872338309022) and high (1004.6779203478711)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at MLService.calculateAllFeatures [as predict] (app/domains/prediction/models/ml/MLService.ts:64:41)
      at Object.predict (app/domains/prediction/models/ml/__tests__/MLService.test.ts:345:23)

  ● MLService › integration scenarios › should handle complete prediction workflow

    Invalid price data at index 4: close (1005.1664340944235) must be between low (1006.154219472476) and high (1008.6668243866621)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at MLService.calculateAllFeatures [as predict] (app/domains/prediction/models/ml/MLService.ts:64:41)
      at Object.predict (app/domains/prediction/models/ml/__tests__/MLService.test.ts:361:38)

  ● MLService › integration scenarios › should handle drift detection and retraining workflow

    Invalid price data at index 14: close (1016.7734068874288) must be between low (1018.7019955026619) and high (1027.676388725862)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at MLService.calculateAllFeatures [as predict] (app/domains/prediction/models/ml/MLService.ts:64:41)
      at Object.predict (app/domains/prediction/models/ml/__tests__/MLService.test.ts:395:23)

  ● MLService › edge cases › should handle extreme prediction values

    Invalid price data at index 1: close (998.2122548596484) must be between low (998.3253163076754) and high (1003.9945544101408)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at MLService.calculateAllFeatures [as predict] (app/domains/prediction/models/ml/MLService.ts:64:41)
      at Object.predict (app/domains/prediction/models/ml/__tests__/MLService.test.ts:435:23)

  ● MLService › edge cases › should handle zero confidence predictions

    Invalid price data at index 16: close (1022.8553909061521) must be between low (1016.4731172857466) and high (1022.564366101473)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at MLService.calculateAllFeatures [as predict] (app/domains/prediction/models/ml/MLService.ts:64:41)
      at Object.predict (app/domains/prediction/models/ml/__tests__/MLService.test.ts:445:23)

PASS app/lib/ml/__tests__/MLService.test.ts
PASS app/domains/prediction/models/ml/__tests__/ModelDriftDetector.test.ts
PASS app/lib/ml/__tests__/ModelDriftDetector.test.ts
FAIL app/lib/services/__tests__/ml-model-service.test.ts
  ● MLModelService › TensorFlow.js integration › should support async prediction method

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: undefined

      444 |
      445 |       expect(result).toBeDefined();
    > 446 |       expect(result.isOk).toBe(true);
          |                           ^
      447 |       if (result.isOk) {
      448 |         expect(result.value.rfPrediction).toBeDefined();
      449 |         expect(result.value.xgbPrediction).toBeDefined();

      at Object.toBe (app/lib/services/__tests__/ml-model-service.test.ts:446:27)

FAIL app/lib/services/__tests__/enhanced-ml-service.test.ts
  ● EnhancedMLService › predictEnhanced › should return enhanced prediction with all required fields

    TypeError: service.predictEnhanced is not a function

      50 |   describe('predictEnhanced', () => {
      51 |     it('should return enhanced prediction with all required fields', async () => {
    > 52 |       const result = await service.predictEnhanced(baseFeatures, mockStock, mockHistoricalData);
         |                                    ^
      53 |
      54 |       expect(result).toHaveProperty('prediction');
      55 |       expect(result).toHaveProperty('confidence');

      at Object.predictEnhanced (app/lib/services/__tests__/enhanced-ml-service.test.ts:52:36)

  ● EnhancedMLService › predictEnhanced › should calculate Kelly fraction between 0 and 0.5

    TypeError: service.predictEnhanced is not a function

      63 |
      64 |     it('should calculate Kelly fraction between 0 and 0.5', async () => {
    > 65 |       const result = await service.predictEnhanced(baseFeatures, mockStock, mockHistoricalData);
         |                                    ^
      66 |
      67 |       expect(result.kellyFraction).toBeGreaterThanOrEqual(0);
      68 |       expect(result.kellyFraction).toBeLessThanOrEqual(0.5);

      at Object.predictEnhanced (app/lib/services/__tests__/enhanced-ml-service.test.ts:65:36)

  ● EnhancedMLService › predictEnhanced › should recommend position size between 1% and 20%

    TypeError: service.predictEnhanced is not a function

      70 |
      71 |     it('should recommend position size between 1% and 20%', async () => {
    > 72 |       const result = await service.predictEnhanced(baseFeatures, mockStock, mockHistoricalData);
         |                                    ^
      73 |
      74 |       expect(result.recommendedPositionSize).toBeGreaterThanOrEqual(1);
      75 |       expect(result.recommendedPositionSize).toBeLessThanOrEqual(20);

      at Object.predictEnhanced (app/lib/services/__tests__/enhanced-ml-service.test.ts:72:36)

  ● EnhancedMLService › predictEnhanced › should reduce confidence when drift risk is high

    TypeError: service.predictEnhanced is not a function

      78 |     it('should reduce confidence when drift risk is high', async () => {
      79 |       // First get baseline
    > 80 |       const baseline = await service.predictEnhanced(baseFeatures, mockStock, mockHistoricalData);
         |                                      ^
      81 |
      82 |       // Simulate predictions with increasing errors to trigger drift
      83 |       for (let i = 0; i < 60; i++) {

      at Object.predictEnhanced (app/lib/services/__tests__/enhanced-ml-service.test.ts:80:38)

  ● EnhancedMLService › predictEnhanced › should calculate expected value

    TypeError: service.predictEnhanced is not a function

       97 |
       98 |     it('should calculate expected value', async () => {
    >  99 |       const result = await service.predictEnhanced(baseFeatures, mockStock, mockHistoricalData);
          |                                    ^
      100 |
      101 |       expect(result.expectedValue).toBeDefined();
      102 |       expect(typeof result.expectedValue).toBe('number');

      at Object.predictEnhanced (app/lib/services/__tests__/enhanced-ml-service.test.ts:99:36)

  ● EnhancedMLService › predictEnhanced › should detect market regime

    TypeError: service.predictEnhanced is not a function

      104 |
      105 |     it('should detect market regime', async () => {
    > 106 |       const result = await service.predictEnhanced(baseFeatures, mockStock, mockHistoricalData);
          |                                    ^
      107 |
      108 |       expect(['TRENDING', 'RANGING', 'UNKNOWN']).toContain(result.marketRegime);
      109 |       expect(['HIGH', 'MEDIUM', 'LOW']).toContain(result.volatility);

      at Object.predictEnhanced (app/lib/services/__tests__/enhanced-ml-service.test.ts:106:36)

  ● EnhancedMLService › updatePerformance › should update hit rate correctly

    TypeError: service.updatePerformance is not a function

      115 |       // Simulate 10 predictions: 7 correct, 3 wrong
      116 |       for (let i = 0; i < 7; i++) {
    > 117 |         service.updatePerformance('RF', 2, 3); // Correct direction (both positive)
          |                 ^
      118 |       }
      119 |       for (let i = 0; i < 3; i++) {
      120 |         service.updatePerformance('RF', 2, -3); // Wrong direction

      at Object.updatePerformance (app/lib/services/__tests__/enhanced-ml-service.test.ts:117:17)

  ● EnhancedMLService › updatePerformance › should track average error

    TypeError: service.updatePerformance is not a function

      130 |
      131 |     it('should track average error', () => {
    > 132 |       service.updatePerformance('RF', 5, 6); // Error of 1
          |               ^
      133 |       service.updatePerformance('RF', 5, 8); // Error of 3
      134 |
      135 |       const stats = service.getModelStats();

      at Object.updatePerformance (app/lib/services/__tests__/enhanced-ml-service.test.ts:132:15)

  ● EnhancedMLService › updatePerformance › should maintain prediction history

    TypeError: service.updatePerformance is not a function

      141 |     it('should maintain prediction history', () => {
      142 |       for (let i = 0; i < 10; i++) {
    > 143 |         service.updatePerformance('RF', i, i + 1);
          |                 ^
      144 |       }
      145 |
      146 |       const stats = service.getModelStats();

      at Object.updatePerformance (app/lib/services/__tests__/enhanced-ml-service.test.ts:143:17)

  ● EnhancedMLService › dynamic weights › should adjust weights based on performance

    TypeError: service.getModelStats is not a function

      152 |   describe('dynamic weights', () => {
      153 |     it('should adjust weights based on performance', async () => {
    > 154 |       const initialStats = service.getModelStats();
          |                                    ^
      155 |       const initialWeights = { ...initialStats.weights };
      156 |
      157 |       // Make RF perform better than others

      at Object.getModelStats (app/lib/services/__tests__/enhanced-ml-service.test.ts:154:36)

  ● EnhancedMLService › dynamic weights › should ensure weights sum to 1

    TypeError: service.predictEnhanced is not a function

      172 |
      173 |     it('should ensure weights sum to 1', async () => {
    > 174 |       await service.predictEnhanced(baseFeatures, mockStock, mockHistoricalData);
          |                     ^
      175 |
      176 |       const stats = service.getModelStats();
      177 |       const sum = stats.weights.RF + stats.weights.XGB + stats.weights.LSTM;

      at Object.predictEnhanced (app/lib/services/__tests__/enhanced-ml-service.test.ts:174:21)

  ● EnhancedMLService › drift detection › should detect low drift initially

    TypeError: service.predictEnhanced is not a function

      183 |   describe('drift detection', () => {
      184 |     it('should detect low drift initially', async () => {
    > 185 |       const result = await service.predictEnhanced(baseFeatures, mockStock, mockHistoricalData);
          |                                    ^
      186 |
      187 |       expect(result.driftRisk).toBe('LOW');
      188 |     });

      at Object.predictEnhanced (app/lib/services/__tests__/enhanced-ml-service.test.ts:185:36)

  ● EnhancedMLService › drift detection › should detect drift when error increases

    TypeError: service.updatePerformance is not a function

      191 |       // Simulate many predictions with increasing error
      192 |       for (let i = 0; i < 60; i++) {
    > 193 |         service.updatePerformance('RF', 5, 0); // High error
          |                 ^
      194 |         service.updatePerformance('XGB', 5, 0);
      195 |         service.updatePerformance('LSTM', 5, 0);
      196 |       }

      at Object.updatePerformance (app/lib/services/__tests__/enhanced-ml-service.test.ts:193:17)

  ● EnhancedMLService › drift detection › should track days since retrain

    TypeError: service.getModelStats is not a function

      203 |
      204 |     it('should track days since retrain', async () => {
    > 205 |       const stats = service.getModelStats();
          |                             ^
      206 |
      207 |       expect(stats.drift.daysSinceRetrain).toBeGreaterThanOrEqual(0);
      208 |       expect(stats.drift.lastRetrainDate).toBeInstanceOf(Date);

      at Object.getModelStats (app/lib/services/__tests__/enhanced-ml-service.test.ts:205:29)

  ● EnhancedMLService › Kelly criterion › should calculate Kelly fraction for high confidence

    TypeError: service.predictEnhanced is not a function

      218 |       };
      219 |
    > 220 |       const result = await service.predictEnhanced(highConfFeatures, mockStock, mockHistoricalData);
          |                                    ^
      221 |
      222 |       expect(result.kellyFraction).toBeGreaterThan(0);
      223 |     });

      at Object.predictEnhanced (app/lib/services/__tests__/enhanced-ml-service.test.ts:220:36)

  ● EnhancedMLService › Kelly criterion › should reduce position size in high volatility

    TypeError: service.predictEnhanced is not a function

      230 |       }));
      231 |
    > 232 |       const result = await service.predictEnhanced(baseFeatures, mockStock, highVolData);
          |                                    ^
      233 |
      234 |       // Position size should be reasonable
      235 |       expect(result.recommendedPositionSize).toBeLessThanOrEqual(20);

      at Object.predictEnhanced (app/lib/services/__tests__/enhanced-ml-service.test.ts:232:36)

  ● EnhancedMLService › expected value › should calculate positive EV for strong signals

    TypeError: service.predictEnhanced is not a function

      245 |       };
      246 |
    > 247 |       const result = await service.predictEnhanced(strongFeatures, mockStock, mockHistoricalData);
          |                                    ^
      248 |
      249 |       // Strong signal should have positive expected value
      250 |       expect(result.expectedValue).toBeGreaterThan(0);

      at Object.predictEnhanced (app/lib/services/__tests__/enhanced-ml-service.test.ts:247:36)

  ● EnhancedMLService › expected value › should adjust EV for volatility

    TypeError: service.predictEnhanced is not a function

      258 |       }));
      259 |
    > 260 |       const result = await service.predictEnhanced(baseFeatures, mockStock, lowVolData);
          |                                    ^
      261 |
      262 |       expect(result.expectedValue).toBeDefined();
      263 |     });

      at Object.predictEnhanced (app/lib/services/__tests__/enhanced-ml-service.test.ts:260:36)

  ● EnhancedMLService › shouldTakeSignal › should reject signals with high drift risk

    TypeError: service.predictEnhanced is not a function

      266 |   describe('shouldTakeSignal', () => {
      267 |     it('should reject signals with high drift risk', async () => {
    > 268 |       const prediction = await service.predictEnhanced(baseFeatures, mockStock, mockHistoricalData);
          |                                        ^
      269 |
      270 |       // Manually set high drift
      271 |       const highDriftPrediction = {

      at Object.predictEnhanced (app/lib/services/__tests__/enhanced-ml-service.test.ts:268:40)

  ● EnhancedMLService › shouldTakeSignal › should accept signals with good EV and confidence

    TypeError: service.predictEnhanced is not a function

      280 |
      281 |     it('should accept signals with good EV and confidence', async () => {
    > 282 |       const prediction = await service.predictEnhanced(baseFeatures, mockStock, mockHistoricalData);
          |                                        ^
      283 |
      284 |       const goodSignal = {
      285 |         ...prediction,

      at Object.predictEnhanced (app/lib/services/__tests__/enhanced-ml-service.test.ts:282:40)

  ● EnhancedMLService › shouldTakeSignal › should reject signals with low confidence

    TypeError: service.predictEnhanced is not a function

      293 |
      294 |     it('should reject signals with low confidence', async () => {
    > 295 |       const prediction = await service.predictEnhanced(baseFeatures, mockStock, mockHistoricalData);
          |                                        ^
      296 |
      297 |       const lowConfSignal = {
      298 |         ...prediction,

      at Object.predictEnhanced (app/lib/services/__tests__/enhanced-ml-service.test.ts:295:40)

  ● EnhancedMLService › shouldTakeSignal › should reject signals with low expected value

    TypeError: service.predictEnhanced is not a function

      306 |
      307 |     it('should reject signals with low expected value', async () => {
    > 308 |       const prediction = await service.predictEnhanced(baseFeatures, mockStock, mockHistoricalData);
          |                                        ^
      309 |
      310 |       const lowEVSignal = {
      311 |         ...prediction,

      at Object.predictEnhanced (app/lib/services/__tests__/enhanced-ml-service.test.ts:308:40)

  ● EnhancedMLService › triggerRetrain › should reset drift metrics

    TypeError: service.updatePerformance is not a function

      323 |       // Trigger some drift
      324 |       for (let i = 0; i < 60; i++) {
    > 325 |         service.updatePerformance('RF', 5, 0);
          |                 ^
      326 |       }
      327 |
      328 |       await service.triggerRetrain();

      at Object.updatePerformance (app/lib/services/__tests__/enhanced-ml-service.test.ts:325:17)

  ● EnhancedMLService › triggerRetrain › should reset performance history

    TypeError: service.updatePerformance is not a function

      336 |       // Add some performance data
      337 |       for (let i = 0; i < 10; i++) {
    > 338 |         service.updatePerformance('RF', 5, 6);
          |                 ^
      339 |       }
      340 |
      341 |       await service.triggerRetrain();

      at Object.updatePerformance (app/lib/services/__tests__/enhanced-ml-service.test.ts:338:17)

  ● EnhancedMLService › getModelStats › should return all model statistics

    TypeError: service.getModelStats is not a function

      352 |   describe('getModelStats', () => {
      353 |     it('should return all model statistics', () => {
    > 354 |       const stats = service.getModelStats();
          |                             ^
      355 |
      356 |       expect(stats).toHaveProperty('weights');
      357 |       expect(stats).toHaveProperty('performance');

      at Object.getModelStats (app/lib/services/__tests__/enhanced-ml-service.test.ts:354:29)

  ● EnhancedMLService › getModelStats › should track Sharpe ratio

    TypeError: service.updatePerformance is not a function

      367 |       // Add predictions with returns
      368 |       for (let i = 0; i < 20; i++) {
    > 369 |         service.updatePerformance('RF', 2, 2.5 + Math.random());
          |                 ^
      370 |       }
      371 |
      372 |       const stats = service.getModelStats();

      at Object.updatePerformance (app/lib/services/__tests__/enhanced-ml-service.test.ts:369:17)

  ● EnhancedMLService › edge cases › should handle insufficient historical data

    TypeError: service.predictEnhanced is not a function

      382 |       const shortData = mockHistoricalData.slice(0, 5);
      383 |
    > 384 |       const result = await service.predictEnhanced(baseFeatures, mockStock, shortData);
          |                                    ^
      385 |
      386 |       expect(result).toBeDefined();
      387 |       expect(result.prediction).toBeDefined();

      at Object.predictEnhanced (app/lib/services/__tests__/enhanced-ml-service.test.ts:384:36)

  ● EnhancedMLService › edge cases › should handle extreme feature values

    TypeError: service.predictEnhanced is not a function

      403 |       };
      404 |
    > 405 |       const result = await service.predictEnhanced(extremeFeatures, mockStock, mockHistoricalData);
          |                                    ^
      406 |
      407 |       expect(result).toBeDefined();
      408 |       expect(result.confidence).toBeGreaterThanOrEqual(0);

      at Object.predictEnhanced (app/lib/services/__tests__/enhanced-ml-service.test.ts:405:36)

  ● EnhancedMLService › edge cases › should handle NaN in features

    TypeError: service.predictEnhanced is not a function

      425 |       };
      426 |
    > 427 |       const result = await service.predictEnhanced(nanFeatures, mockStock, mockHistoricalData);
          |                                    ^
      428 |
      429 |       expect(result).toBeDefined();
      430 |       expect(isFinite(result.confidence)).toBe(true);

      at Object.predictEnhanced (app/lib/services/__tests__/enhanced-ml-service.test.ts:427:36)

PASS app/lib/backtest/__tests__/AdvancedBacktestEngine.realistic-slippage.test.ts
PASS app/lib/__tests__/BacktestVisualizationUtils.test.ts
PASS app/lib/risk/__tests__/AutomaticRiskController.test.ts
PASS app/lib/risk/__tests__/KellyCalculator.test.ts
FAIL app/lib/api/__tests__/DataAggregator.improved.test.ts
  ● Test suite failed to run

    Cannot find module '../../__tests__/test-utils' from 'app/lib/api/__tests__/DataAggregator.improved.test.ts'

      25 |       mockIdbStorage[symbol] = merged;
      26 |       return Promise.resolve(merged);
    > 27 |     })
         |       ^
      28 |   }
      29 | }));
      30 |

      at Resolver._throwModNotFoundError (node_modules/jest-resolve/build/resolver.js:427:11)
      at Object.<anonymous> (app/lib/api/__tests__/DataAggregator.improved.test.ts:27:20)

FAIL app/lib/psychology/__tests__/SentimentAnalyzer.test.ts
  ● SentimentAnalyzer › calculateFearGreedIndex › should calculate fear and greed index

    expect(received).not.toBeNull()

    Received: null

      78 |     it('should calculate fear and greed index', () => {
      79 |       const result = analyzer.calculateFearGreedIndex(sampleEntries);
    > 80 |       expect(result).not.toBeNull();
         |                          ^
      81 |       expect(result?.current).toBeGreaterThanOrEqual(0);
      82 |       expect(result?.current).toBeLessThanOrEqual(100);
      83 |     });

      at Object.toBeNull (app/lib/psychology/__tests__/SentimentAnalyzer.test.ts:80:26)

  ● SentimentAnalyzer › calculateFearGreedIndex › should include all required components

    expect(received).toHaveProperty(path)

    Matcher error: received value must not be null nor undefined

    Received has value: null

      85 |     it('should include all required components', () => {
      86 |       const result = analyzer.calculateFearGreedIndex(sampleEntries);
    > 87 |       expect(result).toHaveProperty('current');
         |                      ^
      88 |       expect(result).toHaveProperty('label');
      89 |       expect(result).toHaveProperty('trend');
      90 |       expect(result).toHaveProperty('components');

      at Object.toHaveProperty (app/lib/psychology/__tests__/SentimentAnalyzer.test.ts:87:22)

  ● SentimentAnalyzer › calculateFearGreedIndex › should include individual emotion components

    expect(received).toHaveProperty(path)

    Matcher error: received value must not be null nor undefined

    Received has value: undefined

      94 |     it('should include individual emotion components', () => {
      95 |       const result = analyzer.calculateFearGreedIndex(sampleEntries);
    > 96 |       expect(result?.components).toHaveProperty('fear');
         |                                  ^
      97 |       expect(result?.components).toHaveProperty('greed');
      98 |       expect(result?.components).toHaveProperty('confidence');
      99 |       expect(result?.components).toHaveProperty('stress');

      at Object.toHaveProperty (app/lib/psychology/__tests__/SentimentAnalyzer.test.ts:96:34)

  ● SentimentAnalyzer › calculateFearGreedIndex › should assign correct label based on value

    expect(received).toMatch(expected)

    Matcher error: received value must be a string

    Received has value: undefined

      110 |       // Test with low fear/greed (should be greed side)
      111 |       const result = analyzer.calculateFearGreedIndex(testEntries);
    > 112 |       expect(result?.label).toMatch(/Greed|Neutral/);
          |                             ^
      113 |     });
      114 |
      115 |     it('should detect trend direction', () => {

      at Object.toMatch (app/lib/psychology/__tests__/SentimentAnalyzer.test.ts:112:29)

  ● SentimentAnalyzer › calculateFearGreedIndex › should detect trend direction

    expect(received).toContain(expected) // indexOf

    Expected value: undefined
    Received array: ["increasing", "decreasing", "stable"]

      115 |     it('should detect trend direction', () => {
      116 |       const result = analyzer.calculateFearGreedIndex(sampleEntries);
    > 117 |       expect(['increasing', 'decreasing', 'stable']).toContain(result?.trend);
          |                                                      ^
      118 |     });
      119 |   });
      120 |

      at Object.toContain (app/lib/psychology/__tests__/SentimentAnalyzer.test.ts:117:54)

  ● SentimentAnalyzer › analyzeEmotionTradeCorrelation › should analyze all emotion types

    expect(received).toContain(expected) // indexOf

    Expected value: "fear"
    Received array: []

      128 |       const correlations = analyzer.analyzeEmotionTradeCorrelation(sampleEntries);
      129 |       const emotionTypes = correlations.map(c => c.emotionType);
    > 130 |       expect(emotionTypes).toContain('fear');
          |                            ^
      131 |       expect(emotionTypes).toContain('greed');
      132 |       expect(emotionTypes).toContain('confidence');
      133 |       expect(emotionTypes).toContain('stress');

      at Object.toContain (app/lib/psychology/__tests__/SentimentAnalyzer.test.ts:130:28)

  ● SentimentAnalyzer › generateSentimentReport › should generate comprehensive report

    expect(received).not.toBeNull()

    Received: null

      219 |     it('should generate comprehensive report', () => {
      220 |       const report = analyzer.generateSentimentReport(sampleEntries);
    > 221 |       expect(report).not.toBeNull();
          |                          ^
      222 |
      223 |       expect(report).toHaveProperty('timestamp');
      224 |       expect(report).toHaveProperty('currentFearGreedIndex');

      at Object.toBeNull (app/lib/psychology/__tests__/SentimentAnalyzer.test.ts:221:26)

  ● SentimentAnalyzer › generateSentimentReport › should include insights

    expect(received).toHaveProperty(path)

    Matcher error: received value must not be null nor undefined

    Received has value: undefined

      231 |     it('should include insights', () => {
      232 |       const report = analyzer.generateSentimentReport(sampleEntries);
    > 233 |       expect(report?.insights).toHaveProperty('dominantEmotion');
          |                                ^
      234 |       expect(report?.insights).toHaveProperty('emotionalStability');
      235 |       expect(report?.insights).toHaveProperty('emotionalVolatility');
      236 |       expect(report?.insights).toHaveProperty('bestEmotionalState');

      at Object.toHaveProperty (app/lib/psychology/__tests__/SentimentAnalyzer.test.ts:233:32)

  ● SentimentAnalyzer › generateSentimentReport › should generate recommendations

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      240 |     it('should generate recommendations', () => {
      241 |       const report = analyzer.generateSentimentReport(sampleEntries);
    > 242 |       expect(Array.isArray(report?.recommendations)).toBe(true);
          |                                                      ^
      243 |       expect(report?.recommendations.length).toBeGreaterThan(0);
      244 |     });
      245 |

      at Object.toBe (app/lib/psychology/__tests__/SentimentAnalyzer.test.ts:242:54)

  ● SentimentAnalyzer › generateSentimentReport › should calculate emotional stability score

    expect(received).toBeGreaterThanOrEqual(expected)

    Matcher error: received value must be a number or bigint

    Received has value: undefined

      246 |     it('should calculate emotional stability score', () => {
      247 |       const report = analyzer.generateSentimentReport(sampleEntries);
    > 248 |       expect(report?.insights.emotionalStability).toBeGreaterThanOrEqual(0);
          |                                                   ^
      249 |       expect(report?.insights.emotionalStability).toBeLessThanOrEqual(100);
      250 |     });
      251 |

      at Object.toBeGreaterThanOrEqual (app/lib/psychology/__tests__/SentimentAnalyzer.test.ts:248:51)

  ● SentimentAnalyzer › generateSentimentReport › should identify best and worst emotional states

    expect(received).toHaveProperty(path)

    Matcher error: received value must not be null nor undefined

    Received has value: undefined

      252 |     it('should identify best and worst emotional states', () => {
      253 |       const report = analyzer.generateSentimentReport(sampleEntries);
    > 254 |       expect(report?.insights.bestEmotionalState).toHaveProperty('fear');
          |                                                   ^
      255 |       expect(report?.insights.bestEmotionalState).toHaveProperty('greed');
      256 |       expect(report?.insights.bestEmotionalState).toHaveProperty('confidence');
      257 |       expect(report?.insights.bestEmotionalState).toHaveProperty('stress');

      at Object.toHaveProperty (app/lib/psychology/__tests__/SentimentAnalyzer.test.ts:254:51)

  ● SentimentAnalyzer › Correlation Calculation › should handle perfect positive correlation

    expect(received).toBeGreaterThan(expected)

    Matcher error: received value must be a number or bigint

    Received has value: undefined

      274 |       const correlations = analyzer.analyzeEmotionTradeCorrelation(entries);
      275 |       const confidenceCorr = correlations.find(c => c.emotionType === 'confidence');
    > 276 |       expect(confidenceCorr?.correlationCoefficient).toBeGreaterThan(0);
          |                                                      ^
      277 |     });
      278 |
      279 |     it('should handle perfect negative correlation', () => {

      at Object.toBeGreaterThan (app/lib/psychology/__tests__/SentimentAnalyzer.test.ts:276:54)

  ● SentimentAnalyzer › Correlation Calculation › should handle perfect negative correlation

    expect(received).toBeLessThan(expected)

    Matcher error: received value must be a number or bigint

    Received has value: undefined

      286 |       const correlations = analyzer.analyzeEmotionTradeCorrelation(entries);
      287 |       const stressCorr = correlations.find(c => c.emotionType === 'stress');
    > 288 |       expect(stressCorr?.correlationCoefficient).toBeLessThan(0);
          |                                                  ^
      289 |     });
      290 |   });
      291 |

      at Object.toBeLessThan (app/lib/psychology/__tests__/SentimentAnalyzer.test.ts:288:50)

  ● SentimentAnalyzer › Configuration › should use custom lookback period

    expect(received).not.toBeNull()

    Received: null

      294 |       const customAnalyzer = createSentimentAnalyzer({ lookbackPeriod: 7 });
      295 |       const result = customAnalyzer.calculateFearGreedIndex(sampleEntries);
    > 296 |       expect(result).not.toBeNull();
          |                          ^
      297 |     });
      298 |
      299 |     it('should use custom min data points', () => {

      at Object.toBeNull (app/lib/psychology/__tests__/SentimentAnalyzer.test.ts:296:26)

PASS app/lib/aiAnalytics/__tests__/FeatureEngineering.test.ts
FAIL app/lib/strategies/__tests__/MultiTimeFrameStrategy.test.ts
  ● MultiTimeFrameStrategy › 整合性計算 › 全ての時間枠が同じシグナルの場合、整合性が1に近い

    expect(received).toBeGreaterThan(expected)

    Expected: > 0.6
    Received:   0.5

      153 |
      154 |       // 全て同じトレンドなので整合性が高い
    > 155 |       expect(result.alignment).toBeGreaterThan(0.6);
          |                                ^
      156 |     });
      157 |
      158 |     it('時間枠間でシグナルが異なる場合、整合性が低い', async () => {

      at Object.toBeGreaterThan (app/lib/strategies/__tests__/MultiTimeFrameStrategy.test.ts:155:32)

FAIL app/lib/execution/__tests__/ExecutionQualityMonitor.test.ts
  ● ExecutionQualityMonitor › Venue Performance › should track venue performance

    expect(jest.fn()).toHaveBeenCalled()

    Expected number of calls: >= 1
    Received number of calls:    0

      231 |       monitor.recordExecution(mockOrder);
      232 |
    > 233 |       expect(performanceUpdatedSpy).toHaveBeenCalled();
          |                                     ^
      234 |     });
      235 |
      236 |     it('should get venue performance', () => {

      at Object.toHaveBeenCalled (app/lib/execution/__tests__/ExecutionQualityMonitor.test.ts:233:37)

  ● ExecutionQualityMonitor › Venue Performance › should get venue performance

    expect(received).toBeDefined()

    Received: undefined

      245 |       const performance = monitor.getVenuePerformance('IBKR');
      246 |
    > 247 |       expect(performance).toBeDefined();
          |                           ^
      248 |       expect(performance?.venue).toBe('IBKR');
      249 |       expect(performance?.orderCount).toBeGreaterThan(0);
      250 |       expect(performance?.reliabilityScore).toBeGreaterThanOrEqual(0);

      at Object.toBeDefined (app/lib/execution/__tests__/ExecutionQualityMonitor.test.ts:247:27)

  ● ExecutionQualityMonitor › Venue Performance › should get all venue performances sorted by reliability

    expect(received).toBe(expected) // Object.is equality

    Expected: 2
    Received: 0

      274 |       const performances = monitor.getAllVenuePerformances();
      275 |
    > 276 |       expect(performances.length).toBe(2);
          |                                   ^
      277 |       expect(performances[0].reliabilityScore).toBeGreaterThanOrEqual(performances[1].reliabilityScore);
      278 |     });
      279 |   });

      at Object.toBe (app/lib/execution/__tests__/ExecutionQualityMonitor.test.ts:276:35)

FAIL app/lib/risk/__tests__/EnhancedPortfolioRiskMonitor.test.ts
  ● EnhancedPortfolioRiskMonitor › calculateEnhancedRiskMetrics › should calculate sector exposures correctly

    expect(received).toBeCloseTo(expected, precision)

    Expected: 100
    Received: 72.72727272727272

    Expected precision:    0
    Expected difference: < 0.5
    Received difference:   27.27272727272728

      82 |         0
      83 |       );
    > 84 |       expect(totalExposure).toBeCloseTo(100, 0);
         |                             ^
      85 |
      86 |       // Should have Technology sector (AAPL, MSFT)
      87 |       const techSector = metrics.sectorExposures.find(s => s.sector === 'Technology');

      at Object.toBeCloseTo (app/lib/risk/__tests__/EnhancedPortfolioRiskMonitor.test.ts:84:29)

  ● EnhancedPortfolioRiskMonitor › Edge cases › should handle single position portfolio

    expect(received).toBe(expected) // Object.is equality

    Expected: 1
    Received: 0.5804988662131518

      347 |       const metrics = singleMonitor.calculateEnhancedRiskMetrics();
      348 |
    > 349 |       expect(metrics.concentration.herfindahlIndex).toBe(1); // Perfect concentration
          |                                                     ^
      350 |       expect(metrics.concentration.effectivePositions).toBe(1);
      351 |     });
      352 |

      at Object.toBe (app/lib/risk/__tests__/EnhancedPortfolioRiskMonitor.test.ts:349:53)

PASS app/lib/data/__tests__/DataQualityValidator.test.ts
PASS app/domains/market-data/__tests__/DataQualityValidator.test.ts
PASS app/lib/__tests__/VolumeAnalysis.test.ts
PASS app/lib/risk/__tests__/RealTimeRiskCalculator.test.ts
PASS app/lib/risk/__tests__/DynamicRiskAdjuster.test.ts
FAIL app/domains/backtest/engine/__tests__/MonteCarloSimulator.test.ts
  ● Console

    console.log
      [MonteCarloSimulator] Starting simulation

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:207:13)

    console.log
        Number of simulations: 100

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:208:13)

    console.log
        Method: trade_shuffling

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:209:13)

    console.log
        Original trades: 50

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:210:13)

    console.log
      [MonteCarloSimulator] Simulation complete

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:235:13)

    console.log
      [MonteCarloSimulator] Starting simulation

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:207:13)

    console.log
        Number of simulations: 100

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:208:13)

    console.log
        Method: trade_shuffling

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:209:13)

    console.log
        Original trades: 50

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:210:13)

    console.log
      [MonteCarloSimulator] Simulation complete

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:235:13)

    console.log
      [MonteCarloSimulator] Starting simulation

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:207:13)

    console.log
        Number of simulations: 100

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:208:13)

    console.log
        Method: trade_shuffling

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:209:13)

    console.log
        Original trades: 50

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:210:13)

    console.log
      [MonteCarloSimulator] Simulation complete

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:235:13)

    console.log
      [MonteCarloSimulator] Starting simulation

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:207:13)

    console.log
        Number of simulations: 100

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:208:13)

    console.log
        Method: trade_shuffling

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:209:13)

    console.log
        Original trades: 50

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:210:13)

    console.log
      [MonteCarloSimulator] Simulation complete

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:235:13)

    console.log
      [MonteCarloSimulator] Starting simulation

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:207:13)

    console.log
        Number of simulations: 100

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:208:13)

    console.log
        Method: trade_shuffling

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:209:13)

    console.log
        Original trades: 50

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:210:13)

    console.log
      [MonteCarloSimulator] Simulation complete

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:235:13)

    console.log
      [MonteCarloSimulator] Starting simulation

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:207:13)

    console.log
        Number of simulations: 100

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:208:13)

    console.log
        Method: trade_shuffling

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:209:13)

    console.log
        Original trades: 50

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:210:13)

    console.log
      [MonteCarloSimulator] Simulation complete

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:235:13)

    console.log
      [MonteCarloSimulator] Starting simulation

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:207:13)

    console.log
        Number of simulations: 100

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:208:13)

    console.log
        Method: trade_shuffling

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:209:13)

    console.log
        Original trades: 50

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:210:13)

    console.log
      [MonteCarloSimulator] Simulation complete

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:235:13)

    console.log
      [MonteCarloSimulator] Starting simulation

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:207:13)

    console.log
        Number of simulations: 100

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:208:13)

    console.log
        Method: trade_shuffling

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:209:13)

    console.log
        Original trades: 50

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:210:13)

    console.log
      [MonteCarloSimulator] Simulation complete

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:235:13)

    console.log
      [MonteCarloSimulator] Starting simulation

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:207:13)

    console.log
        Number of simulations: 100

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:208:13)

    console.log
        Method: trade_shuffling

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:209:13)

    console.log
        Original trades: 50

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:210:13)

    console.log
      [MonteCarloSimulator] Simulation complete

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:235:13)

    console.log
      [MonteCarloSimulator] Starting simulation

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:207:13)

    console.log
        Number of simulations: 100

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:208:13)

    console.log
        Method: trade_shuffling

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:209:13)

    console.log
        Original trades: 50

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:210:13)

    console.log
      [MonteCarloSimulator] Simulation complete

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:235:13)

    console.log
      [MonteCarloSimulator] Starting simulation

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:207:13)

    console.log
        Number of simulations: 100

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:208:13)

    console.log
        Method: trade_shuffling

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:209:13)

    console.log
        Original trades: 50

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:210:13)

    console.log
      [MonteCarloSimulator] Simulation complete

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:235:13)

    console.log
      [MonteCarloSimulator] Starting simulation

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:207:13)

    console.log
        Number of simulations: 100

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:208:13)

    console.log
        Method: trade_shuffling

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:209:13)

    console.log
        Original trades: 50

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:210:13)

    console.log
      [MonteCarloSimulator] Simulation complete

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:235:13)

    console.log
      [MonteCarloSimulator] Starting simulation

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:207:13)

    console.log
        Number of simulations: 100

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:208:13)

    console.log
        Method: trade_shuffling

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:209:13)

    console.log
        Original trades: 50

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:210:13)

    console.log
      [MonteCarloSimulator] Simulation complete

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:235:13)

    console.log
      [MonteCarloSimulator] Starting simulation

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:207:13)

    console.log
        Number of simulations: 100

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:208:13)

    console.log
        Method: trade_shuffling

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:209:13)

    console.log
        Original trades: 50

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:210:13)

    console.log
      [MonteCarloSimulator] Simulation complete

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:235:13)

    console.log
      [MonteCarloSimulator] Starting simulation

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:207:13)

    console.log
        Number of simulations: 100

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:208:13)

    console.log
        Method: trade_shuffling

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:209:13)

    console.log
        Original trades: 50

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:210:13)

    console.log
      [MonteCarloSimulator] Simulation complete

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:235:13)

    console.log
      [MonteCarloSimulator] Starting simulation

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:207:13)

    console.log
        Number of simulations: 100

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:208:13)

    console.log
        Method: trade_shuffling

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:209:13)

    console.log
        Original trades: 50

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:210:13)

    console.log
      [MonteCarloSimulator] Simulation complete

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:235:13)

    console.log
      [MonteCarloSimulator] Starting simulation

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:207:13)

    console.log
        Number of simulations: 100

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:208:13)

    console.log
        Method: trade_shuffling

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:209:13)

    console.log
        Original trades: 50

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:210:13)

    console.log
      [MonteCarloSimulator] Simulation complete

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:235:13)

    console.log
      [MonteCarloSimulator] Starting simulation

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:207:13)

    console.log
        Number of simulations: 100

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:208:13)

    console.log
        Method: trade_shuffling

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:209:13)

    console.log
        Original trades: 50

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:210:13)

    console.log
      [MonteCarloSimulator] Simulation complete

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:235:13)

    console.log
      [MonteCarloSimulator] Starting simulation

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:207:13)

    console.log
        Number of simulations: 100

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:208:13)

    console.log
        Method: trade_shuffling

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:209:13)

    console.log
        Original trades: 50

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:210:13)

    console.log
      [MonteCarloSimulator] Simulation complete

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:235:13)

    console.log
      [MonteCarloSimulator] Starting simulation

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:207:13)

    console.log
        Number of simulations: 100

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:208:13)

    console.log
        Method: trade_shuffling

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:209:13)

    console.log
        Original trades: 50

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:210:13)

    console.log
      [MonteCarloSimulator] Simulation complete

      at MonteCarloSimulator.log [as runSimulation] (app/domains/backtest/engine/MonteCarloSimulator.ts:235:13)

  ● MonteCarloSimulator › Confidence Intervals › should calculate 90% confidence intervals

    expect(received).toBeGreaterThan(expected)

    Expected: > 0
    Received:   0

      215 |       expect(result.confidenceIntervals.confidence90.returns.lower).toBeDefined();
      216 |       expect(result.confidenceIntervals.confidence90.returns.upper).toBeDefined();
    > 217 |       expect(result.confidenceIntervals.confidence90.returns.range).toBeGreaterThan(0);
          |                                                                     ^
      218 |     });
      219 |
      220 |     it('should calculate 95% confidence intervals', async () => {

      at Object.toBeGreaterThan (app/domains/backtest/engine/__tests__/MonteCarloSimulator.test.ts:217:69)

  ● MonteCarloSimulator › Confidence Intervals › should calculate 99% confidence intervals

    expect(received).toBeDefined()

    Received: undefined

      231 |       expect(result.confidenceIntervals.confidence99).toBeDefined();
      232 |       expect(result.confidenceIntervals.confidence99.returns.lower).toBeDefined();
    > 233 |       expect(result.confidenceIntervals.confidence99.returns.upper).toBeDefined();
          |                                                                     ^
      234 |     });
      235 |
      236 |     it('should have wider intervals for higher confidence', async () => {

      at Object.toBeDefined (app/domains/backtest/engine/__tests__/MonteCarloSimulator.test.ts:233:69)

  ● MonteCarloSimulator › Confidence Intervals › should have wider intervals for higher confidence

    expect(received).toBeGreaterThan(expected)

    Expected: > 0
    Received:   NaN

      238 |
      239 |       expect(result.confidenceIntervals.confidence99.returns.range)
    > 240 |         .toBeGreaterThan(result.confidenceIntervals.confidence95.returns.range);
          |          ^
      241 |       expect(result.confidenceIntervals.confidence95.returns.range)
      242 |         .toBeGreaterThan(result.confidenceIntervals.confidence90.returns.range);
      243 |     });

      at Object.toBeGreaterThan (app/domains/backtest/engine/__tests__/MonteCarloSimulator.test.ts:240:10)

FAIL app/lib/backtest/__tests__/MonteCarloSimulator.test.ts
  ● MonteCarloSimulator › Confidence Intervals › should calculate 90% confidence intervals

    expect(received).toBeGreaterThan(expected)

    Expected: > 0
    Received:   0

      215 |       expect(result.confidenceIntervals.confidence90.returns.lower).toBeDefined();
      216 |       expect(result.confidenceIntervals.confidence90.returns.upper).toBeDefined();
    > 217 |       expect(result.confidenceIntervals.confidence90.returns.range).toBeGreaterThan(0);
          |                                                                     ^
      218 |     });
      219 |
      220 |     it('should calculate 95% confidence intervals', async () => {

      at Object.toBeGreaterThan (app/lib/backtest/__tests__/MonteCarloSimulator.test.ts:217:69)

  ● MonteCarloSimulator › Confidence Intervals › should calculate 99% confidence intervals

    expect(received).toBeDefined()

    Received: undefined

      231 |       expect(result.confidenceIntervals.confidence99).toBeDefined();
      232 |       expect(result.confidenceIntervals.confidence99.returns.lower).toBeDefined();
    > 233 |       expect(result.confidenceIntervals.confidence99.returns.upper).toBeDefined();
          |                                                                     ^
      234 |     });
      235 |
      236 |     it('should have wider intervals for higher confidence', async () => {

      at Object.toBeDefined (app/lib/backtest/__tests__/MonteCarloSimulator.test.ts:233:69)

  ● MonteCarloSimulator › Confidence Intervals › should have wider intervals for higher confidence

    expect(received).toBeGreaterThan(expected)

    Expected: > 0
    Received:   NaN

      238 |
      239 |       expect(result.confidenceIntervals.confidence99.returns.range)
    > 240 |         .toBeGreaterThan(result.confidenceIntervals.confidence95.returns.range);
          |          ^
      241 |       expect(result.confidenceIntervals.confidence95.returns.range)
      242 |         .toBeGreaterThan(result.confidenceIntervals.confidence90.returns.range);
      243 |     });

      at Object.toBeGreaterThan (app/lib/backtest/__tests__/MonteCarloSimulator.test.ts:240:10)

PASS app/domains/backtest/engine/__tests__/AdvancedBacktestEngine.realistic-slippage.test.ts
  ● Console

    console.log
      [BacktestEngine] Running backtest for TEST with strategy: Simple Buy and Hold

      at AdvancedBacktestEngine.log [as runBacktest] (app/domains/backtest/engine/AdvancedBacktestEngine.ts:177:13)

    console.log
      [BacktestEngine] Running backtest for TEST with strategy: Simple Buy and Hold

      at AdvancedBacktestEngine.log [as runBacktest] (app/domains/backtest/engine/AdvancedBacktestEngine.ts:177:13)

    console.log
      [BacktestEngine] Running backtest for TEST with strategy: Simple Buy and Hold

      at AdvancedBacktestEngine.log [as runBacktest] (app/domains/backtest/engine/AdvancedBacktestEngine.ts:177:13)

    console.log
      [BacktestEngine] Running backtest for TEST with strategy: Simple Buy and Hold

      at AdvancedBacktestEngine.log [as runBacktest] (app/domains/backtest/engine/AdvancedBacktestEngine.ts:177:13)

    console.log
      [BacktestEngine] Running backtest for TEST with strategy: Simple Buy and Hold

      at AdvancedBacktestEngine.log [as runBacktest] (app/domains/backtest/engine/AdvancedBacktestEngine.ts:177:13)

    console.log
      [BacktestEngine] Running backtest for TEST with strategy: Simple Buy and Hold

      at AdvancedBacktestEngine.log [as runBacktest] (app/domains/backtest/engine/AdvancedBacktestEngine.ts:177:13)

    console.log
      [BacktestEngine] Running backtest for TEST with strategy: High Volume Strategy

      at AdvancedBacktestEngine.log [as runBacktest] (app/domains/backtest/engine/AdvancedBacktestEngine.ts:177:13)

    console.log
      [BacktestEngine] Running backtest for TEST with strategy: Simple Buy and Hold

      at AdvancedBacktestEngine.log [as runBacktest] (app/domains/backtest/engine/AdvancedBacktestEngine.ts:177:13)

    console.log
      [BacktestEngine] Running backtest for TEST with strategy: Simple Buy and Hold

      at AdvancedBacktestEngine.log [as runBacktest] (app/domains/backtest/engine/AdvancedBacktestEngine.ts:177:13)

    console.log
      [BacktestEngine] Running backtest for TEST with strategy: Simple Buy and Hold

      at AdvancedBacktestEngine.log [as runBacktest] (app/domains/backtest/engine/AdvancedBacktestEngine.ts:177:13)

    console.log
      [BacktestEngine] Running backtest for TEST with strategy: Simple Buy and Hold

      at AdvancedBacktestEngine.log [as runBacktest] (app/domains/backtest/engine/AdvancedBacktestEngine.ts:177:13)

    console.log
      [BacktestEngine] Running backtest for TEST with strategy: Simple Buy and Hold

      at AdvancedBacktestEngine.log [as runBacktest] (app/domains/backtest/engine/AdvancedBacktestEngine.ts:177:13)

PASS app/lib/performance/__tests__/PerformanceReporter.test.ts
PASS app/domains/prediction/models/ml/__tests__/PredictionQualityMonitor.test.ts
  ● Console

    console.warn
      Prediction non-existent not found

      60 |     const record = this.predictions.get(predictionId);
      61 |     if (!record) {
    > 62 |       console.warn(`Prediction ${predictionId} not found`);
         |               ^
      63 |       return;
      64 |     }
      65 |

      at PredictionQualityMonitor.warn [as updateActual] (app/domains/prediction/models/ml/PredictionQualityMonitor.ts:62:15)
      at updateActual (app/domains/prediction/models/ml/__tests__/PredictionQualityMonitor.test.ts:49:28)
      at Object.toThrow (app/domains/prediction/models/ml/__tests__/PredictionQualityMonitor.test.ts:49:67)

PASS app/lib/ml/__tests__/PredictionQualityMonitor.test.ts
  ● Console

    console.warn
      [2026-02-08T08:47:22.946Z] [WARN]  Prediction non-existent not found

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at PredictionQualityMonitor.warn [as updateActual] (app/lib/ml/PredictionQualityMonitor.ts:63:14)
      at updateActual (app/lib/ml/__tests__/PredictionQualityMonitor.test.ts:49:28)
      at Object.toThrow (app/lib/ml/__tests__/PredictionQualityMonitor.test.ts:49:67)

PASS app/lib/alternativeData/__tests__/__integration__/EnhancedSentimentService.test.ts
FAIL app/lib/__tests__/AccuracyService.improved.test.ts
  ● Test suite failed to run

    Cannot find module './test-utils' from 'app/lib/__tests__/AccuracyService.improved.test.ts'

      29 |     analyzeStock: jest.fn()
      30 |   }
    > 31 | }));
         |     ^
      32 |
      33 | describe('AccuracyService - Improved Calculations', () => {
      34 |   describe('calculateRealTimeAccuracy', () => {

      at Resolver._throwModNotFoundError (node_modules/jest-resolve/build/resolver.js:427:11)
      at Object.<anonymous> (app/lib/__tests__/AccuracyService.improved.test.ts:31:20)

FAIL app/lib/services/__tests__/integrated-prediction-service.test.ts
  ● IntegratedPredictionService › generatePrediction › should generate complete prediction result

    TypeError: service.generatePrediction is not a function

      34 |   describe('generatePrediction', () => {
      35 |     it('should generate complete prediction result', async () => {
    > 36 |       const result = await service.generatePrediction(mockStock, mockData);
         |                                    ^
      37 |
      38 |       expect(result).toHaveProperty('signal');
      39 |       expect(result).toHaveProperty('enhancedMetrics');

      at Object.generatePrediction (app/lib/services/__tests__/integrated-prediction-service.test.ts:36:36)

  ● IntegratedPredictionService › generatePrediction › should include all enhanced metrics

    TypeError: service.generatePrediction is not a function

      42 |
      43 |     it('should include all enhanced metrics', async () => {
    > 44 |       const result = await service.generatePrediction(mockStock, mockData);
         |                                    ^
      45 |
      46 |       expect(result.enhancedMetrics).toHaveProperty('expectedValue');
      47 |       expect(result.enhancedMetrics).toHaveProperty('kellyFraction');

      at Object.generatePrediction (app/lib/services/__tests__/integrated-prediction-service.test.ts:44:36)

  ● IntegratedPredictionService › generatePrediction › should include model statistics

    TypeError: service.generatePrediction is not a function

      53 |
      54 |     it('should include model statistics', async () => {
    > 55 |       const result = await service.generatePrediction(mockStock, mockData);
         |                                    ^
      56 |
      57 |       expect(result.modelStats).toHaveProperty('rfHitRate');
      58 |       expect(result.modelStats).toHaveProperty('xgbHitRate');

      at Object.generatePrediction (app/lib/services/__tests__/integrated-prediction-service.test.ts:55:36)

  ● IntegratedPredictionService › generatePrediction › should generate valid signal

    TypeError: service.generatePrediction is not a function

      67 |
      68 |     it('should generate valid signal', async () => {
    > 69 |       const result = await service.generatePrediction(mockStock, mockData);
         |                                    ^
      70 |
      71 |       expect(['BUY', 'SELL', 'HOLD']).toContain(result.signal.type);
      72 |       expect(result.signal.confidence).toBeGreaterThanOrEqual(0);

      at Object.generatePrediction (app/lib/services/__tests__/integrated-prediction-service.test.ts:69:36)

  ● IntegratedPredictionService › generatePrediction › should set HOLD when signal does not meet quality threshold

    TypeError: service.generatePrediction is not a function

      83 |       }));
      84 |
    > 85 |       const result = await service.generatePrediction(mockStock, weakData);
         |                                    ^
      86 |
      87 |       // Weak signal should result in HOLD or low confidence
      88 |       if (result.signal.type !== 'HOLD') {

      at Object.generatePrediction (app/lib/services/__tests__/integrated-prediction-service.test.ts:85:36)

  ● IntegratedPredictionService › generatePrediction › should generate BUY signal for strong uptrend

    TypeError: service.generatePrediction is not a function

       99 |       }));
      100 |
    > 101 |       const result = await service.generatePrediction(mockStock, uptrendData);
          |                                    ^
      102 |
      103 |       // Should detect uptrend (may be BUY or HOLD depending on other factors)
      104 |       expect(['BUY', 'HOLD']).toContain(result.signal.type);

      at Object.generatePrediction (app/lib/services/__tests__/integrated-prediction-service.test.ts:101:36)

  ● IntegratedPredictionService › generatePrediction › should include market context when index data provided

    TypeError: service.generatePrediction is not a function

      108 |       const indexData = mockData.map(d => ({ ...d }));
      109 |
    > 110 |       const result = await service.generatePrediction(mockStock, mockData, indexData);
          |                                    ^
      111 |
      112 |       // Market context should be present
      113 |       if (result.signal.marketContext) {

      at Object.generatePrediction (app/lib/services/__tests__/integrated-prediction-service.test.ts:110:36)

  ● IntegratedPredictionService › generatePrediction › should calculate Kelly-based position sizing

    TypeError: service.generatePrediction is not a function

      119 |
      120 |     it('should calculate Kelly-based position sizing', async () => {
    > 121 |       const result = await service.generatePrediction(mockStock, mockData);
          |                                    ^
      122 |
      123 |       expect(result.enhancedMetrics.kellyFraction).toBeGreaterThanOrEqual(0);
      124 |       expect(result.enhancedMetrics.kellyFraction).toBeLessThanOrEqual(0.5);

      at Object.generatePrediction (app/lib/services/__tests__/integrated-prediction-service.test.ts:121:36)

  ● IntegratedPredictionService › generatePrediction › should include drift risk assessment

    TypeError: service.generatePrediction is not a function

      128 |
      129 |     it('should include drift risk assessment', async () => {
    > 130 |       const result = await service.generatePrediction(mockStock, mockData);
          |                                    ^
      131 |
      132 |       expect(['LOW', 'MEDIUM', 'HIGH']).toContain(result.enhancedMetrics.driftRisk);
      133 |     });

      at Object.generatePrediction (app/lib/services/__tests__/integrated-prediction-service.test.ts:130:36)

  ● IntegratedPredictionService › updateWithActualResult › should update performance for all models

    TypeError: service.getPerformanceMetrics is not a function

      136 |   describe('updateWithActualResult', () => {
      137 |     it('should update performance for all models', async () => {
    > 138 |       const initialMetrics = service.getPerformanceMetrics();
          |                                      ^
      139 |
      140 |       await service.updateWithActualResult('TEST', 2.0, 2.5);
      141 |

      at Object.getPerformanceMetrics (app/lib/services/__tests__/integrated-prediction-service.test.ts:138:38)

  ● IntegratedPredictionService › updateWithActualResult › should track correct predictions

    TypeError: service.updateWithActualResult is not a function

      151 |       // Make several correct predictions
      152 |       for (let i = 0; i < 5; i++) {
    > 153 |         await service.updateWithActualResult('TEST', 2.0, 2.5);
          |                       ^
      154 |       }
      155 |
      156 |       const metrics = service.getPerformanceMetrics();

      at Object.updateWithActualResult (app/lib/services/__tests__/integrated-prediction-service.test.ts:153:23)

  ● IntegratedPredictionService › updateWithActualResult › should detect drift after many incorrect predictions

    TypeError: service.updateWithActualResult is not a function

      163 |       // Make many incorrect predictions with large errors
      164 |       for (let i = 0; i < 60; i++) {
    > 165 |         await service.updateWithActualResult('TEST', 5.0, -3.0);
          |                       ^
      166 |       }
      167 |
      168 |       const metrics = service.getPerformanceMetrics();

      at Object.updateWithActualResult (app/lib/services/__tests__/integrated-prediction-service.test.ts:165:23)

  ● IntegratedPredictionService › getPerformanceMetrics › should return all performance metrics

    TypeError: service.getPerformanceMetrics is not a function

      175 |   describe('getPerformanceMetrics', () => {
      176 |     it('should return all performance metrics', () => {
    > 177 |       const metrics = service.getPerformanceMetrics();
          |                               ^
      178 |
      179 |       expect(metrics).toHaveProperty('hitRates');
      180 |       expect(metrics).toHaveProperty('sharpeRatios');

      at Object.getPerformanceMetrics (app/lib/services/__tests__/integrated-prediction-service.test.ts:177:31)

  ● IntegratedPredictionService › getPerformanceMetrics › should have hit rates between 0 and 1

    TypeError: service.getPerformanceMetrics is not a function

      184 |
      185 |     it('should have hit rates between 0 and 1', () => {
    > 186 |       const metrics = service.getPerformanceMetrics();
          |                               ^
      187 |
      188 |       expect(metrics.hitRates.rf).toBeGreaterThanOrEqual(0);
      189 |       expect(metrics.hitRates.rf).toBeLessThanOrEqual(1);

      at Object.getPerformanceMetrics (app/lib/services/__tests__/integrated-prediction-service.test.ts:186:31)

  ● IntegratedPredictionService › getPerformanceMetrics › should track drift status

    TypeError: service.getPerformanceMetrics is not a function

      195 |
      196 |     it('should track drift status', () => {
    > 197 |       const metrics = service.getPerformanceMetrics();
          |                               ^
      198 |
      199 |       expect(metrics.driftStatus).toHaveProperty('driftDetected');
      200 |       expect(metrics.driftStatus).toHaveProperty('daysSinceRetrain');

      at Object.getPerformanceMetrics (app/lib/services/__tests__/integrated-prediction-service.test.ts:197:31)

  ● IntegratedPredictionService › getPerformanceMetrics › should update metrics after predictions

    TypeError: service.getPerformanceMetrics is not a function

      207 |     it('should update metrics after predictions', async () => {
      208 |       // Get initial metrics
    > 209 |       const initial = service.getPerformanceMetrics();
          |                               ^
      210 |
      211 |       // Make some predictions and updates
      212 |       await service.updateWithActualResult('TEST', 2.0, 2.5);

      at Object.getPerformanceMetrics (app/lib/services/__tests__/integrated-prediction-service.test.ts:209:31)

  ● IntegratedPredictionService › retrainModels › should reset drift metrics

    TypeError: service.updateWithActualResult is not a function

      224 |       // Create some drift
      225 |       for (let i = 0; i < 60; i++) {
    > 226 |         await service.updateWithActualResult('TEST', 5.0, -3.0);
          |                       ^
      227 |       }
      228 |
      229 |       await service.retrainModels();

      at Object.updateWithActualResult (app/lib/services/__tests__/integrated-prediction-service.test.ts:226:23)

  ● IntegratedPredictionService › retrainModels › should reset performance history

    TypeError: service.updateWithActualResult is not a function

      238 |       // Add some performance data
      239 |       for (let i = 0; i < 10; i++) {
    > 240 |         await service.updateWithActualResult('TEST', 2.0, 2.5);
          |                       ^
      241 |       }
      242 |
      243 |       await service.retrainModels();

      at Object.updateWithActualResult (app/lib/services/__tests__/integrated-prediction-service.test.ts:240:23)

  ● IntegratedPredictionService › signal generation › should include drift warning in reason for high drift

    TypeError: service.updateWithActualResult is not a function

      254 |       // Generate high drift
      255 |       for (let i = 0; i < 60; i++) {
    > 256 |         await service.updateWithActualResult('TEST', 5.0, -3.0);
          |                       ^
      257 |       }
      258 |
      259 |       const result = await service.generatePrediction(mockStock, mockData);

      at Object.updateWithActualResult (app/lib/services/__tests__/integrated-prediction-service.test.ts:256:23)

  ● IntegratedPredictionService › signal generation › should include Kelly criterion in reason

    TypeError: service.generatePrediction is not a function

      265 |
      266 |     it('should include Kelly criterion in reason', async () => {
    > 267 |       const result = await service.generatePrediction(mockStock, mockData);
          |                                    ^
      268 |
      269 |       if (result.enhancedMetrics.kellyFraction > 0) {
      270 |         expect(result.signal.reason).toContain('Kelly');

      at Object.generatePrediction (app/lib/services/__tests__/integrated-prediction-service.test.ts:267:36)

  ● IntegratedPredictionService › signal generation › should include market regime in reason

    TypeError: service.generatePrediction is not a function

      273 |
      274 |     it('should include market regime in reason', async () => {
    > 275 |       const result = await service.generatePrediction(mockStock, mockData);
          |                                    ^
      276 |
      277 |       // Should mention regime or volatility
      278 |       const reason = result.signal.reason;

      at Object.generatePrediction (app/lib/services/__tests__/integrated-prediction-service.test.ts:275:36)

  ● IntegratedPredictionService › signal generation › should adjust target/stop based on Kelly fraction

    TypeError: service.generatePrediction is not a function

      286 |
      287 |     it('should adjust target/stop based on Kelly fraction', async () => {
    > 288 |       const result = await service.generatePrediction(mockStock, mockData);
          |                                    ^
      289 |
      290 |       const currentPrice = mockData[mockData.length - 1].close;
      291 |

      at Object.generatePrediction (app/lib/services/__tests__/integrated-prediction-service.test.ts:288:36)

  ● IntegratedPredictionService › edge cases › should handle minimal data

    TypeError: service.generatePrediction is not a function

      304 |       const minimalData = mockData.slice(0, 20);
      305 |
    > 306 |       const result = await service.generatePrediction(mockStock, minimalData);
          |                                    ^
      307 |
      308 |       expect(result).toBeDefined();
      309 |       expect(result.signal).toBeDefined();

      at Object.generatePrediction (app/lib/services/__tests__/integrated-prediction-service.test.ts:306:36)

  ● IntegratedPredictionService › edge cases › should handle high volatility data

    TypeError: service.generatePrediction is not a function

      318 |       }));
      319 |
    > 320 |       const result = await service.generatePrediction(mockStock, volatileData);
          |                                    ^
      321 |
      322 |       expect(result).toBeDefined();
      323 |       expect(result.enhancedMetrics.volatility).toBeDefined();

      at Object.generatePrediction (app/lib/services/__tests__/integrated-prediction-service.test.ts:320:36)

  ● IntegratedPredictionService › edge cases › should handle flat data

    TypeError: service.generatePrediction is not a function

      333 |       }));
      334 |
    > 335 |       const result = await service.generatePrediction(mockStock, flatData);
          |                                    ^
      336 |
      337 |       expect(result).toBeDefined();
      338 |       // Flat market should result in HOLD or low confidence

      at Object.generatePrediction (app/lib/services/__tests__/integrated-prediction-service.test.ts:335:36)

PASS app/lib/execution/__tests__/AlgorithmicExecutionEngine.test.ts (25.764 s)
PASS app/lib/execution/__tests__/OrderManagementSystem.test.ts
FAIL app/lib/__tests__/mocks/test-utils.ts
  ● Test suite failed to run

    Your test suite must contain at least one test.

      at onResult (node_modules/@jest/core/build/TestScheduler.js:133:18)
      at node_modules/@jest/core/build/TestScheduler.js:254:19
      at node_modules/emittery/index.js:363:13
          at Array.map (<anonymous>)
      at Emittery.emit (node_modules/emittery/index.js:361:23)

PASS app/lib/__tests__/technicalAnalysis.test.ts
PASS app/store/__tests__/psychologyStore.test.ts
FAIL app/lib/backtest/__tests__/LatencySimulator.test.ts
  ● LatencySimulator › Order Submission and Execution › should retrieve executable orders at specified time

    expect(received).toBeGreaterThan(expected)

    Expected: > 0
    Received:   0

      82 |       const future = currentTime + 5000; // 5 seconds later
      83 |       const executable = simulator.getExecutableOrders(future);
    > 84 |       expect(executable.length).toBeGreaterThan(0);
         |                                 ^
      85 |     });
      86 |
      87 |     it('should remove executed orders from queue', () => {

      at Object.toBeGreaterThan (app/lib/backtest/__tests__/LatencySimulator.test.ts:84:33)

  ● LatencySimulator › Order Submission and Execution › should remove executed orders from queue

    expect(received).toBe(expected) // Object.is equality

    Expected: 0
    Received: 1

       96 |
       97 |       status = simulator.getPendingOrdersStatus();
    >  98 |       expect(status.totalOrders).toBe(0);
          |                                  ^
       99 |     });
      100 |
      101 |     it('should cancel specific orders', () => {

      at Object.toBe (app/lib/backtest/__tests__/LatencySimulator.test.ts:98:34)

  ● LatencySimulator › Latency Presets › should apply low latency preset

    expect(received).toBeLessThan(expected)

    Expected: < 1000
    Received:   900040.521782355

      210 |
      211 |       const result = simulator.calculateLatency();
    > 212 |       expect(result.totalLatency).toBeLessThan(1000); // Less than 1 second
          |                                   ^
      213 |     });
      214 |
      215 |     it('should apply medium latency preset', () => {

      at Object.toBeLessThan (app/lib/backtest/__tests__/LatencySimulator.test.ts:212:35)

  ● LatencySimulator › Configuration Management › should support partial config updates

    expect(received).toBe(expected) // Object.is equality

    Expected: 500
    Received: undefined

      302 |       const config = simulator.getConfig();
      303 |       expect(config.apiLatency.min).toBe(50);
    > 304 |       expect(config.apiLatency.max).toBe(originalMax); // Should preserve
          |                                     ^
      305 |     });
      306 |   });
      307 |

      at Object.toBe (app/lib/backtest/__tests__/LatencySimulator.test.ts:304:37)

PASS app/lib/services/__tests__/signal-generation-service.test.ts
FAIL app/lib/validation/__tests__/OverfittingDetector.test.ts
  ● OverfittingDetector › White Noise Test › should pass for similar scores (white noise)

    expect(received).toBe(expected) // Object.is equality

    Expected: true
    Received: false

      211 |
      212 |       expect(analysis.tests.whiteNoiseCheck.pValue).toBeDefined();
    > 213 |       expect(analysis.tests.whiteNoiseCheck.passed).toBe(true);
          |                                                     ^
      214 |     });
      215 |   });
      216 |

      at Object.toBe (app/lib/validation/__tests__/OverfittingDetector.test.ts:213:53)

  ● OverfittingDetector › Recommendations › should provide positive recommendations for good models

    expect(received).toBe(expected) // Object.is equality

    Expected: false
    Received: true

      357 |
      358 |       expect(analysis.recommendations).toBeDefined();
    > 359 |       expect(analysis.isOverfit).toBe(false);
          |                                  ^
      360 |     });
      361 |   });
      362 |

      at Object.toBe (app/lib/validation/__tests__/OverfittingDetector.test.ts:359:34)

FAIL app/lib/__tests__/validation.test.ts
  ● Validation Utilities › validateRequiredString › should return Response for empty string

    ValidationError: Validation error for field: must be a non-empty string

      15 | export function validateRequiredString(value: unknown, fieldName: string): string {
      16 |   if (!value || typeof value !== 'string' || value.trim().length === 0) {
    > 17 |     throw new ValidationError(fieldName, `must be a non-empty string`);
         |           ^
      18 |   }
      19 |   return value.trim();
      20 | }

      at validateRequiredString (app/lib/validation.ts:17:11)
      at Object.<anonymous> (app/lib/__tests__/validation.test.ts:39:44)

  ● Validation Utilities › validateRequiredString › should return Response for whitespace only

    ValidationError: Validation error for field: must be a non-empty string

      15 | export function validateRequiredString(value: unknown, fieldName: string): string {
      16 |   if (!value || typeof value !== 'string' || value.trim().length === 0) {
    > 17 |     throw new ValidationError(fieldName, `must be a non-empty string`);
         |           ^
      18 |   }
      19 |   return value.trim();
      20 | }

      at validateRequiredString (app/lib/validation.ts:17:11)
      at Object.<anonymous> (app/lib/__tests__/validation.test.ts:45:44)

  ● Validation Utilities › validateRequiredString › should return Response for null

    ValidationError: Validation error for field: must be a non-empty string

      15 | export function validateRequiredString(value: unknown, fieldName: string): string {
      16 |   if (!value || typeof value !== 'string' || value.trim().length === 0) {
    > 17 |     throw new ValidationError(fieldName, `must be a non-empty string`);
         |           ^
      18 |   }
      19 |   return value.trim();
      20 | }

      at validateRequiredString (app/lib/validation.ts:17:11)
      at Object.<anonymous> (app/lib/__tests__/validation.test.ts:51:44)

  ● Validation Utilities › validateRequiredString › should return Response for undefined

    ValidationError: Validation error for field: must be a non-empty string

      15 | export function validateRequiredString(value: unknown, fieldName: string): string {
      16 |   if (!value || typeof value !== 'string' || value.trim().length === 0) {
    > 17 |     throw new ValidationError(fieldName, `must be a non-empty string`);
         |           ^
      18 |   }
      19 |   return value.trim();
      20 | }

      at validateRequiredString (app/lib/validation.ts:17:11)
      at Object.<anonymous> (app/lib/__tests__/validation.test.ts:57:44)

  ● Validation Utilities › validateRequiredString › should return Response for non-string

    ValidationError: Validation error for field: must be a non-empty string

      15 | export function validateRequiredString(value: unknown, fieldName: string): string {
      16 |   if (!value || typeof value !== 'string' || value.trim().length === 0) {
    > 17 |     throw new ValidationError(fieldName, `must be a non-empty string`);
         |           ^
      18 |   }
      19 |   return value.trim();
      20 | }

      at validateRequiredString (app/lib/validation.ts:17:11)
      at Object.<anonymous> (app/lib/__tests__/validation.test.ts:63:44)

  ● Validation Utilities › validateNumber › should return Response for non-number

    ValidationError: Validation error for field: must be a number

      30 | } = {}): number {
      31 |   if (typeof value !== 'number') {
    > 32 |     throw new ValidationError(fieldName, `must be a number`);
         |           ^
      33 |   }
      34 |
      35 |   if (options.finite && !isFinite(value)) {

      at validateNumber (app/lib/validation.ts:32:11)
      at Object.<anonymous> (app/lib/__tests__/validation.test.ts:79:36)

  ● Validation Utilities › validateNumber › should return Response for zero with positive option

    ValidationError: Validation error for field: must be positive

      38 |
      39 |   if (options.positive && value <= 0) {
    > 40 |     throw new ValidationError(fieldName, `must be positive`);
         |           ^
      41 |   }
      42 |
      43 |   if (options.min !== undefined && value < options.min) {

      at validateNumber (app/lib/validation.ts:40:11)
      at Object.<anonymous> (app/lib/__tests__/validation.test.ts:85:36)

  ● Validation Utilities › validateNumber › should return Response for negative with positive option

    ValidationError: Validation error for field: must be positive

      38 |
      39 |   if (options.positive && value <= 0) {
    > 40 |     throw new ValidationError(fieldName, `must be positive`);
         |           ^
      41 |   }
      42 |
      43 |   if (options.min !== undefined && value < options.min) {

      at validateNumber (app/lib/validation.ts:40:11)
      at Object.<anonymous> (app/lib/__tests__/validation.test.ts:91:36)

  ● Validation Utilities › validateBoolean › should return Response for non-boolean

    ValidationError: Validation error for field: must be a boolean

      57 | export function validateBoolean(value: unknown, fieldName: string): boolean {
      58 |   if (typeof value !== 'boolean') {
    > 59 |     throw new ValidationError(fieldName, `must be a boolean`);
         |           ^
      60 |   }
      61 |   return value;
      62 | }

      at validateBoolean (app/lib/validation.ts:59:11)
      at Object.<anonymous> (app/lib/__tests__/validation.test.ts:111:37)

  ● Validation Utilities › validateArray › should return Response for non-array

    ValidationError: Validation error for field: must be an array

      67 | export function validateArray<T>(value: unknown, fieldName: string, itemValidator?: (item: unknown) => T): T[] {
      68 |   if (!Array.isArray(value)) {
    > 69 |     throw new ValidationError(fieldName, `must be an array`);
         |           ^
      70 |   }
      71 |
      72 |   if (itemValidator) {

      at validateArray (app/lib/validation.ts:69:11)
      at Object.<anonymous> (app/lib/__tests__/validation.test.ts:123:35)

  ● Validation Utilities › validateObject › should return Response for null

    ValidationError: Validation error for field: must be an object

      89 | export function validateObject(value: unknown, fieldName: string): Record<string, unknown> {
      90 |   if (!value || typeof value !== 'object' || Array.isArray(value)) {
    > 91 |     throw new ValidationError(fieldName, `must be an object`);
         |           ^
      92 |   }
      93 |   return value as Record<string, unknown>;
      94 | }

      at validateObject (app/lib/validation.ts:91:11)
      at Object.<anonymous> (app/lib/__tests__/validation.test.ts:136:36)

  ● Validation Utilities › validateSymbol › should return Response for invalid characters

    ValidationError: Validation error for symbol: Invalid symbol format

      110 |   // シンボル形式の検証（英数字、ドット、カンマ、キャレット）
      111 |   if (!/^[A-Z0-9.,^]+$/.test(validatedSymbol.toUpperCase())) {
    > 112 |     throw new ValidationError('symbol', 'Invalid symbol format');
          |           ^
      113 |   }
      114 |
      115 |   // シンボル長の検証（DoS対策）

      at validateSymbol (app/lib/validation.ts:112:11)
      at Object.<anonymous> (app/lib/__tests__/validation.test.ts:160:36)

  ● Validation Utilities › validateSymbol › should return Response for symbol too long

    ValidationError: Validation error for symbol: Symbol too long

      118 |
      119 |   if (validatedSymbol.length > maxLength) {
    > 120 |     throw new ValidationError('symbol', 'Symbol too long');
          |           ^
      121 |   }
      122 |
      123 |   return validatedSymbol.toUpperCase();

      at validateSymbol (app/lib/validation.ts:120:11)
      at Object.<anonymous> (app/lib/__tests__/validation.test.ts:166:36)

  ● Validation Utilities › validateOrderSide › should return Response for invalid side

    ValidationError: Validation error for side: Invalid side: must be BUY or SELL

      135 |
      136 |   if (!['BUY', 'SELL'].includes(validatedSide)) {
    > 137 |     throw new ValidationError('side', 'Invalid side: must be BUY or SELL');
          |           ^
      138 |   }
      139 |
      140 |   return validatedSide as 'BUY' | 'SELL';

      at validateOrderSide (app/lib/validation.ts:137:11)
      at Object.<anonymous> (app/lib/__tests__/validation.test.ts:182:39)

  ● Validation Utilities › validateOrderType › should return Response for invalid type

    ValidationError: Validation error for orderType: Invalid orderType: must be MARKET or LIMIT

      152 |
      153 |   if (!['MARKET', 'LIMIT'].includes(validatedType)) {
    > 154 |     throw new ValidationError('orderType', 'Invalid orderType: must be MARKET or LIMIT');
          |           ^
      155 |   }
      156 |
      157 |   return validatedType as 'MARKET' | 'LIMIT';

      at validateOrderType (app/lib/validation.ts:154:11)
      at Object.<anonymous> (app/lib/__tests__/validation.test.ts:198:39)

  ● Validation Utilities › validateMarketType › should return Response for invalid market

    ValidationError: Validation error for market: Invalid market: must be japan or usa

      167 |
      168 |   if (!['japan', 'usa'].includes(validatedMarket)) {
    > 169 |     throw new ValidationError('market', 'Invalid market: must be japan or usa');
          |           ^
      170 |   }
      171 |
      172 |   return validatedMarket as 'japan' | 'usa';

      at validateMarketType (app/lib/validation.ts:169:11)
      at Object.<anonymous> (app/lib/__tests__/validation.test.ts:218:40)

  ● Validation Utilities › validateTradingAction › should return Response for invalid action

    ValidationError: Validation error for action: Unknown action

      185 |
      186 |   if (!validActions.includes(validatedAction)) {
    > 187 |     throw new ValidationError('action', 'Unknown action');
          |           ^
      188 |   }
      189 |
      190 |   return validatedAction;

      at validateTradingAction (app/lib/validation.ts:187:11)
      at Object.<anonymous> (app/lib/__tests__/validation.test.ts:234:43)

  ● Validation Utilities › validateDataType › should return Response for invalid type

    ValidationError: Validation error for type: Invalid type parameter. Use "history" or "quote".

      198 |
      199 |   if (!['history', 'quote'].includes(validatedType)) {
    > 200 |     throw new ValidationError('type', 'Invalid type parameter. Use "history" or "quote".');
          |           ^
      201 |   }
      202 |
      203 |   return validatedType as 'history' | 'quote';

      at validateDataType (app/lib/validation.ts:200:11)
      at Object.<anonymous> (app/lib/__tests__/validation.test.ts:250:38)

  ● Validation Utilities › validateInterval › should return Response for invalid interval

    ValidationError: Validation error for interval: Invalid interval. Use 1m, 5m, 15m, 1h, 4h, 1d, 1wk, or 1mo

      215 |
      216 |   if (!validIntervals.includes(validatedInterval)) {
    > 217 |     throw new ValidationError('interval', 'Invalid interval. Use 1m, 5m, 15m, 1h, 4h, 1d, 1wk, or 1mo');
          |           ^
      218 |   }
      219 |
      220 |   return validatedInterval;

      at validateInterval (app/lib/validation.ts:217:11)
      at Object.<anonymous> (app/lib/__tests__/validation.test.ts:270:38)

  ● Validation Utilities › validateDate › should return Response for invalid format

    ValidationError: Validation error for date: Invalid date format. Use YYYY-MM-DD.

      229 |   // YYYY-MM-DD形式の検証
      230 |   if (!/^\d{4}-\d{2}-\d{2}$/.test(validatedDate) || isNaN(Date.parse(validatedDate))) {
    > 231 |     throw new ValidationError(fieldName, `Invalid ${fieldName} format. Use YYYY-MM-DD.`);
          |           ^
      232 |   }
      233 |
      234 |   return validatedDate;

      at validateDate (app/lib/validation.ts:231:11)
      at Object.<anonymous> (app/lib/__tests__/validation.test.ts:282:34)

  ● Validation Utilities › validateDate › should return Response for invalid date

    ValidationError: Validation error for date: Invalid date format. Use YYYY-MM-DD.

      229 |   // YYYY-MM-DD形式の検証
      230 |   if (!/^\d{4}-\d{2}-\d{2}$/.test(validatedDate) || isNaN(Date.parse(validatedDate))) {
    > 231 |     throw new ValidationError(fieldName, `Invalid ${fieldName} format. Use YYYY-MM-DD.`);
          |           ^
      232 |   }
      233 |
      234 |   return validatedDate;

      at validateDate (app/lib/validation.ts:231:11)
      at Object.<anonymous> (app/lib/__tests__/validation.test.ts:288:34)

  ● Validation Utilities › validateOperator › should return Response for invalid operator

    ValidationError: Validation error for operator: Invalid operator: must be >, <, >=, <=, ==, above, below, crosses_above, crosses_below, equals, or between

      245 |
      246 |   if (!validOperators.includes(validatedOperator as ValidOperator)) {
    > 247 |     throw new ValidationError('operator', 'Invalid operator: must be >, <, >=, <=, ==, above, below, crosses_above, crosses_below, equals, or between');
          |           ^
      248 |   }
      249 |
      250 |   return validatedOperator as ValidOperator;

      at validateOperator (app/lib/validation.ts:247:11)
      at Object.<anonymous> (app/lib/__tests__/validation.test.ts:304:38)

  ● Validation Utilities › validateMode › should return Response for invalid mode

    ValidationError: Validation error for mode: Invalid mode: must be live, paper, or backtest

      264 |
      265 |   if (!['live', 'paper', 'backtest'].includes(validatedMode)) {
    > 266 |     throw new ValidationError('mode', 'Invalid mode: must be live, paper, or backtest');
          |           ^
      267 |   }
      268 |
      269 |   return validatedMode as 'live' | 'paper' | 'backtest';

      at validateMode (app/lib/validation.ts:266:11)
      at Object.<anonymous> (app/lib/__tests__/validation.test.ts:324:34)

  ● Validation Utilities › validateRiskLimits › should return Response for non-positive number

    ValidationError: Validation error for maxPositionSize: must be positive

      38 |
      39 |   if (options.positive && value <= 0) {
    > 40 |     throw new ValidationError(fieldName, `must be positive`);
         |           ^
      41 |   }
      42 |
      43 |   if (options.min !== undefined && value < options.min) {

      at validateNumber (app/lib/validation.ts:40:11)
      at validateNumber (app/lib/validation.ts:284:28)
      at Object.<anonymous> (app/lib/__tests__/validation.test.ts:349:40)

PASS app/__tests__/StockChart.test.tsx
FAIL app/lib/risk/__tests__/PortfolioRiskMonitor.test.ts
  ● PortfolioRiskMonitor › stress tests › should reflect worst-case scenarios appropriately

    expect(received).toBeLessThan(expected)

    Expected: < -30
    Received:   -14.66400029991331

      179 |
      180 |       expect(blackSwan).toBeDefined();
    > 181 |       expect(blackSwan!.portfolioImpactPercent).toBeLessThan(-30);
          |                                                 ^
      182 |     });
      183 |   });
      184 |

      at Object.toBeLessThan (app/lib/risk/__tests__/PortfolioRiskMonitor.test.ts:181:49)

  ● PortfolioRiskMonitor › edge cases › should handle empty portfolio

    expect(received).toBe(expected) // Object.is equality

    Expected: 0
    Received: 32900

      270 |
      271 |       expect(report).toBeDefined();
    > 272 |       expect(report.dailyVar.var95).toBe(0);
          |                                     ^
      273 |     });
      274 |
      275 |     it('should handle portfolio with no history', () => {

      at Object.toBe (app/lib/risk/__tests__/PortfolioRiskMonitor.test.ts:272:37)

  ● PortfolioRiskMonitor › sector exposure calculations › should calculate sector percentages correctly

    expect(received).toBeGreaterThan(expected)

    Expected: > 99
    Received:   38.2716049382716

      333 |
      334 |       // 合計は100%に近いはず（浮動小数点の誤差を許容）
    > 335 |       expect(totalPercent).toBeGreaterThan(99);
          |                            ^
      336 |       expect(totalPercent).toBeLessThan(101);
      337 |     });
      338 |   });

      at Object.toBeGreaterThan (app/lib/risk/__tests__/PortfolioRiskMonitor.test.ts:335:28)

PASS app/lib/__tests__/TransactionCostModel.test.ts
PASS app/store/__tests__/utils.test.ts
PASS app/lib/optimizer/__tests__/WinRateMaximizer.test.ts
PASS app/lib/__tests__/breakout.test.ts
FAIL app/lib/psychology/__tests__/AITradingCoach.test.ts
  ● AITradingCoach › analyzeTradingPatterns › should detect premature exit pattern

    expect(received).toBeDefined()

    Received: undefined

      103 |       const patterns = coach.analyzeTradingPatterns(sampleEntries);
      104 |       const prematureExit = patterns.find(p => p.patternType === 'premature_exit');
    > 105 |       expect(prematureExit).toBeDefined();
          |                             ^
      106 |       expect(prematureExit?.impact).toBe('negative');
      107 |     });
      108 |

      at Object.toBeDefined (app/lib/psychology/__tests__/AITradingCoach.test.ts:105:29)

  ● AITradingCoach › Pattern Detection › should detect overtrading pattern

    expect(received).toBeDefined()

    Received: undefined

      211 |       const patterns = coach.analyzeTradingPatterns(manyTrades);
      212 |       const overtrading = patterns.find(p => p.patternType === 'overtrading');
    > 213 |       expect(overtrading).toBeDefined();
          |                           ^
      214 |     });
      215 |
      216 |     it('should detect revenge trading pattern', () => {

      at Object.toBeDefined (app/lib/psychology/__tests__/AITradingCoach.test.ts:213:27)

  ● AITradingCoach › Pattern Detection › should detect revenge trading pattern

    expect(received).toBeDefined()

    Received: undefined

      224 |       const patterns = coach.analyzeTradingPatterns(revengeTrades);
      225 |       const revengeTrading = patterns.find(p => p.patternType === 'revenge_trading');
    > 226 |       expect(revengeTrading).toBeDefined();
          |                              ^
      227 |     });
      228 |
      229 |     it('should detect emotional trading pattern', () => {

      at Object.toBeDefined (app/lib/psychology/__tests__/AITradingCoach.test.ts:226:30)

  ● AITradingCoach › Pattern Detection › should detect emotional trading pattern

    expect(received).toBeDefined()

    Received: undefined

      236 |       const patterns = coach.analyzeTradingPatterns(emotionalTrades);
      237 |       const emotional = patterns.find(p => p.patternType === 'emotional');
    > 238 |       expect(emotional).toBeDefined();
          |                         ^
      239 |     });
      240 |
      241 |     it('should detect position sizing issues', () => {

      at Object.toBeDefined (app/lib/psychology/__tests__/AITradingCoach.test.ts:238:25)

  ● AITradingCoach › Pattern Detection › should detect position sizing issues

    expect(received).toBeDefined()

    Received: undefined

      249 |       const patterns = coach.analyzeTradingPatterns(varyingSizes);
      250 |       const positionSizing = patterns.find(p => p.patternType === 'position_sizing');
    > 251 |       expect(positionSizing).toBeDefined();
          |                              ^
      252 |     });
      253 |   });
      254 |

      at Object.toBeDefined (app/lib/psychology/__tests__/AITradingCoach.test.ts:251:30)

PASS app/lib/performance/__tests__/PerformanceAnalyzer.test.ts
FAIL app/lib/__tests__/MarketRegimeDetector.test.ts
  ● MarketRegimeDetector › detect › should detect trending market (ADX > 25)

    expect(received).toBe(expected) // Object.is equality

    Expected: "TRENDING_UP"
    Received: "TRENDING"

      79 |       const result = marketRegimeDetector.detect(data);
      80 |
    > 81 |       expect(result.regime).toBe('TRENDING_UP');
         |                             ^
      82 |       expect(result.adx).toBeGreaterThan(25);
      83 |       expect(result.trendDirection).toBe('UP');
      84 |     });

      at Object.toBe (app/lib/__tests__/MarketRegimeDetector.test.ts:81:29)

  ● MarketRegimeDetector › detect › should detect downtrend (ADX > 25, negative DI)

    expect(received).toBe(expected) // Object.is equality

    Expected: "TRENDING_DOWN"
    Received: "TRENDING"

      100 |       const result = marketRegimeDetector.detect(data);
      101 |
    > 102 |       expect(result.regime).toBe('TRENDING_DOWN');
          |                             ^
      103 |       expect(result.adx).toBeGreaterThan(25);
      104 |       expect(result.trendDirection).toBe('DOWN');
      105 |     });

      at Object.toBe (app/lib/__tests__/MarketRegimeDetector.test.ts:102:29)

  ● MarketRegimeDetector › regime persistence › should maintain regime for minimum 3 days before confirming

    expect(received).toBe(expected) // Object.is equality

    Expected: "TRENDING_UP"
    Received: "TRENDING"

      182 |
      183 |       // Should be initial detection
    > 184 |       expect(result1.regime).toBe('TRENDING_UP');
          |                              ^
      185 |       expect(result1.confidence).toBe('INITIAL');
      186 |
      187 |       // Simulate 3 consecutive days of same regime

      at Object.toBe (app/lib/__tests__/MarketRegimeDetector.test.ts:184:30)

  ● MarketRegimeDetector › regime persistence › should reset persistence counter on regime change

    expect(received).toBe(expected) // Object.is equality

    Expected: "TRENDING_UP"
    Received: "TRENDING"

      203 |       const uptrendData = generateOHLCVData(50, 'uptrend');
      204 |       const result1 = marketRegimeDetector.detect(uptrendData);
    > 205 |       expect(result1.regime).toBe('TRENDING_UP');
          |                              ^
      206 |
      207 |       // Switch to sideways - create data with very low volatility to ensure ADX < 20
      208 |       const sidewaysData: OHLCV[] = [];

      at Object.toBe (app/lib/__tests__/MarketRegimeDetector.test.ts:205:30)

  ● MarketRegimeDetector › getRegimeDescription › should return description for TRENDING_UP

    expect(received).toContain(expected) // indexOf

    Expected substring: "トレンド"
    Received string:    "レンジ相場 (中ボラ)"

      239 |       const result = marketRegimeDetector.getRegimeDescription('TRENDING_UP', 'UP', 'MEDIUM');
      240 |
    > 241 |       expect(result).toContain('トレンド');
          |                      ^
      242 |       expect(result).toContain('上昇');
      243 |     });
      244 |

      at Object.toContain (app/lib/__tests__/MarketRegimeDetector.test.ts:241:22)

  ● MarketRegimeDetector › getRecommendedStrategy › should recommend TrendFollowing for trending market

    expect(received).toBe(expected) // Object.is equality

    Expected: "TrendFollowing"
    Received: "None"

      261 |       const result = marketRegimeDetector.getRecommendedStrategy('TRENDING_UP', 'UP', 'MEDIUM');
      262 |
    > 263 |       expect(result.primary).toBe('TrendFollowing');
          |                              ^
      264 |       expect(result.weight).toBeGreaterThan(0.5);
      265 |     });
      266 |

      at Object.toBe (app/lib/__tests__/MarketRegimeDetector.test.ts:263:30)

  ● MarketRegimeDetector › getRecommendedStrategy › should recommend Breakout for high volatility

    expect(received).toContain(expected) // indexOf

    Expected value: "Breakout"
    Received array: []

      275 |       const result = marketRegimeDetector.getRecommendedStrategy('TRENDING_UP', 'UP', 'HIGH');
      276 |
    > 277 |       expect(result.secondary).toContain('Breakout');
          |                                ^
      278 |     });
      279 |   });
      280 |

      at Object.toContain (app/lib/__tests__/MarketRegimeDetector.test.ts:277:32)

FAIL app/__tests__/orderExecution.test.ts
  ● Order Execution - Atomic Operations › executeOrder › LONG注文を正しく実行する

    TypeError: _tradingStore.useTradingStore.getState is not a function

      10 |   beforeEach(() => {
      11 |     // テスト前にストアをリセット
    > 12 |     const { portfolio } = useTradingStore.getState();
         |                                           ^
      13 |
      14 |     // Explicitly reset the entire portfolio state including orders
      15 |     useTradingStore.setState({

      at Object.getState (app/__tests__/orderExecution.test.ts:12:43)

  ● Order Execution - Atomic Operations › executeOrder › SHORT注文を正しく実行する

    TypeError: _tradingStore.useTradingStore.getState is not a function

      10 |   beforeEach(() => {
      11 |     // テスト前にストアをリセット
    > 12 |     const { portfolio } = useTradingStore.getState();
         |                                           ^
      13 |
      14 |     // Explicitly reset the entire portfolio state including orders
      15 |     useTradingStore.setState({

      at Object.getState (app/__tests__/orderExecution.test.ts:12:43)

  ● Order Execution - Atomic Operations › executeOrder › 資金不足の場合に注文を拒否する

    TypeError: _tradingStore.useTradingStore.getState is not a function

      10 |   beforeEach(() => {
      11 |     // テスト前にストアをリセット
    > 12 |     const { portfolio } = useTradingStore.getState();
         |                                           ^
      13 |
      14 |     // Explicitly reset the entire portfolio state including orders
      15 |     useTradingStore.setState({

      at Object.getState (app/__tests__/orderExecution.test.ts:12:43)

  ● Order Execution - Atomic Operations › executeOrder › 既存のポジションを正しく更新する

    TypeError: _tradingStore.useTradingStore.getState is not a function

      10 |   beforeEach(() => {
      11 |     // テスト前にストアをリセット
    > 12 |     const { portfolio } = useTradingStore.getState();
         |                                           ^
      13 |
      14 |     // Explicitly reset the entire portfolio state including orders
      15 |     useTradingStore.setState({

      at Object.getState (app/__tests__/orderExecution.test.ts:12:43)

  ● Order Execution - Atomic Operations › executeOrder › 注文履歴を正しく記録する

    TypeError: _tradingStore.useTradingStore.getState is not a function

      10 |   beforeEach(() => {
      11 |     // テスト前にストアをリセット
    > 12 |     const { portfolio } = useTradingStore.getState();
         |                                           ^
      13 |
      14 |     // Explicitly reset the entire portfolio state including orders
      15 |     useTradingStore.setState({

      at Object.getState (app/__tests__/orderExecution.test.ts:12:43)

  ● Order Execution - Atomic Operations › closePosition › LONGポジションを正しく決済する

    TypeError: _tradingStore.useTradingStore.getState is not a function

      10 |   beforeEach(() => {
      11 |     // テスト前にストアをリセット
    > 12 |     const { portfolio } = useTradingStore.getState();
         |                                           ^
      13 |
      14 |     // Explicitly reset the entire portfolio state including orders
      15 |     useTradingStore.setState({

      at Object.getState (app/__tests__/orderExecution.test.ts:12:43)

  ● Order Execution - Atomic Operations › closePosition › SHORTポジションを正しく決済する

    TypeError: _tradingStore.useTradingStore.getState is not a function

      10 |   beforeEach(() => {
      11 |     // テスト前にストアをリセット
    > 12 |     const { portfolio } = useTradingStore.getState();
         |                                           ^
      13 |
      14 |     // Explicitly reset the entire portfolio state including orders
      15 |     useTradingStore.setState({

      at Object.getState (app/__tests__/orderExecution.test.ts:12:43)

  ● Order Execution - Atomic Operations › closePosition › 存在しないポジションの決済を拒否する

    TypeError: _tradingStore.useTradingStore.getState is not a function

      10 |   beforeEach(() => {
      11 |     // テスト前にストアをリセット
    > 12 |     const { portfolio } = useTradingStore.getState();
         |                                           ^
      13 |
      14 |     // Explicitly reset the entire portfolio state including orders
      15 |     useTradingStore.setState({

      at Object.getState (app/__tests__/orderExecution.test.ts:12:43)

  ● Order Execution - Atomic Operations › Race Condition Prevention › 複数の注文を同時に実行しても整合性を保つ

    TypeError: _tradingStore.useTradingStore.getState is not a function

      10 |   beforeEach(() => {
      11 |     // テスト前にストアをリセット
    > 12 |     const { portfolio } = useTradingStore.getState();
         |                                           ^
      13 |
      14 |     // Explicitly reset the entire portfolio state including orders
      15 |     useTradingStore.setState({

      at Object.getState (app/__tests__/orderExecution.test.ts:12:43)

  ● Order Execution - Atomic Operations › Race Condition Prevention › 資金不足の注文が他の注文に影響を与えない

    TypeError: _tradingStore.useTradingStore.getState is not a function

      10 |   beforeEach(() => {
      11 |     // テスト前にストアをリセット
    > 12 |     const { portfolio } = useTradingStore.getState();
         |                                           ^
      13 |
      14 |     // Explicitly reset the entire portfolio state including orders
      15 |     useTradingStore.setState({

      at Object.getState (app/__tests__/orderExecution.test.ts:12:43)

PASS app/lib/execution/__tests__/AdvancedOrderManager.test.ts
PASS app/lib/__tests__/ConsensusSignalService.test.ts
PASS app/lib/__tests__/mlPrediction.test.ts
PASS app/lib/aiAnalytics/AnomalyDetection/__tests__/EventPredictor.test.ts
PASS app/lib/__tests__/result-type.test.ts
FAIL app/lib/risk/__tests__/DynamicPositionSizer.test.ts
  ● DynamicPositionSizer › calculatePositionSize › should calculate volatility-based position size

    TypeError: (0 , _globals.expect)(...).toHaveLengthGreaterThan is not a function

      58 |       expect(result.positionValue).toBeGreaterThan(0);
      59 |       expect(result.riskAmount).toBeGreaterThan(0);
    > 60 |       expect(result.reasoning).toHaveLengthGreaterThan(0);
         |                                ^
      61 |     });
      62 |
      63 |     it('should calculate Kelly criterion position size', () => {

      at Object.toHaveLengthGreaterThan (app/lib/risk/__tests__/DynamicPositionSizer.test.ts:60:32)

  ● DynamicPositionSizer › calculatePositionSize › should calculate risk parity position size

    expect(received).toBeGreaterThan(expected)

    Expected: > 0
    Received:   0

      91 |       const result = positionSizer.calculatePositionSize(request);
      92 |
    > 93 |       expect(result.recommendedShares).toBeGreaterThan(0);
         |                                        ^
      94 |       expect(result.reasoning).toContain('リスクパリティアプローチ');
      95 |     });
      96 |

      at Object.toBeGreaterThan (app/lib/risk/__tests__/DynamicPositionSizer.test.ts:93:40)

  ● DynamicPositionSizer › calculatePositionSize › should calculate fixed position size

    expect(received).toContain(expected) // indexOf

    Expected value: "固定リスク"
    Received array: ["固定リスク: 2% ($1310.00)", "ストップロス距離: $5.00"]

      108 |
      109 |       expect(result.recommendedShares).toBeGreaterThan(0);
    > 110 |       expect(result.reasoning).toContain('固定リスク');
          |                                ^
      111 |     });
      112 |
      113 |     it('should calculate Optimal F position size', () => {

      at Object.toContain (app/lib/risk/__tests__/DynamicPositionSizer.test.ts:110:32)

  ● DynamicPositionSizer › calculatePositionSize › should calculate Optimal F position size

    expect(received).toContain(expected) // indexOf

    Expected value: "Optimal F"
    Received array: ["Optimal F: 2150.54%", "セーフOptimal F (50%): 1075.27%", "平均トレードリターン: 0.75%"]

      126 |
      127 |       expect(result.recommendedShares).toBeGreaterThanOrEqual(0);
    > 128 |       expect(result.reasoning).toContain('Optimal F');
          |                                ^
      129 |     });
      130 |
      131 |     it('should respect portfolio risk limits', () => {

      at Object.toContain (app/lib/risk/__tests__/DynamicPositionSizer.test.ts:128:32)

  ● DynamicPositionSizer › confidence adjustment › should reduce position size with lower confidence

    expect(received).toBeGreaterThan(expected)

    Expected: > 25
    Received:   25

      258 |       const lowConfResult = positionSizer.calculatePositionSize(lowConfidenceRequest);
      259 |
    > 260 |       expect(highConfResult.recommendedShares).toBeGreaterThan(lowConfResult.recommendedShares);
          |                                                ^
      261 |     });
      262 |   });
      263 |

      at Object.toBeGreaterThan (app/lib/risk/__tests__/DynamicPositionSizer.test.ts:260:48)

PASS app/lib/__tests__/forecastAccuracy.test.ts
FAIL app/__tests__/property-based.test.ts
  ● Test suite failed to run

    Cannot find module '../security/InputSanitizer' from 'app/__tests__/property-based.test.ts'

       9 | import {
      10 |   escapeHtml,
    > 11 |   sanitizeText,
         |                ^
      12 |   sanitizeNumber,
      13 |   sanitizeSymbol,
      14 |   detectSqlInjection,

      at Resolver._throwModNotFoundError (node_modules/jest-resolve/build/resolver.js:427:11)
      at Object.<anonymous> (app/__tests__/property-based.test.ts:11:25)

FAIL app/domains/prediction/models/ml/__tests__/EnsembleModel.test.ts
  ● EnsembleModel › predict › should generate ensemble prediction

    Invalid price data at index 0: close (993.0129204536806) must be between low (994.9095036137031) and high (996.4608640968942)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at Object.calculateAllFeatures (app/domains/prediction/models/ml/__tests__/EnsembleModel.test.ts:40:39)

  ● EnsembleModel › predict › should include all model predictions

    Invalid price data at index 0: close (991.9892092529071) must be between low (992.0445533052285) and high (997.9273285277175)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at Object.calculateAllFeatures (app/domains/prediction/models/ml/__tests__/EnsembleModel.test.ts:40:39)

  ● EnsembleModel › predict › should generate valid reasoning

    Invalid price data at index 3: close (982.3983804591124) must be between low (983.0945338690152) and high (990.0906259266334)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at Object.calculateAllFeatures (app/domains/prediction/models/ml/__tests__/EnsembleModel.test.ts:40:39)

  ● EnsembleModel › predict › should detect market regime

    Invalid price data at index 7: close (981.9226324513971) must be between low (982.7300211750204) and high (986.1232674949491)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at Object.calculateAllFeatures (app/domains/prediction/models/ml/__tests__/EnsembleModel.test.ts:40:39)

  ● EnsembleModel › predict › should normalize weights to sum to 1

    Invalid price data at index 0: close (994.8116538373434) must be between low (996.1690099239016) and high (1006.9945584969287)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at Object.calculateAllFeatures (app/domains/prediction/models/ml/__tests__/EnsembleModel.test.ts:40:39)

  ● EnsembleModel › predict › should apply macro sentiment adjustment when provided

    Invalid price data at index 5: close (989.4812398071813) must be between low (987.0219408413774) and high (989.2735638107051)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at Object.calculateAllFeatures (app/domains/prediction/models/ml/__tests__/EnsembleModel.test.ts:40:39)

  ● EnsembleModel › recordPerformance › should record model performance

    Invalid price data at index 8: close (986.176386328938) must be between low (986.3017848313625) and high (995.5443300564206)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at Object.calculateAllFeatures (app/domains/prediction/models/ml/__tests__/EnsembleModel.test.ts:40:39)

  ● EnsembleModel › recordPerformance › should update weights based on performance

    Invalid price data at index 33: close (1076.6691115547926) must be between low (1077.767751724178) and high (1083.9544139425855)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at Object.calculateAllFeatures (app/domains/prediction/models/ml/__tests__/EnsembleModel.test.ts:40:39)

  ● EnsembleModel › weight adjustment › should adjust weights for TRENDING regime

    Invalid price data at index 4: close (1001.6356739848453) must be between low (991.2934243105084) and high (1001.5878870970677)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at Object.calculateAllFeatures (app/domains/prediction/models/ml/__tests__/EnsembleModel.test.ts:40:39)

  ● EnsembleModel › weight adjustment › should adjust weights for RANGING regime

    Invalid price data at index 24: close (1003.1814501004089) must be between low (1003.6832592916472) and high (1006.1827458352687)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at Object.calculateAllFeatures (app/domains/prediction/models/ml/__tests__/EnsembleModel.test.ts:40:39)

  ● EnsembleModel › market regime detection › should detect TRENDING regime

    Invalid price data at index 0: close (994.206674103163) must be between low (989.763229930301) and high (993.417602707074)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at Object.calculateAllFeatures (app/domains/prediction/models/ml/__tests__/EnsembleModel.test.ts:40:39)

  ● EnsembleModel › market regime detection › should detect RANGING regime

    Invalid price data at index 5: close (1000.8750724522922) must be between low (995.4032583025071) and high (999.6370533433779)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at Object.calculateAllFeatures (app/domains/prediction/models/ml/__tests__/EnsembleModel.test.ts:40:39)

  ● EnsembleModel › getters › should return current weights

    Invalid price data at index 4: close (1018.893455087673) must be between low (1014.0650028486572) and high (1017.394577310372)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at Object.calculateAllFeatures (app/domains/prediction/models/ml/__tests__/EnsembleModel.test.ts:40:39)

  ● EnsembleModel › getters › should return model performance stats

    Invalid price data at index 5: close (1031.4738110633882) must be between low (1032.0214160041817) and high (1036.705463142899)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at Object.calculateAllFeatures (app/domains/prediction/models/ml/__tests__/EnsembleModel.test.ts:40:39)

  ● EnsembleModel › edge cases › should handle empty data gracefully

    Invalid price data at index 4: close (1002.1703353506427) must be between low (996.8072189861592) and high (1001.9612937942503)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at Object.calculateAllFeatures (app/domains/prediction/models/ml/__tests__/EnsembleModel.test.ts:40:39)

  ● EnsembleModel › edge cases › should handle predictions with extreme values

    Invalid price data at index 0: close (996.399568252819) must be between low (994.1012285540022) and high (995.186519134377)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at Object.calculateAllFeatures (app/domains/prediction/models/ml/__tests__/EnsembleModel.test.ts:40:39)

  ● EnsembleModel › edge cases › should maintain weight bounds

    Invalid price data at index 10: close (989.5160543669954) must be between low (990.7765383696769) and high (996.8596123470045)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at Object.calculateAllFeatures (app/domains/prediction/models/ml/__tests__/EnsembleModel.test.ts:40:39)

  ● EnsembleModel › resetWeights › should reset weights to base values

    Invalid price data at index 0: close (1000.8704000933849) must be between low (1001.2798044922453) and high (1012.7027901551148)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at Object.calculateAllFeatures (app/domains/prediction/models/ml/__tests__/EnsembleModel.test.ts:40:39)

  ● EnsembleModel › resetWeights › should clear performance history on reset

    Invalid price data at index 5: close (1000.1743492708193) must be between low (993.774460976236) and high (998.935094757139)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at Object.calculateAllFeatures (app/domains/prediction/models/ml/__tests__/EnsembleModel.test.ts:40:39)

FAIL app/lib/ml/__tests__/EnsembleModel.test.ts
  ● EnsembleModel › weight adjustment › should adjust weights for TRENDING regime

    Insufficient data for feature calculation (minimum 200 data points required)

      172 |   ): AllFeatures {
      173 |     if (data.length < 200) {
    > 174 |       throw new Error('Insufficient data for feature calculation (minimum 200 data points required)');
          |             ^
      175 |     }
      176 |
      177 |     const technical = this.calculateTechnicalFeatures(data);

      at FeatureEngineering.calculateAllFeatures (app/lib/ml/FeatureEngineering.ts:174:13)
      at Object.calculateAllFeatures (app/lib/ml/__tests__/EnsembleModel.test.ts:176:43)

  ● EnsembleModel › weight adjustment › should adjust weights for RANGING regime

    Insufficient data for feature calculation (minimum 200 data points required)

      172 |   ): AllFeatures {
      173 |     if (data.length < 200) {
    > 174 |       throw new Error('Insufficient data for feature calculation (minimum 200 data points required)');
          |             ^
      175 |     }
      176 |
      177 |     const technical = this.calculateTechnicalFeatures(data);

      at FeatureEngineering.calculateAllFeatures (app/lib/ml/FeatureEngineering.ts:174:13)
      at Object.calculateAllFeatures (app/lib/ml/__tests__/EnsembleModel.test.ts:198:43)

  ● EnsembleModel › market regime detection › should detect TRENDING regime

    Insufficient data for feature calculation (minimum 200 data points required)

      172 |   ): AllFeatures {
      173 |     if (data.length < 200) {
    > 174 |       throw new Error('Insufficient data for feature calculation (minimum 200 data points required)');
          |             ^
      175 |     }
      176 |
      177 |     const technical = this.calculateTechnicalFeatures(data);

      at FeatureEngineering.calculateAllFeatures (app/lib/ml/FeatureEngineering.ts:174:13)
      at Object.calculateAllFeatures (app/lib/ml/__tests__/EnsembleModel.test.ts:221:43)

  ● EnsembleModel › market regime detection › should detect RANGING regime

    Insufficient data for feature calculation (minimum 200 data points required)

      172 |   ): AllFeatures {
      173 |     if (data.length < 200) {
    > 174 |       throw new Error('Insufficient data for feature calculation (minimum 200 data points required)');
          |             ^
      175 |     }
      176 |
      177 |     const technical = this.calculateTechnicalFeatures(data);

      at FeatureEngineering.calculateAllFeatures (app/lib/ml/FeatureEngineering.ts:174:13)
      at Object.calculateAllFeatures (app/lib/ml/__tests__/EnsembleModel.test.ts:242:43)

  ● EnsembleModel › edge cases › should handle empty data gracefully

    expect(received).toThrow()

    Received function did not throw

      274 |       expect(() => {
      275 |         ensembleModel.predict(emptyData, mockFeatures);
    > 276 |       }).toThrow();
          |          ^
      277 |     });
      278 |
      279 |     it('should handle predictions with extreme values', () => {

      at Object.toThrow (app/lib/ml/__tests__/EnsembleModel.test.ts:276:10)

PASS app/components/StockChart/hooks/__tests__/useChartData.test.ts
FAIL app/lib/risk/__tests__/TailRiskHedging.test.ts
  ● TailRiskHedging › generateHedgeRecommendations › should generate recommendations based on tail risk

    TypeError: this.getYieldCurveDescription is not a function

      206 |     const effectiveness = Math.min(100, costBenefitRatio * 100);
      207 |     const implementationSteps = [
    > 208 |       `Check VIX term structure: ${this.getYieldCurveDescription()}`,
          |                                         ^
      209 |       `Hedge ratio: ${(hedgeRatio * 100).toFixed(1)}% of portfolio (${Math.floor(this.portfolio.totalValue * hedgeRatio / 1000)} VIX futures contracts)`,
      210 |       `Expected cost: $${vixCost.toFixed(2)} (includes roll costs in contango)`,
      211 |       'Enter long VIX futures position via VIX futures ETF (VIXY) or direct futures',

      at TailRiskHedging.getYieldCurveDescription (app/lib/risk/TailRiskHedging.ts:208:41)
      at TailRiskHedging.recommendVIXFuturesHedge [as generateHedgeRecommendations] (app/lib/risk/TailRiskHedging.ts:117:29)
      at Object.generateHedgeRecommendations (app/lib/risk/__tests__/TailRiskHedging.test.ts:99:39)

  ● TailRiskHedging › generateHedgeRecommendations › should recommend put options for high tail risk

    TypeError: this.getYieldCurveDescription is not a function

      206 |     const effectiveness = Math.min(100, costBenefitRatio * 100);
      207 |     const implementationSteps = [
    > 208 |       `Check VIX term structure: ${this.getYieldCurveDescription()}`,
          |                                         ^
      209 |       `Hedge ratio: ${(hedgeRatio * 100).toFixed(1)}% of portfolio (${Math.floor(this.portfolio.totalValue * hedgeRatio / 1000)} VIX futures contracts)`,
      210 |       `Expected cost: $${vixCost.toFixed(2)} (includes roll costs in contango)`,
      211 |       'Enter long VIX futures position via VIX futures ETF (VIXY) or direct futures',

      at TailRiskHedging.getYieldCurveDescription (app/lib/risk/TailRiskHedging.ts:208:41)
      at TailRiskHedging.recommendVIXFuturesHedge [as generateHedgeRecommendations] (app/lib/risk/TailRiskHedging.ts:117:29)
      at Object.generateHedgeRecommendations (app/lib/risk/__tests__/TailRiskHedging.test.ts:119:39)

  ● TailRiskHedging › generateHedgeRecommendations › should recommend VIX futures for negative skewness

    TypeError: this.getYieldCurveDescription is not a function

      206 |     const effectiveness = Math.min(100, costBenefitRatio * 100);
      207 |     const implementationSteps = [
    > 208 |       `Check VIX term structure: ${this.getYieldCurveDescription()}`,
          |                                         ^
      209 |       `Hedge ratio: ${(hedgeRatio * 100).toFixed(1)}% of portfolio (${Math.floor(this.portfolio.totalValue * hedgeRatio / 1000)} VIX futures contracts)`,
      210 |       `Expected cost: $${vixCost.toFixed(2)} (includes roll costs in contango)`,
      211 |       'Enter long VIX futures position via VIX futures ETF (VIXY) or direct futures',

      at TailRiskHedging.getYieldCurveDescription (app/lib/risk/TailRiskHedging.ts:208:41)
      at TailRiskHedging.recommendVIXFuturesHedge [as generateHedgeRecommendations] (app/lib/risk/TailRiskHedging.ts:117:29)
      at Object.generateHedgeRecommendations (app/lib/risk/__tests__/TailRiskHedging.test.ts:134:39)

  ● TailRiskHedging › generateHedgeRecommendations › should sort recommendations by cost-benefit ratio

    TypeError: this.getYieldCurveDescription is not a function

      206 |     const effectiveness = Math.min(100, costBenefitRatio * 100);
      207 |     const implementationSteps = [
    > 208 |       `Check VIX term structure: ${this.getYieldCurveDescription()}`,
          |                                         ^
      209 |       `Hedge ratio: ${(hedgeRatio * 100).toFixed(1)}% of portfolio (${Math.floor(this.portfolio.totalValue * hedgeRatio / 1000)} VIX futures contracts)`,
      210 |       `Expected cost: $${vixCost.toFixed(2)} (includes roll costs in contango)`,
      211 |       'Enter long VIX futures position via VIX futures ETF (VIXY) or direct futures',

      at TailRiskHedging.getYieldCurveDescription (app/lib/risk/TailRiskHedging.ts:208:41)
      at TailRiskHedging.recommendVIXFuturesHedge [as generateHedgeRecommendations] (app/lib/risk/TailRiskHedging.ts:117:29)
      at Object.generateHedgeRecommendations (app/lib/risk/__tests__/TailRiskHedging.test.ts:147:39)

  ● TailRiskHedging › buildOptimalHedgePortfolio › should select hedges within budget

    TypeError: this.getYieldCurveDescription is not a function

      206 |     const effectiveness = Math.min(100, costBenefitRatio * 100);
      207 |     const implementationSteps = [
    > 208 |       `Check VIX term structure: ${this.getYieldCurveDescription()}`,
          |                                         ^
      209 |       `Hedge ratio: ${(hedgeRatio * 100).toFixed(1)}% of portfolio (${Math.floor(this.portfolio.totalValue * hedgeRatio / 1000)} VIX futures contracts)`,
      210 |       `Expected cost: $${vixCost.toFixed(2)} (includes roll costs in contango)`,
      211 |       'Enter long VIX futures position via VIX futures ETF (VIXY) or direct futures',

      at TailRiskHedging.getYieldCurveDescription (app/lib/risk/TailRiskHedging.ts:208:41)
      at TailRiskHedging.recommendVIXFuturesHedge [as generateHedgeRecommendations] (app/lib/risk/TailRiskHedging.ts:117:29)
      at TailRiskHedging.generateHedgeRecommendations [as buildOptimalHedgePortfolio] (app/lib/risk/TailRiskHedging.ts:330:34)
      at Object.buildOptimalHedgePortfolio (app/lib/risk/__tests__/TailRiskHedging.test.ts:237:38)

  ● TailRiskHedging › buildOptimalHedgePortfolio › should prioritize high cost-benefit hedges

    TypeError: this.getYieldCurveDescription is not a function

      206 |     const effectiveness = Math.min(100, costBenefitRatio * 100);
      207 |     const implementationSteps = [
    > 208 |       `Check VIX term structure: ${this.getYieldCurveDescription()}`,
          |                                         ^
      209 |       `Hedge ratio: ${(hedgeRatio * 100).toFixed(1)}% of portfolio (${Math.floor(this.portfolio.totalValue * hedgeRatio / 1000)} VIX futures contracts)`,
      210 |       `Expected cost: $${vixCost.toFixed(2)} (includes roll costs in contango)`,
      211 |       'Enter long VIX futures position via VIX futures ETF (VIXY) or direct futures',

      at TailRiskHedging.getYieldCurveDescription (app/lib/risk/TailRiskHedging.ts:208:41)
      at TailRiskHedging.recommendVIXFuturesHedge [as generateHedgeRecommendations] (app/lib/risk/TailRiskHedging.ts:117:29)
      at TailRiskHedging.generateHedgeRecommendations [as buildOptimalHedgePortfolio] (app/lib/risk/TailRiskHedging.ts:330:34)
      at Object.buildOptimalHedgePortfolio (app/lib/risk/__tests__/TailRiskHedging.test.ts:250:38)

  ● TailRiskHedging › buildOptimalHedgePortfolio › should return empty array if no recommendations fit budget

    TypeError: this.getYieldCurveDescription is not a function

      206 |     const effectiveness = Math.min(100, costBenefitRatio * 100);
      207 |     const implementationSteps = [
    > 208 |       `Check VIX term structure: ${this.getYieldCurveDescription()}`,
          |                                         ^
      209 |       `Hedge ratio: ${(hedgeRatio * 100).toFixed(1)}% of portfolio (${Math.floor(this.portfolio.totalValue * hedgeRatio / 1000)} VIX futures contracts)`,
      210 |       `Expected cost: $${vixCost.toFixed(2)} (includes roll costs in contango)`,
      211 |       'Enter long VIX futures position via VIX futures ETF (VIXY) or direct futures',

      at TailRiskHedging.getYieldCurveDescription (app/lib/risk/TailRiskHedging.ts:208:41)
      at TailRiskHedging.recommendVIXFuturesHedge [as generateHedgeRecommendations] (app/lib/risk/TailRiskHedging.ts:117:29)
      at TailRiskHedging.generateHedgeRecommendations [as buildOptimalHedgePortfolio] (app/lib/risk/TailRiskHedging.ts:330:34)
      at Object.buildOptimalHedgePortfolio (app/lib/risk/__tests__/TailRiskHedging.test.ts:262:38)

RiskHedging › buildOptimalHedgePortfolio › should return empty array if no recommendations fit budget

    TypeError: this.getYieldCurveDescription is not a function

      206 |     const effectiveness = Math.min(100, costBenefitRatio * 100);
      207 |     const implementationSteps = [
    > 208 |       `Check VIX term structure: ${this.getYieldCurveDescription()}`,
          |                                         ^
      209 |       `Hedge ratio: ${(hedgeRatio * 100).toFixed(1)}% of portfolio (${Math.floor(this.portfolio.totalValue * hedgeRatio / 1000)} VIX futures contracts)`,
      210 |       `Expected cost: $${vixCost.toFixed(2)} (includes roll costs in contango)`,
      211 |       'Enter long VIX futures position via VIX futures ETF (VIXY) or direct futures',

      at TailRiskHedging.getYieldCurveDescription (app/lib/risk/TailRiskHedging.ts:208:41)
      at TailRiskHedging.recommendVIXFuturesHedge [as generateHedgeRecommendations] (app/lib/risk/TailRiskHedging.ts:117:29)
      at TailRiskHedging.generateHedgeRecommendations [as buildOptimalHedgePortfolio] (app/lib/risk/TailRiskHedging.ts:330:34)
      at Object.buildOptimalHedgePortfolio (app/lib/risk/__tests__/TailRiskHedging.test.ts:262:38)

PASS app/lib/execution/__tests__/AlgorithmicExecutionEngine.test.ts (25.589 s)
FAIL app/domains/prediction/models/ml/__tests__/ModelPipeline.test.ts (63.64 s)
  ● Console

    console.log
      Error when getting WebGL context:  TypeError: gl.disable is not a function
          at getWebGLContext (/app/trading-platform/tfjs-backend-webgl/src/canvas_util.ts:59:6)
          at isWebGLVersionEnabled (/app/trading-platform/tfjs-backend-webgl/src/webgl_util.ts:565:16)
          at Object.evaluationFn (/app/trading-platform/tfjs-backend-webgl/src/flags_webgl.ts:35:7)
          at Environment.Object.<anonymous>.Environment.evaluateFlag (/app/trading-platform/tfjs-core/src/environment.ts:148:40)
          at Environment.Object.<anonymous>.Environment.get (/app/trading-platform/tfjs-core/src/environment.ts:101:28)
          at Environment.Object.<anonymous>.Environment.getNumber (/app/trading-platform/tfjs-core/src/environment.ts:113:17)
          at Object.evaluationFn (/app/trading-platform/tfjs-backend-webgl/src/flags_webgl.ts:31:41)
          at Environment.Object.<anonymous>.Environment.evaluateFlag (/app/trading-platform/tfjs-core/src/environment.ts:148:40)
          at Environment.Object.<anonymous>.Environment.get (/app/trading-platform/tfjs-core/src/environment.ts:101:28)
          at Environment.Object.<anonymous>.Environment.getBool (/app/trading-platform/tfjs-core/src/environment.ts:117:17)
          at new MathBackendWebGL (/app/trading-platform/tfjs-backend-webgl/src/backend_webgl.ts:146:16)
          at Object.factory (/app/trading-platform/tfjs-backend-webgl/src/base.ts:25:34)
          at Engine.Object.<anonymous>.Engine.initializeBackend (/app/trading-platform/tfjs-core/src/engine.ts:328:44)
          at Engine.Object.<anonymous>.Engine.initializeBackendsAndReturnBest (/app/trading-platform/tfjs-core/src/engine.ts:414:41)
          at Engine.get (/app/trading-platform/tfjs-core/src/engine.ts:219:38)
          at Engine.Object.<anonymous>.Engine.makeTensor (/app/trading-platform/tfjs-core/src/engine.ts:810:31)
          at makeTensor (/app/trading-platform/tfjs-core/src/ops/tensor_ops_util.ts:86:17)
          at Object.tensor3d (/app/trading-platform/tfjs-core/src/ops/tensor3d.ts:65:10)
          at ModelPipeline.tensor3d [as prepareSequences] (/app/trading-platform/app/domains/prediction/models/ml/ModelPipeline.ts:516:23)
          at ModelPipeline.prepareSequences [as trainLSTMModel] (/app/trading-platform/app/domains/prediction/models/ml/ModelPipeline.ts:196:49)
          at Object.trainLSTMModel (/app/trading-platform/app/domains/prediction/models/ml/__tests__/ModelPipeline.test.ts:69:49)
          at Promise.then.completed (/app/trading-platform/node_modules/jest-circus/build/utils.js:298:28)
          at new Promise (<anonymous>)
          at callAsyncCircusFn (/app/trading-platform/node_modules/jest-circus/build/utils.js:231:10)
          at _callCircusTest (/app/trading-platform/node_modules/jest-circus/build/run.js:316:40)
          at processTicksAndRejections (node:internal/process/task_queues:105:5)
          at _runTest (/app/trading-platform/node_modules/jest-circus/build/run.js:252:3)
          at _runTestsForDescribeBlock (/app/trading-platform/node_modules/jest-circus/build/run.js:126:9)
          at _runTestsForDescribeBlock (/app/trading-platform/node_modules/jest-circus/build/run.js:121:9)
          at _runTestsForDescribeBlock (/app/trading-platform/node_modules/jest-circus/build/run.js:121:9)
          at run (/app/trading-platform/node_modules/jest-circus/build/run.js:71:3)
          at runAndTransformResultsToJestFormat (/app/trading-platform/node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapterInit.js:122:21)
          at jestAdapter (/app/trading-platform/node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapter.js:79:19)
          at runTestInternal (/app/trading-platform/node_modules/jest-runner/build/runTest.js:367:16)
          at runTest (/app/trading-platform/node_modules/jest-runner/build/runTest.js:444:34)
          at Object.worker (/app/trading-platform/node_modules/jest-runner/build/testWorker.js:106:12)

      at isWebGLVersionEnabled (tfjs-backend-webgl/src/webgl_util.ts:570:13)

    console.log
      Error when getting WebGL context:  TypeError: gl.disable is not a function
          at getWebGLContext (/app/trading-platform/tfjs-backend-webgl/src/canvas_util.ts:59:6)
          at isWebGLVersionEnabled (/app/trading-platform/tfjs-backend-webgl/src/webgl_util.ts:565:16)
          at Object.evaluationFn (/app/trading-platform/tfjs-backend-webgl/src/flags_webgl.ts:37:14)
          at Environment.Object.<anonymous>.Environment.evaluateFlag (/app/trading-platform/tfjs-core/src/environment.ts:148:40)
          at Environment.Object.<anonymous>.Environment.get (/app/trading-platform/tfjs-core/src/environment.ts:101:28)
          at Environment.Object.<anonymous>.Environment.getNumber (/app/trading-platform/tfjs-core/src/environment.ts:113:17)
          at Object.evaluationFn (/app/trading-platform/tfjs-backend-webgl/src/flags_webgl.ts:31:41)
          at Environment.Object.<anonymous>.Environment.evaluateFlag (/app/trading-platform/tfjs-core/src/environment.ts:148:40)
          at Environment.Object.<anonymous>.Environment.get (/app/trading-platform/tfjs-core/src/environment.ts:101:28)
          at Environment.Object.<anonymous>.Environment.getBool (/app/trading-platform/tfjs-core/src/environment.ts:117:17)
          at new MathBackendWebGL (/app/trading-platform/tfjs-backend-webgl/src/backend_webgl.ts:146:16)
          at Object.factory (/app/trading-platform/tfjs-backend-webgl/src/base.ts:25:34)
          at Engine.Object.<anonymous>.Engine.initializeBackend (/app/trading-platform/tfjs-core/src/engine.ts:328:44)
          at Engine.Object.<anonymous>.Engine.initializeBackendsAndReturnBest (/app/trading-platform/tfjs-core/src/engine.ts:414:41)
          at Engine.get (/app/trading-platform/tfjs-core/src/engine.ts:219:38)
          at Engine.Object.<anonymous>.Engine.makeTensor (/app/trading-platform/tfjs-core/src/engine.ts:810:31)
          at makeTensor (/app/trading-platform/tfjs-core/src/ops/tensor_ops_util.ts:86:17)
          at Object.tensor3d (/app/trading-platform/tfjs-core/src/ops/tensor3d.ts:65:10)
          at ModelPipeline.tensor3d [as prepareSequences] (/app/trading-platform/app/domains/prediction/models/ml/ModelPipeline.ts:516:23)
          at ModelPipeline.prepareSequences [as trainLSTMModel] (/app/trading-platform/app/domains/prediction/models/ml/ModelPipeline.ts:196:49)
          at Object.trainLSTMModel (/app/trading-platform/app/domains/prediction/models/ml/__tests__/ModelPipeline.test.ts:69:49)
          at Promise.then.completed (/app/trading-platform/node_modules/jest-circus/build/utils.js:298:28)
          at new Promise (<anonymous>)
          at callAsyncCircusFn (/app/trading-platform/node_modules/jest-circus/build/utils.js:231:10)
          at _callCircusTest (/app/trading-platform/node_modules/jest-circus/build/run.js:316:40)
          at processTicksAndRejections (node:internal/process/task_queues:105:5)
          at _runTest (/app/trading-platform/node_modules/jest-circus/build/run.js:252:3)
          at _runTestsForDescribeBlock (/app/trading-platform/node_modules/jest-circus/build/run.js:126:9)
          at _runTestsForDescribeBlock (/app/trading-platform/node_modules/jest-circus/build/run.js:121:9)
          at _runTestsForDescribeBlock (/app/trading-platform/node_modules/jest-circus/build/run.js:121:9)
          at run (/app/trading-platform/node_modules/jest-circus/build/run.js:71:3)
          at runAndTransformResultsToJestFormat (/app/trading-platform/node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapterInit.js:122:21)
          at jestAdapter (/app/trading-platform/node_modules/jest-circus/build/legacy-code-todo-rewrite/jestAdapter.js:79:19)
          at runTestInternal (/app/trading-platform/node_modules/jest-runner/build/runTest.js:367:16)
          at runTest (/app/trading-platform/node_modules/jest-runner/build/runTest.js:444:34)
          at Object.worker (/app/trading-platform/node_modules/jest-runner/build/testWorker.js:106:12)

      at isWebGLVersionEnabled (tfjs-backend-webgl/src/webgl_util.ts:570:13)

    console.warn
      Orthogonal initializer is being called on a matrix with more than 2000 (16384) elements: Slowness may result.

      at tfjs-layers/src/initializers.ts:558:17
      at tfjs-core/src/engine.ts:469:20
      at Engine.Object.<anonymous>.Engine.scopedRun (tfjs-core/src/engine.ts:480:19)
      at Engine.Object.<anonymous>.Engine.tidy (tfjs-core/src/engine.ts:467:17)
      at Object.tidy (tfjs-core/src/globals.ts:192:17)
      at Orthogonal.tidy [as apply] (tfjs-layers/src/initializers.ts:543:12)
      at LSTMCell.Object.<anonymous>.Layer.addWeight (tfjs-layers/src/engine/topology.ts:1288:35)
      at LSTMCell.Object.<anonymous>.LSTMCell.build (tfjs-layers/src/layers/recurrent.ts:1706:33)
      at LSTM.Object.<anonymous>.RNN.build (tfjs-layers/src/layers/recurrent.ts:516:17)
      at tfjs-layers/src/engine/topology.ts:981:14
      at nameScope (tfjs-layers/src/common.ts:48:20)
      at LSTM.Object.<anonymous>.Layer.apply (tfjs-layers/src/engine/topology.ts:967:12)
      at LSTM.Object.<anonymous>.RNN.apply (tfjs-layers/src/layers/recurrent.ts:697:25)
      at Sequential.Object.<anonymous>.Sequential.add (tfjs-layers/src/models.ts:491:15)
      at ModelPipeline.add [as buildLSTMModel] (app/domains/prediction/models/ml/ModelPipeline.ts:245:11)
      at ModelPipeline.buildLSTMModel (app/domains/prediction/models/ml/ModelPipeline.ts:202:24)
      at Object.trainLSTMModel (app/domains/prediction/models/ml/__tests__/ModelPipeline.test.ts:94:40)

    console.warn
      Orthogonal initializer is being called on a matrix with more than 2000 (4096) elements: Slowness may result.

      at tfjs-layers/src/initializers.ts:558:17
      at tfjs-core/src/engine.ts:469:20
      at Engine.Object.<anonymous>.Engine.scopedRun (tfjs-core/src/engine.ts:480:19)
      at Engine.Object.<anonymous>.Engine.tidy (tfjs-core/src/engine.ts:467:17)
      at Object.tidy (tfjs-core/src/globals.ts:192:17)
      at Orthogonal.tidy [as apply] (tfjs-layers/src/initializers.ts:543:12)
      at LSTMCell.Object.<anonymous>.Layer.addWeight (tfjs-layers/src/engine/topology.ts:1288:35)
      at LSTMCell.Object.<anonymous>.LSTMCell.build (tfjs-layers/src/layers/recurrent.ts:1706:33)
      at LSTM.Object.<anonymous>.RNN.build (tfjs-layers/src/layers/recurrent.ts:516:17)
      at tfjs-layers/src/engine/topology.ts:981:14
      at nameScope (tfjs-layers/src/common.ts:48:20)
      at LSTM.Object.<anonymous>.Layer.apply (tfjs-layers/src/engine/topology.ts:967:12)
      at LSTM.Object.<anonymous>.RNN.apply (tfjs-layers/src/layers/recurrent.ts:697:25)
      at Sequential.Object.<anonymous>.Sequential.add (tfjs-layers/src/models.ts:538:34)
      at ModelPipeline.add [as buildLSTMModel] (app/domains/prediction/models/ml/ModelPipeline.ts:259:13)
      at ModelPipeline.buildLSTMModel (app/domains/prediction/models/ml/ModelPipeline.ts:202:24)
      at Object.trainLSTMModel (app/domains/prediction/models/ml/__tests__/ModelPipeline.test.ts:94:40)

    console.warn
      Orthogonal initializer is being called on a matrix with more than 2000 (4096) elements: Slowness may result.

      at tfjs-layers/src/initializers.ts:558:17
      at tfjs-core/src/engine.ts:469:20
      at Engine.Object.<anonymous>.Engine.scopedRun (tfjs-core/src/engine.ts:480:19)
      at Engine.Object.<anonymous>.Engine.tidy (tfjs-core/src/engine.ts:467:17)
      at Object.tidy (tfjs-core/src/globals.ts:192:17)
      at Orthogonal.tidy [as apply] (tfjs-layers/src/initializers.ts:543:12)
      at LSTMCell.Object.<anonymous>.Layer.addWeight (tfjs-layers/src/engine/topology.ts:1288:35)
      at LSTMCell.Object.<anonymous>.LSTMCell.build (tfjs-layers/src/layers/recurrent.ts:1706:33)
      at LSTM.Object.<anonymous>.RNN.build (tfjs-layers/src/layers/recurrent.ts:516:17)
      at tfjs-layers/src/engine/topology.ts:981:14
      at nameScope (tfjs-layers/src/common.ts:48:20)
      at LSTM.Object.<anonymous>.Layer.apply (tfjs-layers/src/engine/topology.ts:967:12)
      at LSTM.Object.<anonymous>.RNN.apply (tfjs-layers/src/layers/recurrent.ts:697:25)
      at Sequential.Object.<anonymous>.Sequential.add (tfjs-layers/src/models.ts:491:15)
      at ModelPipeline.add [as buildLSTMModel] (app/domains/prediction/models/ml/ModelPipeline.ts:245:11)
      at ModelPipeline.buildLSTMModel (app/domains/prediction/models/ml/ModelPipeline.ts:202:24)
      at Object.trainLSTMModel (app/domains/prediction/models/ml/__tests__/ModelPipeline.test.ts:143:22)

    console.log
      Testing params: { learningRate: 0.001, sequenceLength: 5, lstmUnits: 16 }

      at ModelPipeline.log [as optimizeHyperparameters] (app/domains/prediction/models/ml/ModelPipeline.ts:658:15)

    console.error
      Error during hyperparameter optimization: TypeError: Cannot read properties of undefined (reading 'toFixed')
          at CustomCallback.valLoss [as epochEnd] (/app/trading-platform/app/domains/prediction/models/ml/ModelPipeline.ts:219:86)
          at CustomCallback.<anonymous> (/app/trading-platform/tfjs-layers/src/base_callbacks.ts:427:20)
          at step (/app/trading-platform/node_modules/tslib/tslib.es6.js:102:23)
          at Object.next (/app/trading-platform/node_modules/tslib/tslib.es6.js:83:53)
          at fulfilled (/app/trading-platform/node_modules/tslib/tslib.es6.js:73:58)

      683 |         model.dispose();
      684 |       } catch (error) {
    > 685 |         console.error('Error during hyperparameter optimization:', error);
          |                 ^
      686 |       }
      687 |     }
      688 |

      at ModelPipeline.error [as optimizeHyperparameters] (app/domains/prediction/models/ml/ModelPipeline.ts:685:17)
      at Object.<anonymous> (app/domains/prediction/models/ml/__tests__/ModelPipeline.test.ts:245:41)

    console.log
      Testing params: { learningRate: 0.001, sequenceLength: 5, lstmUnits: 32 }

      at ModelPipeline.log [as optimizeHyperparameters] (app/domains/prediction/models/ml/ModelPipeline.ts:658:15)

    console.warn
      Orthogonal initializer is being called on a matrix with more than 2000 (4096) elements: Slowness may result.

      at tfjs-layers/src/initializers.ts:558:17
      at tfjs-core/src/engine.ts:469:20
      at Engine.Object.<anonymous>.Engine.scopedRun (tfjs-core/src/engine.ts:480:19)
      at Engine.Object.<anonymous>.Engine.tidy (tfjs-core/src/engine.ts:467:17)
      at Object.tidy (tfjs-core/src/globals.ts:192:17)
      at Orthogonal.tidy [as apply] (tfjs-layers/src/initializers.ts:543:12)
      at LSTMCell.Object.<anonymous>.Layer.addWeight (tfjs-layers/src/engine/topology.ts:1288:35)
      at LSTMCell.Object.<anonymous>.LSTMCell.build (tfjs-layers/src/layers/recurrent.ts:1706:33)
      at LSTM.Object.<anonymous>.RNN.build (tfjs-layers/src/layers/recurrent.ts:516:17)
      at tfjs-layers/src/engine/topology.ts:981:14
      at nameScope (tfjs-layers/src/common.ts:48:20)
      at LSTM.Object.<anonymous>.Layer.apply (tfjs-layers/src/engine/topology.ts:967:12)
      at LSTM.Object.<anonymous>.RNN.apply (tfjs-layers/src/layers/recurrent.ts:697:25)
      at Sequential.Object.<anonymous>.Sequential.add (tfjs-layers/src/models.ts:491:15)
      at ModelPipeline.add [as buildLSTMModel] (app/domains/prediction/models/ml/ModelPipeline.ts:245:11)
      at ModelPipeline.buildLSTMModel (app/domains/prediction/models/ml/ModelPipeline.ts:202:24)
      at ModelPipeline.trainLSTMModel [as optimizeHyperparameters] (app/domains/prediction/models/ml/ModelPipeline.ts:674:47)
      at Object.<anonymous> (app/domains/prediction/models/ml/__tests__/ModelPipeline.test.ts:245:41)

    console.error
      Error during hyperparameter optimization: TypeError: Cannot read properties of undefined (reading 'toFixed')
          at CustomCallback.valLoss [as epochEnd] (/app/trading-platform/app/domains/prediction/models/ml/ModelPipeline.ts:219:86)
          at CustomCallback.<anonymous> (/app/trading-platform/tfjs-layers/src/base_callbacks.ts:427:20)
          at step (/app/trading-platform/node_modules/tslib/tslib.es6.js:102:23)
          at Object.next (/app/trading-platform/node_modules/tslib/tslib.es6.js:83:53)
          at fulfilled (/app/trading-platform/node_modules/tslib/tslib.es6.js:73:58)

      683 |         model.dispose();
      684 |       } catch (error) {
    > 685 |         console.error('Error during hyperparameter optimization:', error);
          |                 ^
      686 |       }
      687 |     }
      688 |

      at ModelPipeline.error [as optimizeHyperparameters] (app/domains/prediction/models/ml/ModelPipeline.ts:685:17)
      at Object.<anonymous> (app/domains/prediction/models/ml/__tests__/ModelPipeline.test.ts:245:41)

    console.log
      Testing params: { learningRate: 0.001, sequenceLength: 10, lstmUnits: 16 }

      at ModelPipeline.log [as optimizeHyperparameters] (app/domains/prediction/models/ml/ModelPipeline.ts:658:15)

    console.error
      Error during hyperparameter optimization: TypeError: Cannot read properties of undefined (reading 'toFixed')
          at CustomCallback.valLoss [as epochEnd] (/app/trading-platform/app/domains/prediction/models/ml/ModelPipeline.ts:219:86)
          at CustomCallback.<anonymous> (/app/trading-platform/tfjs-layers/src/base_callbacks.ts:427:20)
          at step (/app/trading-platform/node_modules/tslib/tslib.es6.js:102:23)
          at Object.next (/app/trading-platform/node_modules/tslib/tslib.es6.js:83:53)
          at fulfilled (/app/trading-platform/node_modules/tslib/tslib.es6.js:73:58)

      683 |         model.dispose();
      684 |       } catch (error) {
    > 685 |         console.error('Error during hyperparameter optimization:', error);
          |                 ^
      686 |       }
      687 |     }
      688 |

      at ModelPipeline.error [as optimizeHyperparameters] (app/domains/prediction/models/ml/ModelPipeline.ts:685:17)
      at Object.<anonymous> (app/domains/prediction/models/ml/__tests__/ModelPipeline.test.ts:245:41)

    console.log
      Testing params: { learningRate: 0.001, sequenceLength: 10, lstmUnits: 32 }

      at ModelPipeline.log [as optimizeHyperparameters] (app/domains/prediction/models/ml/ModelPipeline.ts:658:15)

    console.warn
      Orthogonal initializer is being called on a matrix with more than 2000 (4096) elements: Slowness may result.

      at tfjs-layers/src/initializers.ts:558:17
      at tfjs-core/src/engine.ts:469:20
      at Engine.Object.<anonymous>.Engine.scopedRun (tfjs-core/src/engine.ts:480:19)
      at Engine.Object.<anonymous>.Engine.tidy (tfjs-core/src/engine.ts:467:17)
      at Object.tidy (tfjs-core/src/globals.ts:192:17)
      at Orthogonal.tidy [as apply] (tfjs-layers/src/initializers.ts:543:12)
      at LSTMCell.Object.<anonymous>.Layer.addWeight (tfjs-layers/src/engine/topology.ts:1288:35)
      at LSTMCell.Object.<anonymous>.LSTMCell.build (tfjs-layers/src/layers/recurrent.ts:1706:33)
      at LSTM.Object.<anonymous>.RNN.build (tfjs-layers/src/layers/recurrent.ts:516:17)
      at tfjs-layers/src/engine/topology.ts:981:14
      at nameScope (tfjs-layers/src/common.ts:48:20)
      at LSTM.Object.<anonymous>.Layer.apply (tfjs-layers/src/engine/topology.ts:967:12)
      at LSTM.Object.<anonymous>.RNN.apply (tfjs-layers/src/layers/recurrent.ts:697:25)
      at Sequential.Object.<anonymous>.Sequential.add (tfjs-layers/src/models.ts:491:15)
      at ModelPipeline.add [as buildLSTMModel] (app/domains/prediction/models/ml/ModelPipeline.ts:245:11)
      at ModelPipeline.buildLSTMModel (app/domains/prediction/models/ml/ModelPipeline.ts:202:24)
      at ModelPipeline.trainLSTMModel [as optimizeHyperparameters] (app/domains/prediction/models/ml/ModelPipeline.ts:674:47)
      at Object.<anonymous> (app/domains/prediction/models/ml/__tests__/ModelPipeline.test.ts:245:41)

    console.error
      Error during hyperparameter optimization: TypeError: Cannot read properties of undefined (reading 'toFixed')
          at CustomCallback.valLoss [as epochEnd] (/app/trading-platform/app/domains/prediction/models/ml/ModelPipeline.ts:219:86)
          at CustomCallback.<anonymous> (/app/trading-platform/tfjs-layers/src/base_callbacks.ts:427:20)
          at step (/app/trading-platform/node_modules/tslib/tslib.es6.js:102:23)
          at Object.next (/app/trading-platform/node_modules/tslib/tslib.es6.js:83:53)
          at fulfilled (/app/trading-platform/node_modules/tslib/tslib.es6.js:73:58)

      683 |         model.dispose();
      684 |       } catch (error) {
    > 685 |         console.error('Error during hyperparameter optimization:', error);
          |                 ^
      686 |       }
      687 |     }
      688 |

      at ModelPipeline.error [as optimizeHyperparameters] (app/domains/prediction/models/ml/ModelPipeline.ts:685:17)
      at Object.<anonymous> (app/domains/prediction/models/ml/__tests__/ModelPipeline.test.ts:245:41)

    console.log
      Testing params: { learningRate: 0.01, sequenceLength: 5, lstmUnits: 16 }

      at ModelPipeline.log [as optimizeHyperparameters] (app/domains/prediction/models/ml/ModelPipeline.ts:658:15)

    console.error
      Error during hyperparameter optimization: TypeError: Cannot read properties of undefined (reading 'toFixed')
          at CustomCallback.valLoss [as epochEnd] (/app/trading-platform/app/domains/prediction/models/ml/ModelPipeline.ts:219:86)
          at CustomCallback.<anonymous> (/app/trading-platform/tfjs-layers/src/base_callbacks.ts:427:20)
          at step (/app/trading-platform/node_modules/tslib/tslib.es6.js:102:23)
          at Object.next (/app/trading-platform/node_modules/tslib/tslib.es6.js:83:53)
          at fulfilled (/app/trading-platform/node_modules/tslib/tslib.es6.js:73:58)

      683 |         model.dispose();
      684 |       } catch (error) {
    > 685 |         console.error('Error during hyperparameter optimization:', error);
          |                 ^
      686 |       }
      687 |     }
      688 |

      at ModelPipeline.error [as optimizeHyperparameters] (app/domains/prediction/models/ml/ModelPipeline.ts:685:17)
      at Object.<anonymous> (app/domains/prediction/models/ml/__tests__/ModelPipeline.test.ts:245:41)

    console.log
      Testing params: { learningRate: 0.01, sequenceLength: 5, lstmUnits: 32 }

      at ModelPipeline.log [as optimizeHyperparameters] (app/domains/prediction/models/ml/ModelPipeline.ts:658:15)

    console.warn
      Orthogonal initializer is being called on a matrix with more than 2000 (4096) elements: Slowness may result.

      at tfjs-layers/src/initializers.ts:558:17
      at tfjs-core/src/engine.ts:469:20
      at Engine.Object.<anonymous>.Engine.scopedRun (tfjs-core/src/engine.ts:480:19)
      at Engine.Object.<anonymous>.Engine.tidy (tfjs-core/src/engine.ts:467:17)
      at Object.tidy (tfjs-core/src/globals.ts:192:17)
      at Orthogonal.tidy [as apply] (tfjs-layers/src/initializers.ts:543:12)
      at LSTMCell.Object.<anonymous>.Layer.addWeight (tfjs-layers/src/engine/topology.ts:1288:35)
      at LSTMCell.Object.<anonymous>.LSTMCell.build (tfjs-layers/src/layers/recurrent.ts:1706:33)
      at LSTM.Object.<anonymous>.RNN.build (tfjs-layers/src/layers/recurrent.ts:516:17)
      at tfjs-layers/src/engine/topology.ts:981:14
      at nameScope (tfjs-layers/src/common.ts:48:20)
      at LSTM.Object.<anonymous>.Layer.apply (tfjs-layers/src/engine/topology.ts:967:12)
      at LSTM.Object.<anonymous>.RNN.apply (tfjs-layers/src/layers/recurrent.ts:697:25)
      at Sequential.Object.<anonymous>.Sequential.add (tfjs-layers/src/models.ts:491:15)
      at ModelPipeline.add [as buildLSTMModel] (app/domains/prediction/models/ml/ModelPipeline.ts:245:11)
      at ModelPipeline.buildLSTMModel (app/domains/prediction/models/ml/ModelPipeline.ts:202:24)
      at ModelPipeline.trainLSTMModel [as optimizeHyperparameters] (app/domains/prediction/models/ml/ModelPipeline.ts:674:47)
      at Object.<anonymous> (app/domains/prediction/models/ml/__tests__/ModelPipeline.test.ts:245:41)

    console.error
      Error during hyperparameter optimization: TypeError: Cannot read properties of undefined (reading 'toFixed')
          at CustomCallback.valLoss [as epochEnd] (/app/trading-platform/app/domains/prediction/models/ml/ModelPipeline.ts:219:86)
          at CustomCallback.<anonymous> (/app/trading-platform/tfjs-layers/src/base_callbacks.ts:427:20)
          at step (/app/trading-platform/node_modules/tslib/tslib.es6.js:102:23)
          at Object.next (/app/trading-platform/node_modules/tslib/tslib.es6.js:83:53)
          at fulfilled (/app/trading-platform/node_modules/tslib/tslib.es6.js:73:58)

      683 |         model.dispose();
      684 |       } catch (error) {
    > 685 |         console.error('Error during hyperparameter optimization:', error);
          |                 ^
      686 |       }
      687 |     }
      688 |

      at ModelPipeline.error [as optimizeHyperparameters] (app/domains/prediction/models/ml/ModelPipeline.ts:685:17)
      at Object.<anonymous> (app/domains/prediction/models/ml/__tests__/ModelPipeline.test.ts:245:41)

    console.log
      Testing params: { learningRate: 0.01, sequenceLength: 10, lstmUnits: 16 }

      at ModelPipeline.log [as optimizeHyperparameters] (app/domains/prediction/models/ml/ModelPipeline.ts:658:15)

    console.error
      Error during hyperparameter optimization: TypeError: Cannot read properties of undefined (reading 'toFixed')
          at CustomCallback.valLoss [as epochEnd] (/app/trading-platform/app/domains/prediction/models/ml/ModelPipeline.ts:219:86)
          at CustomCallback.<anonymous> (/app/trading-platform/tfjs-layers/src/base_callbacks.ts:427:20)
          at step (/app/trading-platform/node_modules/tslib/tslib.es6.js:102:23)
          at Object.next (/app/trading-platform/node_modules/tslib/tslib.es6.js:83:53)
          at fulfilled (/app/trading-platform/node_modules/tslib/tslib.es6.js:73:58)

      683 |         model.dispose();
      684 |       } catch (error) {
    > 685 |         console.error('Error during hyperparameter optimization:', error);
          |                 ^
      686 |       }
      687 |     }
      688 |

      at ModelPipeline.error [as optimizeHyperparameters] (app/domains/prediction/models/ml/ModelPipeline.ts:685:17)
      at Object.<anonymous> (app/domains/prediction/models/ml/__tests__/ModelPipeline.test.ts:245:41)

    console.log
      Testing params: { learningRate: 0.01, sequenceLength: 10, lstmUnits: 32 }

      at ModelPipeline.log [as optimizeHyperparameters] (app/domains/prediction/models/ml/ModelPipeline.ts:658:15)

    console.warn
      Orthogonal initializer is being called on a matrix with more than 2000 (4096) elements: Slowness may result.

      at tfjs-layers/src/initializers.ts:558:17
      at tfjs-core/src/engine.ts:469:20
      at Engine.Object.<anonymous>.Engine.scopedRun (tfjs-core/src/engine.ts:480:19)
      at Engine.Object.<anonymous>.Engine.tidy (tfjs-core/src/engine.ts:467:17)
      at Object.tidy (tfjs-core/src/globals.ts:192:17)
      at Orthogonal.tidy [as apply] (tfjs-layers/src/initializers.ts:543:12)
      at LSTMCell.Object.<anonymous>.Layer.addWeight (tfjs-layers/src/engine/topology.ts:1288:35)
      at LSTMCell.Object.<anonymous>.LSTMCell.build (tfjs-layers/src/layers/recurrent.ts:1706:33)
      at LSTM.Object.<anonymous>.RNN.build (tfjs-layers/src/layers/recurrent.ts:516:17)
      at tfjs-layers/src/engine/topology.ts:981:14
      at nameScope (tfjs-layers/src/common.ts:48:20)
      at LSTM.Object.<anonymous>.Layer.apply (tfjs-layers/src/engine/topology.ts:967:12)
      at LSTM.Object.<anonymous>.RNN.apply (tfjs-layers/src/layers/recurrent.ts:697:25)
      at Sequential.Object.<anonymous>.Sequential.add (tfjs-layers/src/models.ts:491:15)
      at ModelPipeline.add [as buildLSTMModel] (app/domains/prediction/models/ml/ModelPipeline.ts:245:11)
      at ModelPipeline.buildLSTMModel (app/domains/prediction/models/ml/ModelPipeline.ts:202:24)
      at ModelPipeline.trainLSTMModel [as optimizeHyperparameters] (app/domains/prediction/models/ml/ModelPipeline.ts:674:47)
      at Object.<anonymous> (app/domains/prediction/models/ml/__tests__/ModelPipeline.test.ts:245:41)

    console.error
      Error during hyperparameter optimization: TypeError: Cannot read properties of undefined (reading 'toFixed')
          at CustomCallback.valLoss [as epochEnd] (/app/trading-platform/app/domains/prediction/models/ml/ModelPipeline.ts:219:86)
          at CustomCallback.<anonymous> (/app/trading-platform/tfjs-layers/src/base_callbacks.ts:427:20)
          at step (/app/trading-platform/node_modules/tslib/tslib.es6.js:102:23)
          at Object.next (/app/trading-platform/node_modules/tslib/tslib.es6.js:83:53)
          at fulfilled (/app/trading-platform/node_modules/tslib/tslib.es6.js:73:58)

      683 |         model.dispose();
      684 |       } catch (error) {
    > 685 |         console.error('Error during hyperparameter optimization:', error);
          |                 ^
      686 |       }
      687 |     }
      688 |

      at ModelPipeline.error [as optimizeHyperparameters] (app/domains/prediction/models/ml/ModelPipeline.ts:685:17)
      at Object.<anonymous> (app/domains/prediction/models/ml/__tests__/ModelPipeline.test.ts:245:41)

  ● ModelPipeline › LSTM Model Training › should create and train an LSTM model

    TypeError: Cannot read properties of undefined (reading 'toFixed')

      217 |         onEpochEnd: (epoch, logs) => {
      218 |           console.log(
    > 219 |             `Epoch ${epoch + 1}: loss = ${logs?.loss.toFixed(4)}, val_loss = ${logs?.valLoss.toFixed(4)}`
          |                                                                                      ^
      220 |           );
      221 |         },
      222 |       },

      at CustomCallback.valLoss [as epochEnd] (app/domains/prediction/models/ml/ModelPipeline.ts:219:86)
      at CustomCallback.<anonymous> (tfjs-layers/src/base_callbacks.ts:427:20)
      at step (node_modules/tslib/tslib.es6.js:102:23)
      at Object.next (node_modules/tslib/tslib.es6.js:83:53)
      at fulfilled (node_modules/tslib/tslib.es6.js:73:58)

  ● ModelPipeline › LSTM Model Training › should handle different LSTM architectures

    TypeError: Cannot read properties of undefined (reading 'toFixed')

      217 |         onEpochEnd: (epoch, logs) => {
      218 |           console.log(
    > 219 |             `Epoch ${epoch + 1}: loss = ${logs?.loss.toFixed(4)}, val_loss = ${logs?.valLoss.toFixed(4)}`
          |                                                                                      ^
      220 |           );
      221 |         },
      222 |       },

      at CustomCallback.valLoss [as epochEnd] (app/domains/prediction/models/ml/ModelPipeline.ts:219:86)
      at CustomCallback.<anonymous> (tfjs-layers/src/base_callbacks.ts:427:20)
      at step (node_modules/tslib/tslib.es6.js:102:23)
      at Object.next (node_modules/tslib/tslib.es6.js:83:53)
      at fulfilled (node_modules/tslib/tslib.es6.js:73:58)

  ● ModelPipeline › Transformer Model Training › should create and train a Transformer model

    TypeError: Cannot read properties of undefined (reading 'toFixed')

      316 |         onEpochEnd: (epoch, logs) => {
      317 |           console.log(
    > 318 |             `Epoch ${epoch + 1}: loss = ${logs?.loss.toFixed(4)}, val_loss = ${logs?.valLoss.toFixed(4)}`
          |                                                                                      ^
      319 |           );
      320 |         },
      321 |       },

      at CustomCallback.valLoss [as epochEnd] (app/domains/prediction/models/ml/ModelPipeline.ts:318:86)
      at CustomCallback.<anonymous> (tfjs-layers/src/base_callbacks.ts:427:20)
      at step (node_modules/tslib/tslib.es6.js:102:23)
      at Object.next (node_modules/tslib/tslib.es6.js:83:53)
      at fulfilled (node_modules/tslib/tslib.es6.js:73:58)

  ● ModelPipeline › Model Prediction › should make predictions with uncertainty

    TypeError: Cannot read properties of undefined (reading 'toFixed')

      217 |         onEpochEnd: (epoch, logs) => {
      218 |           console.log(
    > 219 |             `Epoch ${epoch + 1}: loss = ${logs?.loss.toFixed(4)}, val_loss = ${logs?.valLoss.toFixed(4)}`
          |                                                                                      ^
      220 |           );
      221 |         },
      222 |       },

      at CustomCallback.valLoss [as epochEnd] (app/domains/prediction/models/ml/ModelPipeline.ts:219:86)
      at CustomCallback.<anonymous> (tfjs-layers/src/base_callbacks.ts:427:20)
      at step (node_modules/tslib/tslib.es6.js:102:23)
      at Object.next (node_modules/tslib/tslib.es6.js:83:53)
      at fulfilled (node_modules/tslib/tslib.es6.js:73:58)

  ● ModelPipeline › Model Save and Load › should save and load a model

    TypeError: Cannot read properties of undefined (reading 'toFixed')

      217 |         onEpochEnd: (epoch, logs) => {
      218 |           console.log(
    > 219 |             `Epoch ${epoch + 1}: loss = ${logs?.loss.toFixed(4)}, val_loss = ${logs?.valLoss.toFixed(4)}`
          |                                                                                      ^
      220 |           );
      221 |         },
      222 |       },

      at CustomCallback.valLoss [as epochEnd] (app/domains/prediction/models/ml/ModelPipeline.ts:219:86)
      at CustomCallback.<anonymous> (tfjs-layers/src/base_callbacks.ts:427:20)
      at step (node_modules/tslib/tslib.es6.js:102:23)
      at Object.next (node_modules/tslib/tslib.es6.js:83:53)
      at fulfilled (node_modules/tslib/tslib.es6.js:73:58)

  ● ModelPipeline › Model Evaluation › should evaluate model performance

    TypeError: Cannot read properties of undefined (reading 'toFixed')

      217 |         onEpochEnd: (epoch, logs) => {
      218 |           console.log(
    > 219 |             `Epoch ${epoch + 1}: loss = ${logs?.loss.toFixed(4)}, val_loss = ${logs?.valLoss.toFixed(4)}`
          |                                                                                      ^
      220 |           );
      221 |         },
      222 |       },

      at CustomCallback.valLoss [as epochEnd] (app/domains/prediction/models/ml/ModelPipeline.ts:219:86)
      at CustomCallback.<anonymous> (tfjs-layers/src/base_callbacks.ts:427:20)
      at step (node_modules/tslib/tslib.es6.js:102:23)
      at Object.next (node_modules/tslib/tslib.es6.js:83:53)
      at fulfilled (node_modules/tslib/tslib.es6.js:73:58)

  ● ModelPipeline › Hyperparameter Optimization › should optimize hyperparameters

    expect(received).toBeDefined()

    Received: undefined

      251 |       expect(bestScore).toBeDefined();
      252 |       expect(bestScore).toBeGreaterThanOrEqual(0);
    > 253 |       expect(bestParams.learningRate).toBeDefined();
          |                                       ^
      254 |     }, 60000);
      255 |   });
      256 |

      at Object.toBeDefined (app/domains/prediction/models/ml/__tests__/ModelPipeline.test.ts:253:39)

  ● ModelPipeline › Model Summary › should generate model summary

    TypeError: Cannot read properties of undefined (reading 'toFixed')

      217 |         onEpochEnd: (epoch, logs) => {
      218 |           console.log(
    > 219 |             `Epoch ${epoch + 1}: loss = ${logs?.loss.toFixed(4)}, val_loss = ${logs?.valLoss.toFixed(4)}`
          |                                                                                      ^
      220 |           );
      221 |         },
      222 |       },

      at CustomCallback.valLoss [as epochEnd] (app/domains/prediction/models/ml/ModelPipeline.ts:219:86)
      at CustomCallback.<anonymous> (tfjs-layers/src/base_callbacks.ts:427:20)
      at step (node_modules/tslib/tslib.es6.js:102:23)
      at Object.next (node_modules/tslib/tslib.es6.js:83:53)
      at fulfilled (node_modules/tslib/tslib.es6.js:73:58)

  ● ModelPipeline › Memory Management › should clean up tensors properly

    TypeError: Cannot read properties of undefined (reading 'toFixed')

      217 |         onEpochEnd: (epoch, logs) => {
      218 |           console.log(
    > 219 |             `Epoch ${epoch + 1}: loss = ${logs?.loss.toFixed(4)}, val_loss = ${logs?.valLoss.toFixed(4)}`
          |                                                                                      ^
      220 |           );
      221 |         },
      222 |       },

      at CustomCallback.valLoss [as epochEnd] (app/domains/prediction/models/ml/ModelPipeline.ts:219:86)
      at CustomCallback.<anonymous> (tfjs-layers/src/base_callbacks.ts:427:20)
      at step (node_modules/tslib/tslib.es6.js:102:23)
      at Object.next (node_modules/tslib/tslib.es6.js:83:53)
      at fulfilled (node_modules/tslib/tslib.es6.js:73:58)

  ● ModelPipeline › Edge Cases › should handle insufficient data gracefully

    TypeError: Cannot read properties of undefined (reading 'toFixed')

      217 |         onEpochEnd: (epoch, logs) => {
      218 |           console.log(
    > 219 |             `Epoch ${epoch + 1}: loss = ${logs?.loss.toFixed(4)}, val_loss = ${logs?.valLoss.toFixed(4)}`
          |                                                                                      ^
      220 |           );
      221 |         },
      222 |       },

      at CustomCallback.valLoss [as epochEnd] (app/domains/prediction/models/ml/ModelPipeline.ts:219:86)
      at CustomCallback.<anonymous> (tfjs-layers/src/base_callbacks.ts:427:20)
      at step (node_modules/tslib/tslib.es6.js:102:23)
      at Object.next (node_modules/tslib/tslib.es6.js:83:53)
      at fulfilled (node_modules/tslib/tslib.es6.js:73:58)

PASS app/lib/aiAnalytics/__tests__/ModelValidation.test.ts
  ● Console

    console.warn
      [2026-02-08T08:48:15.338Z] [WARN]  Too many parameter combinations (1000). Sampling 100 combinations.

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at ModelValidation.warn [as generateParamCombinations] (app/lib/aiAnalytics/ModelValidation.ts:430:14)
      at ModelValidation.generateParamCombinations [as optimizeParameters] (app/lib/aiAnalytics/ModelValidation.ts:251:36)
      at Object.optimizeParameters (app/lib/aiAnalytics/__tests__/ModelValidation.test.ts:234:38)

PASS app/lib/execution/__tests__/BrokerConnectors.test.ts
PASS app/components/__tests__/NotificationCenter.test.tsx
PASS app/lib/__tests__/integration.test.ts
  ● Console

    console.info
      [2026-02-08T08:48:16.882Z] [INFO]  [analyzeStock] start { symbol: '7203', market: 'japan', dataLength: 50, context: 'none' }

      at Logger.info (app/core/logger.ts:76:15)

    console.info
      [2026-02-08T08:48:16.891Z] [INFO]  [analyzeStock] windowData length: 50

      at Logger.info (app/core/logger.ts:76:15)

    console.info
      [2026-02-08T08:48:16.898Z] [INFO]  [analyzeStock] start { symbol: '7203', market: 'japan', dataLength: 50, context: 'none' }

      at Logger.info (app/core/logger.ts:76:15)

    console.info
      [2026-02-08T08:48:16.899Z] [INFO]  [analyzeStock] windowData length: 50

      at Logger.info (app/core/logger.ts:76:15)

    console.info
      [2026-02-08T08:48:16.901Z] [INFO]  [analyzeStock] start { symbol: '7203', market: 'japan', dataLength: 50, context: 'none' }

      at Logger.info (app/core/logger.ts:76:15)

    console.info
      [2026-02-08T08:48:16.901Z] [INFO]  [analyzeStock] windowData length: 50

      at Logger.info (app/core/logger.ts:76:15)

    console.info
      [2026-02-08T08:48:16.907Z] [INFO]  [analyzeStock] start { symbol: '7203', market: 'japan', dataLength: 50, context: 'none' }

      at Logger.info (app/core/logger.ts:76:15)

    console.info
      [2026-02-08T08:48:16.907Z] [INFO]  [analyzeStock] windowData length: 50

      at Logger.info (app/core/logger.ts:76:15)

    console.info
      [2026-02-08T08:48:16.909Z] [INFO]  [analyzeStock] start { symbol: '7203', market: 'japan', dataLength: 50, context: 'none' }

      at Logger.info (app/core/logger.ts:76:15)

    console.info
      [2026-02-08T08:48:16.914Z] [INFO]  [analyzeStock] windowData length: 50

      at Logger.info (app/core/logger.ts:76:15)

    console.info
      [2026-02-08T08:48:16.915Z] [INFO]  [analyzeStock] start { symbol: '7203', market: 'japan', dataLength: 50, context: 'none' }

      at Logger.info (app/core/logger.ts:76:15)

    console.info
      [2026-02-08T08:48:16.916Z] [INFO]  [analyzeStock] windowData length: 50

      at Logger.info (app/core/logger.ts:76:15)

    console.info
      [2026-02-08T08:48:16.921Z] [INFO]  [analyzeStock] start { symbol: '7203', market: 'japan', dataLength: 50, context: 'none' }

      at Logger.info (app/core/logger.ts:76:15)

    console.info
      [2026-02-08T08:48:16.922Z] [INFO]  [analyzeStock] windowData length: 50

      at Logger.info (app/core/logger.ts:76:15)

    console.info
      [2026-02-08T08:48:16.925Z] [INFO]  [analyzeStock] start { symbol: '7203', market: 'japan', dataLength: 50, context: 'none' }

      at Logger.info (app/core/logger.ts:76:15)

    console.info
      [2026-02-08T08:48:16.925Z] [INFO]  [analyzeStock] windowData length: 50

      at Logger.info (app/core/logger.ts:76:15)

    console.info
      [2026-02-08T08:48:16.931Z] [INFO]  [analyzeStock] start { symbol: '7203', market: 'japan', dataLength: 15, context: 'none' }

      at Logger.info (app/core/logger.ts:76:15)

    console.info
      [2026-02-08T08:48:16.931Z] [INFO]  [analyzeStock] windowData length: 15

      at Logger.info (app/core/logger.ts:76:15)

    console.info
      [2026-02-08T08:48:16.933Z] [INFO]  [analyzeStock] start { symbol: '7203', market: 'japan', dataLength: 50, context: 'none' }

      at Logger.info (app/core/logger.ts:76:15)

    console.info
      [2026-02-08T08:48:16.933Z] [INFO]  [analyzeStock] windowData length: 50

      at Logger.info (app/core/logger.ts:76:15)

    console.info
      [2026-02-08T08:48:16.938Z] [INFO]  [analyzeStock] start { symbol: '7203', market: 'japan', dataLength: 50, context: 'none' }

      at Logger.info (app/core/logger.ts:76:15)

    console.info
      [2026-02-08T08:48:16.938Z] [INFO]  [analyzeStock] windowData length: 50

      at Logger.info (app/core/logger.ts:76:15)

    console.info
      [2026-02-08T08:48:16.940Z] [INFO]  [analyzeStock] start { symbol: '7203', market: 'japan', dataLength: 50, context: 'none' }

      at Logger.info (app/core/logger.ts:76:15)

    console.info
      [2026-02-08T08:48:16.940Z] [INFO]  [analyzeStock] windowData length: 50

      at Logger.info (app/core/logger.ts:76:15)

    console.info
      [2026-02-08T08:48:16.974Z] [INFO]  [analyzeStock] start { symbol: '7203', market: 'japan', dataLength: 0, context: 'none' }

      at Logger.info (app/core/logger.ts:76:15)

    console.info
      [2026-02-08T08:48:16.975Z] [INFO]  [analyzeStock] windowData length: 0

      at Logger.info (app/core/logger.ts:76:15)

    console.info
      [2026-02-08T08:48:16.976Z] [INFO]  [analyzeStock] start { symbol: '7203', market: 'japan', dataLength: 20, context: 'none' }

      at Logger.info (app/core/logger.ts:76:15)

    console.info
      [2026-02-08T08:48:16.977Z] [INFO]  [analyzeStock] windowData length: 20

      at Logger.info (app/core/logger.ts:76:15)

    console.info
      [2026-02-08T08:48:16.991Z] [INFO]  [analyzeStock] start {
        symbol: '7203',
        market: 'japan',
        dataLength: 50,
        context: { endIndex: undefined, startIndex: undefined }
      }

      at Logger.info (app/core/logger.ts:76:15)

    console.info
      [2026-02-08T08:48:16.991Z] [INFO]  [analyzeStock] windowData length: 50

      at Logger.info (app/core/logger.ts:76:15)

    console.info
      [2026-02-08T08:48:16.993Z] [INFO]  [analyzeStock] start { symbol: '7203', market: 'japan', dataLength: 50, context: 'none' }

      at Logger.info (app/core/logger.ts:76:15)

    console.info
      [2026-02-08T08:48:17.002Z] [INFO]  [analyzeStock] windowData length: 50

      at Logger.info (app/core/logger.ts:76:15)

    console.info
      [2026-02-08T08:48:17.002Z] [INFO]  [analyzeStock] start { symbol: '7203', market: 'japan', dataLength: 50, context: 'none' }

      at Logger.info (app/core/logger.ts:76:15)

    console.info
      [2026-02-08T08:48:17.003Z] [INFO]  [analyzeStock] windowData length: 50

      at Logger.info (app/core/logger.ts:76:15)

PASS app/lib/utils/__tests__/performanceMonitor.test.ts
PASS app/lib/nlp/__tests__/SocialMediaCollector.test.ts
PASS app/domains/market-data/integration/__tests__/MultiSourceDataAggregator.test.ts (5.18 s)
  ● Console

    console.log
      [Aggregator] Registered source: Source A (priority: 1)

      at MultiSourceDataAggregator.log [as registerSource] (app/domains/market-data/integration/MultiSourceDataAggregator.ts:85:13)

    console.log
      [Aggregator] Registered source: Source A (priority: 1)

      at MultiSourceDataAggregator.log [as registerSource] (app/domains/market-data/integration/MultiSourceDataAggregator.ts:85:13)

    console.log
      [Aggregator] Registered source: Source B (priority: 2)

      at MultiSourceDataAggregator.log [as registerSource] (app/domains/market-data/integration/MultiSourceDataAggregator.ts:85:13)

    console.log
      [Aggregator] Registered source: Source C (priority: 3)

      at MultiSourceDataAggregator.log [as registerSource] (app/domains/market-data/integration/MultiSourceDataAggregator.ts:85:13)

    console.log
      [Aggregator] Registered source: Source C (priority: 3)

      at MultiSourceDataAggregator.log [as registerSource] (app/domains/market-data/integration/MultiSourceDataAggregator.ts:85:13)

    console.log
      [Aggregator] Registered source: Source A (priority: 1)

      at MultiSourceDataAggregator.log [as registerSource] (app/domains/market-data/integration/MultiSourceDataAggregator.ts:85:13)

    console.log
      [Aggregator] Registered source: Source B (priority: 2)

      at MultiSourceDataAggregator.log [as registerSource] (app/domains/market-data/integration/MultiSourceDataAggregator.ts:85:13)

    console.log
      [Aggregator] Registered source: Source A (priority: 1)

      at MultiSourceDataAggregator.log [as registerSource] (app/domains/market-data/integration/MultiSourceDataAggregator.ts:85:13)

    console.log
      [Aggregator] Registered source: Source B (priority: 2)

      at MultiSourceDataAggregator.log [as registerSource] (app/domains/market-data/integration/MultiSourceDataAggregator.ts:85:13)

    console.log
      [Aggregator] Unregistered source: A

      at MultiSourceDataAggregator.log [as unregisterSource] (app/domains/market-data/integration/MultiSourceDataAggregator.ts:93:13)

    console.log
      [Aggregator] Registered source: Source A (priority: 1)

      at MultiSourceDataAggregator.log [as registerSource] (app/domains/market-data/integration/MultiSourceDataAggregator.ts:85:13)

    console.log
      [Aggregator] Registered source: Source B (priority: 2)

      at MultiSourceDataAggregator.log [as registerSource] (app/domains/market-data/integration/MultiSourceDataAggregator.ts:85:13)

    console.log
      [Aggregator] Registered source: Source C (priority: 3)

      at MultiSourceDataAggregator.log [as registerSource] (app/domains/market-data/integration/MultiSourceDataAggregator.ts:85:13)

    console.log
      [Aggregator] Registered source: Source A (priority: 1)

      at MultiSourceDataAggregator.log [as registerSource] (app/domains/market-data/integration/MultiSourceDataAggregator.ts:85:13)

    console.log
      [Aggregator] Registered source: Source B (priority: 2)

      at MultiSourceDataAggregator.log [as registerSource] (app/domains/market-data/integration/MultiSourceDataAggregator.ts:85:13)

    console.log
      [Aggregator] Registered source: Source A (priority: 1)

      at MultiSourceDataAggregator.log [as registerSource] (app/domains/market-data/integration/MultiSourceDataAggregator.ts:85:13)

    console.log
      [Aggregator] Registered source: Source A (priority: 1)

      at MultiSourceDataAggregator.log [as registerSource] (app/domains/market-data/integration/MultiSourceDataAggregator.ts:85:13)

    console.log
      [Aggregator] Registered source: Source B (priority: 2)

      at MultiSourceDataAggregator.log [as registerSource] (app/domains/market-data/integration/MultiSourceDataAggregator.ts:85:13)

    console.log
      [Aggregator] Registered source: Source A (priority: 1)

      at MultiSourceDataAggregator.log [as registerSource] (app/domains/market-data/integration/MultiSourceDataAggregator.ts:85:13)

    console.log
      [Aggregator] Registered source: Source B (priority: 2)

      at MultiSourceDataAggregator.log [as registerSource] (app/domains/market-data/integration/MultiSourceDataAggregator.ts:85:13)

    console.log
      [Aggregator] Registered source: Source A (priority: 1)

      at MultiSourceDataAggregator.log [as registerSource] (app/domains/market-data/integration/MultiSourceDataAggregator.ts:85:13)

    console.log
      [Aggregator] Registered source: Source B (priority: 2)

      at MultiSourceDataAggregator.log [as registerSource] (app/domains/market-data/integration/MultiSourceDataAggregator.ts:85:13)

    console.log
      [Aggregator] Registered source: Source A (priority: 1)

      at MultiSourceDataAggregator.log [as registerSource] (app/domains/market-data/integration/MultiSourceDataAggregator.ts:85:13)

    console.log
      [Aggregator] Registered source: Source A (priority: 1)

      at MultiSourceDataAggregator.log [as registerSource] (app/domains/market-data/integration/MultiSourceDataAggregator.ts:85:13)

    console.log
      [Aggregator] Registered source: Source A (priority: 1)

      at MultiSourceDataAggregator.log [as registerSource] (app/domains/market-data/integration/MultiSourceDataAggregator.ts:85:13)

    console.log
      [Aggregator] Registered source: Source A (priority: 1)

      at MultiSourceDataAggregator.log [as registerSource] (app/domains/market-data/integration/MultiSourceDataAggregator.ts:85:13)

    console.log
      [Aggregator] Registered source: Source B (priority: 2)

      at MultiSourceDataAggregator.log [as registerSource] (app/domains/market-data/integration/MultiSourceDataAggregator.ts:85:13)

    console.log
      [Aggregator] Registered source: Source A (priority: 1)

      at MultiSourceDataAggregator.log [as registerSource] (app/domains/market-data/integration/MultiSourceDataAggregator.ts:85:13)

    console.log
      [Aggregator] Registered source: Source B (priority: 2)

      at MultiSourceDataAggregator.log [as registerSource] (app/domains/market-data/integration/MultiSourceDataAggregator.ts:85:13)

    console.log
      [Aggregator] Registered source: Source A (priority: 1)

      at MultiSourceDataAggregator.log [as registerSource] (app/domains/market-data/integration/MultiSourceDataAggregator.ts:85:13)

    console.log
      [Aggregator] Registered source: Source B (priority: 2)

      at MultiSourceDataAggregator.log [as registerSource] (app/domains/market-data/integration/MultiSourceDataAggregator.ts:85:13)

    console.log
      [Aggregator] Registered source: Source A (priority: 1)

      at MultiSourceDataAggregator.log [as registerSource] (app/domains/market-data/integration/MultiSourceDataAggregator.ts:85:13)

    console.log
      [Aggregator] Registered source: Source B (priority: 2)

      at MultiSourceDataAggregator.log [as registerSource] (app/domains/market-data/integration/MultiSourceDataAggregator.ts:85:13)

    console.log
      [Aggregator] Registered source: Source A (priority: 1)

      at MultiSourceDataAggregator.log [as registerSource] (app/domains/market-data/integration/MultiSourceDataAggregator.ts:85:13)

PASS app/lib/risk/__tests__/PsychologyMonitor.test.ts
  ● Console

    console.warn
      [2026-02-08T08:48:23.192Z] [WARN] [PsychologyMonitor] Psychology Alert [fomo]: 短時間に複数の取引が検出されました。FOMO（取り残される恐怖）の可能性があります。 {
        severity: 'high',
        recommendation: '一度立ち止まり、取引計画を確認してください。感情ではなく戦略に基づいて取引してください。',
        timestamp: 2026-02-08T08:48:23.192Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:33:27)

    console.warn
      [2026-02-08T08:48:23.201Z] [WARN] [PsychologyMonitor] Psychology Alert [fomo]: 短時間に複数の取引が検出されました。FOMO（取り残される恐怖）の可能性があります。 {
        severity: 'high',
        recommendation: '一度立ち止まり、取引計画を確認してください。感情ではなく戦略に基づいて取引してください。',
        timestamp: 2026-02-08T08:48:23.201Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:33:27)

    console.warn
      [2026-02-08T08:48:23.206Z] [WARN] [PsychologyMonitor] Psychology Alert [fomo]: 短時間に複数の取引が検出されました。FOMO（取り残される恐怖）の可能性があります。 {
        severity: 'high',
        recommendation: '一度立ち止まり、取引計画を確認してください。感情ではなく戦略に基づいて取引してください。',
        timestamp: 2026-02-08T08:48:23.206Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:33:27)

    console.warn
      [2026-02-08T08:48:23.210Z] [WARN] [PsychologyMonitor] Psychology Alert [fomo]: 短時間に複数の取引が検出されました。FOMO（取り残される恐怖）の可能性があります。 {
        severity: 'high',
        recommendation: '一度立ち止まり、取引計画を確認してください。感情ではなく戦略に基づいて取引してください。',
        timestamp: 2026-02-08T08:48:23.210Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:33:27)

    console.warn
      [2026-02-08T08:48:23.212Z] [WARN] [PsychologyMonitor] Psychology Alert [revenge_trading]: 連続損失が3回続いています。 {
        severity: 'medium',
        recommendation: '一時的に取引を停止し、戦略を見直してください。',
        timestamp: 2026-02-08T08:48:23.211Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.212Z] [WARN] [PsychologyMonitor] Psychology Alert [fear]: 感情的な取引パターンが検出されました。スコア: 75 {
        severity: 'medium',
        recommendation: '冷静さを取り戻し、トレーディングプランに従ってください。',
        timestamp: 2026-02-08T08:48:23.211Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.212Z] [WARN] [PsychologyMonitor] Psychology Alert [fomo]: 短時間に複数の取引が検出されました。FOMO（取り残される恐怖）の可能性があります。 {
        severity: 'high',
        recommendation: '一度立ち止まり、取引計画を確認してください。感情ではなく戦略に基づいて取引してください。',
        timestamp: 2026-02-08T08:48:23.211Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.213Z] [WARN] [PsychologyMonitor] Psychology Alert [loss_aversion]: 連続損失後に同じシンボルを買い増ししています。損失嫌悪バイアスの可能性があります。 {
        severity: 'high',
        recommendation: '損失を取り戻そうとする心理に注意してください。平均化戦略は慎重に行い、リスク管理を優先してください。',
        timestamp: 2026-02-08T08:48:23.211Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.213Z] [WARN] [PsychologyMonitor] Psychology Alert [revenge_trading]: 連続損失が4回続いています。 {
        severity: 'medium',
        recommendation: '一時的に取引を停止し、戦略を見直してください。',
        timestamp: 2026-02-08T08:48:23.213Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.218Z] [WARN] [PsychologyMonitor] Psychology Alert [fear]: 感情的な取引パターンが検出されました。スコア: 90 {
        severity: 'high',
        recommendation: '冷静さを取り戻し、トレーディングプランに従ってください。',
        timestamp: 2026-02-08T08:48:23.213Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.218Z] [WARN] [PsychologyMonitor] Psychology Alert [fomo]: 短時間に複数の取引が検出されました。FOMO（取り残される恐怖）の可能性があります。 {
        severity: 'high',
        recommendation: '一度立ち止まり、取引計画を確認してください。感情ではなく戦略に基づいて取引してください。',
        timestamp: 2026-02-08T08:48:23.213Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.218Z] [WARN] [PsychologyMonitor] Psychology Alert [loss_aversion]: 連続損失後に同じシンボルを買い増ししています。損失嫌悪バイアスの可能性があります。 {
        severity: 'high',
        recommendation: '損失を取り戻そうとする心理に注意してください。平均化戦略は慎重に行い、リスク管理を優先してください。',
        timestamp: 2026-02-08T08:48:23.213Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.219Z] [WARN] [PsychologyMonitor] Psychology Alert [revenge_trading]: 連続損失が5回続いています。 {
        severity: 'high',
        recommendation: '一時的に取引を停止し、戦略を見直してください。',
        timestamp: 2026-02-08T08:48:23.219Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.219Z] [WARN] [PsychologyMonitor] Psychology Alert [fear]: 感情的な取引パターンが検出されました。スコア: 100 {
        severity: 'high',
        recommendation: '冷静さを取り戻し、トレーディングプランに従ってください。',
        timestamp: 2026-02-08T08:48:23.219Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.219Z] [WARN] [PsychologyMonitor] Psychology Alert [fomo]: 短時間に複数の取引が検出されました。FOMO（取り残される恐怖）の可能性があります。 {
        severity: 'high',
        recommendation: '一度立ち止まり、取引計画を確認してください。感情ではなく戦略に基づいて取引してください。',
        timestamp: 2026-02-08T08:48:23.219Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.220Z] [WARN] [PsychologyMonitor] Psychology Alert [loss_aversion]: 連続損失後に同じシンボルを買い増ししています。損失嫌悪バイアスの可能性があります。 {
        severity: 'high',
        recommendation: '損失を取り戻そうとする心理に注意してください。平均化戦略は慎重に行い、リスク管理を優先してください。',
        timestamp: 2026-02-08T08:48:23.219Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.220Z] [WARN] [PsychologyMonitor] Psychology Alert [revenge_trading]: 連続損失が6回続いています。 {
        severity: 'high',
        recommendation: '一時的に取引を停止し、戦略を見直してください。',
        timestamp: 2026-02-08T08:48:23.220Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.220Z] [WARN] [PsychologyMonitor] Psychology Alert [fear]: 感情的な取引パターンが検出されました。スコア: 100 {
        severity: 'high',
        recommendation: '冷静さを取り戻し、トレーディングプランに従ってください。',
        timestamp: 2026-02-08T08:48:23.220Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.226Z] [WARN] [PsychologyMonitor] Psychology Alert [fomo]: 短時間に複数の取引が検出されました。FOMO（取り残される恐怖）の可能性があります。 {
        severity: 'high',
        recommendation: '一度立ち止まり、取引計画を確認してください。感情ではなく戦略に基づいて取引してください。',
        timestamp: 2026-02-08T08:48:23.220Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.226Z] [WARN] [PsychologyMonitor] Psychology Alert [loss_aversion]: 連続損失後に同じシンボルを買い増ししています。損失嫌悪バイアスの可能性があります。 {
        severity: 'high',
        recommendation: '損失を取り戻そうとする心理に注意してください。平均化戦略は慎重に行い、リスク管理を優先してください。',
        timestamp: 2026-02-08T08:48:23.220Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.226Z] [WARN] [PsychologyMonitor] Psychology Alert [revenge_trading]: 連続損失が7回続いています。 {
        severity: 'high',
        recommendation: '一時的に取引を停止し、戦略を見直してください。',
        timestamp: 2026-02-08T08:48:23.226Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.227Z] [WARN] [PsychologyMonitor] Psychology Alert [fear]: 感情的な取引パターンが検出されました。スコア: 100 {
        severity: 'high',
        recommendation: '冷静さを取り戻し、トレーディングプランに従ってください。',
        timestamp: 2026-02-08T08:48:23.226Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.227Z] [WARN] [PsychologyMonitor] Psychology Alert [fomo]: 短時間に複数の取引が検出されました。FOMO（取り残される恐怖）の可能性があります。 {
        severity: 'high',
        recommendation: '一度立ち止まり、取引計画を確認してください。感情ではなく戦略に基づいて取引してください。',
        timestamp: 2026-02-08T08:48:23.226Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.227Z] [WARN] [PsychologyMonitor] Psychology Alert [loss_aversion]: 連続損失後に同じシンボルを買い増ししています。損失嫌悪バイアスの可能性があります。 {
        severity: 'high',
        recommendation: '損失を取り戻そうとする心理に注意してください。平均化戦略は慎重に行い、リスク管理を優先してください。',
        timestamp: 2026-02-08T08:48:23.226Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.228Z] [WARN] [PsychologyMonitor] Psychology Alert [revenge_trading]: 連続損失が8回続いています。 {
        severity: 'high',
        recommendation: '一時的に取引を停止し、戦略を見直してください。',
        timestamp: 2026-02-08T08:48:23.228Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.231Z] [WARN] [PsychologyMonitor] Psychology Alert [fear]: 感情的な取引パターンが検出されました。スコア: 100 {
        severity: 'high',
        recommendation: '冷静さを取り戻し、トレーディングプランに従ってください。',
        timestamp: 2026-02-08T08:48:23.228Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.231Z] [WARN] [PsychologyMonitor] Psychology Alert [fomo]: 短時間に複数の取引が検出されました。FOMO（取り残される恐怖）の可能性があります。 {
        severity: 'high',
        recommendation: '一度立ち止まり、取引計画を確認してください。感情ではなく戦略に基づいて取引してください。',
        timestamp: 2026-02-08T08:48:23.228Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.232Z] [WARN] [PsychologyMonitor] Psychology Alert [loss_aversion]: 連続損失後に同じシンボルを買い増ししています。損失嫌悪バイアスの可能性があります。 {
        severity: 'high',
        recommendation: '損失を取り戻そうとする心理に注意してください。平均化戦略は慎重に行い、リスク管理を優先してください。',
        timestamp: 2026-02-08T08:48:23.228Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.232Z] [WARN] [PsychologyMonitor] Psychology Alert [revenge_trading]: 連続損失が9回続いています。 {
        severity: 'high',
        recommendation: '一時的に取引を停止し、戦略を見直してください。',
        timestamp: 2026-02-08T08:48:23.232Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.238Z] [WARN] [PsychologyMonitor] Psychology Alert [fear]: 感情的な取引パターンが検出されました。スコア: 100 {
        severity: 'high',
        recommendation: '冷静さを取り戻し、トレーディングプランに従ってください。',
        timestamp: 2026-02-08T08:48:23.232Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.238Z] [WARN] [PsychologyMonitor] Psychology Alert [fomo]: 短時間に複数の取引が検出されました。FOMO（取り残される恐怖）の可能性があります。 {
        severity: 'high',
        recommendation: '一度立ち止まり、取引計画を確認してください。感情ではなく戦略に基づいて取引してください。',
        timestamp: 2026-02-08T08:48:23.232Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.238Z] [WARN] [PsychologyMonitor] Psychology Alert [loss_aversion]: 連続損失後に同じシンボルを買い増ししています。損失嫌悪バイアスの可能性があります。 {
        severity: 'high',
        recommendation: '損失を取り戻そうとする心理に注意してください。平均化戦略は慎重に行い、リスク管理を優先してください。',
        timestamp: 2026-02-08T08:48:23.232Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.239Z] [WARN] [PsychologyMonitor] Psychology Alert [revenge_trading]: 連続損失が10回続いています。 {
        severity: 'high',
        recommendation: '一時的に取引を停止し、戦略を見直してください。',
        timestamp: 2026-02-08T08:48:23.239Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.239Z] [WARN] [PsychologyMonitor] Psychology Alert [fear]: 感情的な取引パターンが検出されました。スコア: 100 {
        severity: 'high',
        recommendation: '冷静さを取り戻し、トレーディングプランに従ってください。',
        timestamp: 2026-02-08T08:48:23.239Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.239Z] [WARN] [PsychologyMonitor] Psychology Alert [fomo]: 短時間に複数の取引が検出されました。FOMO（取り残される恐怖）の可能性があります。 {
        severity: 'high',
        recommendation: '一度立ち止まり、取引計画を確認してください。感情ではなく戦略に基づいて取引してください。',
        timestamp: 2026-02-08T08:48:23.239Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.240Z] [WARN] [PsychologyMonitor] Psychology Alert [loss_aversion]: 連続損失後に同じシンボルを買い増ししています。損失嫌悪バイアスの可能性があります。 {
        severity: 'high',
        recommendation: '損失を取り戻そうとする心理に注意してください。平均化戦略は慎重に行い、リスク管理を優先してください。',
        timestamp: 2026-02-08T08:48:23.239Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.240Z] [WARN] [PsychologyMonitor] Psychology Alert [revenge_trading]: 連続損失が11回続いています。 {
        severity: 'high',
        recommendation: '一時的に取引を停止し、戦略を見直してください。',
        timestamp: 2026-02-08T08:48:23.240Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.240Z] [WARN] [PsychologyMonitor] Psychology Alert [fear]: 感情的な取引パターンが検出されました。スコア: 100 {
        severity: 'high',
        recommendation: '冷静さを取り戻し、トレーディングプランに従ってください。',
        timestamp: 2026-02-08T08:48:23.240Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.241Z] [WARN] [PsychologyMonitor] Psychology Alert [fomo]: 短時間に複数の取引が検出されました。FOMO（取り残される恐怖）の可能性があります。 {
        severity: 'high',
        recommendation: '一度立ち止まり、取引計画を確認してください。感情ではなく戦略に基づいて取引してください。',
        timestamp: 2026-02-08T08:48:23.240Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.241Z] [WARN] [PsychologyMonitor] Psychology Alert [loss_aversion]: 連続損失後に同じシンボルを買い増ししています。損失嫌悪バイアスの可能性があります。 {
        severity: 'high',
        recommendation: '損失を取り戻そうとする心理に注意してください。平均化戦略は慎重に行い、リスク管理を優先してください。',
        timestamp: 2026-02-08T08:48:23.240Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.245Z] [WARN] [PsychologyMonitor] Psychology Alert [revenge_trading]: 連続損失が12回続いています。 {
        severity: 'high',
        recommendation: '一時的に取引を停止し、戦略を見直してください。',
        timestamp: 2026-02-08T08:48:23.245Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.254Z] [WARN] [PsychologyMonitor] Psychology Alert [fear]: 感情的な取引パターンが検出されました。スコア: 100 {
        severity: 'high',
        recommendation: '冷静さを取り戻し、トレーディングプランに従ってください。',
        timestamp: 2026-02-08T08:48:23.245Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.254Z] [WARN] [PsychologyMonitor] Psychology Alert [fomo]: 短時間に複数の取引が検出されました。FOMO（取り残される恐怖）の可能性があります。 {
        severity: 'high',
        recommendation: '一度立ち止まり、取引計画を確認してください。感情ではなく戦略に基づいて取引してください。',
        timestamp: 2026-02-08T08:48:23.245Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.255Z] [WARN] [PsychologyMonitor] Psychology Alert [loss_aversion]: 連続損失後に同じシンボルを買い増ししています。損失嫌悪バイアスの可能性があります。 {
        severity: 'high',
        recommendation: '損失を取り戻そうとする心理に注意してください。平均化戦略は慎重に行い、リスク管理を優先してください。',
        timestamp: 2026-02-08T08:48:23.245Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.255Z] [WARN] [PsychologyMonitor] Psychology Alert [revenge_trading]: 連続損失が13回続いています。 {
        severity: 'high',
        recommendation: '一時的に取引を停止し、戦略を見直してください。',
        timestamp: 2026-02-08T08:48:23.255Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.256Z] [WARN] [PsychologyMonitor] Psychology Alert [fear]: 感情的な取引パターンが検出されました。スコア: 100 {
        severity: 'high',
        recommendation: '冷静さを取り戻し、トレーディングプランに従ってください。',
        timestamp: 2026-02-08T08:48:23.255Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.256Z] [WARN] [PsychologyMonitor] Psychology Alert [fomo]: 短時間に複数の取引が検出されました。FOMO（取り残される恐怖）の可能性があります。 {
        severity: 'high',
        recommendation: '一度立ち止まり、取引計画を確認してください。感情ではなく戦略に基づいて取引してください。',
        timestamp: 2026-02-08T08:48:23.255Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.256Z] [WARN] [PsychologyMonitor] Psychology Alert [loss_aversion]: 連続損失後に同じシンボルを買い増ししています。損失嫌悪バイアスの可能性があります。 {
        severity: 'high',
        recommendation: '損失を取り戻そうとする心理に注意してください。平均化戦略は慎重に行い、リスク管理を優先してください。',
        timestamp: 2026-02-08T08:48:23.255Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.257Z] [WARN] [PsychologyMonitor] Psychology Alert [revenge_trading]: 連続損失が14回続いています。 {
        severity: 'high',
        recommendation: '一時的に取引を停止し、戦略を見直してください。',
        timestamp: 2026-02-08T08:48:23.256Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.257Z] [WARN] [PsychologyMonitor] Psychology Alert [fear]: 感情的な取引パターンが検出されました。スコア: 100 {
        severity: 'high',
        recommendation: '冷静さを取り戻し、トレーディングプランに従ってください。',
        timestamp: 2026-02-08T08:48:23.256Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.257Z] [WARN] [PsychologyMonitor] Psychology Alert [fomo]: 短時間に複数の取引が検出されました。FOMO（取り残される恐怖）の可能性があります。 {
        severity: 'high',
        recommendation: '一度立ち止まり、取引計画を確認してください。感情ではなく戦略に基づいて取引してください。',
        timestamp: 2026-02-08T08:48:23.256Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.262Z] [WARN] [PsychologyMonitor] Psychology Alert [loss_aversion]: 連続損失後に同じシンボルを買い増ししています。損失嫌悪バイアスの可能性があります。 {
        severity: 'high',
        recommendation: '損失を取り戻そうとする心理に注意してください。平均化戦略は慎重に行い、リスク管理を優先してください。',
        timestamp: 2026-02-08T08:48:23.256Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.262Z] [WARN] [PsychologyMonitor] Psychology Alert [revenge_trading]: 連続損失が15回続いています。 {
        severity: 'high',
        recommendation: '一時的に取引を停止し、戦略を見直してください。',
        timestamp: 2026-02-08T08:48:23.262Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.262Z] [WARN] [PsychologyMonitor] Psychology Alert [fear]: 感情的な取引パターンが検出されました。スコア: 100 {
        severity: 'high',
        recommendation: '冷静さを取り戻し、トレーディングプランに従ってください。',
        timestamp: 2026-02-08T08:48:23.262Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.263Z] [WARN] [PsychologyMonitor] Psychology Alert [fomo]: 短時間に複数の取引が検出されました。FOMO（取り残される恐怖）の可能性があります。 {
        severity: 'high',
        recommendation: '一度立ち止まり、取引計画を確認してください。感情ではなく戦略に基づいて取引してください。',
        timestamp: 2026-02-08T08:48:23.262Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.263Z] [WARN] [PsychologyMonitor] Psychology Alert [loss_aversion]: 連続損失後に同じシンボルを買い増ししています。損失嫌悪バイアスの可能性があります。 {
        severity: 'high',
        recommendation: '損失を取り戻そうとする心理に注意してください。平均化戦略は慎重に行い、リスク管理を優先してください。',
        timestamp: 2026-02-08T08:48:23.262Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.263Z] [WARN] [PsychologyMonitor] Psychology Alert [revenge_trading]: 連続損失が16回続いています。 {
        severity: 'high',
        recommendation: '一時的に取引を停止し、戦略を見直してください。',
        timestamp: 2026-02-08T08:48:23.263Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.264Z] [WARN] [PsychologyMonitor] Psychology Alert [fear]: 感情的な取引パターンが検出されました。スコア: 100 {
        severity: 'high',
        recommendation: '冷静さを取り戻し、トレーディングプランに従ってください。',
        timestamp: 2026-02-08T08:48:23.263Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.264Z] [WARN] [PsychologyMonitor] Psychology Alert [fomo]: 短時間に複数の取引が検出されました。FOMO（取り残される恐怖）の可能性があります。 {
        severity: 'high',
        recommendation: '一度立ち止まり、取引計画を確認してください。感情ではなく戦略に基づいて取引してください。',
        timestamp: 2026-02-08T08:48:23.263Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.264Z] [WARN] [PsychologyMonitor] Psychology Alert [loss_aversion]: 連続損失後に同じシンボルを買い増ししています。損失嫌悪バイアスの可能性があります。 {
        severity: 'high',
        recommendation: '損失を取り戻そうとする心理に注意してください。平均化戦略は慎重に行い、リスク管理を優先してください。',
        timestamp: 2026-02-08T08:48:23.263Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.265Z] [WARN] [PsychologyMonitor] Psychology Alert [revenge_trading]: 連続損失が17回続いています。 {
        severity: 'high',
        recommendation: '一時的に取引を停止し、戦略を見直してください。',
        timestamp: 2026-02-08T08:48:23.265Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.265Z] [WARN] [PsychologyMonitor] Psychology Alert [fear]: 感情的な取引パターンが検出されました。スコア: 100 {
        severity: 'high',
        recommendation: '冷静さを取り戻し、トレーディングプランに従ってください。',
        timestamp: 2026-02-08T08:48:23.265Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.265Z] [WARN] [PsychologyMonitor] Psychology Alert [fomo]: 短時間に複数の取引が検出されました。FOMO（取り残される恐怖）の可能性があります。 {
        severity: 'high',
        recommendation: '一度立ち止まり、取引計画を確認してください。感情ではなく戦略に基づいて取引してください。',
        timestamp: 2026-02-08T08:48:23.265Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.268Z] [WARN] [PsychologyMonitor] Psychology Alert [loss_aversion]: 連続損失後に同じシンボルを買い増ししています。損失嫌悪バイアスの可能性があります。 {
        severity: 'high',
        recommendation: '損失を取り戻そうとする心理に注意してください。平均化戦略は慎重に行い、リスク管理を優先してください。',
        timestamp: 2026-02-08T08:48:23.265Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.268Z] [WARN] [PsychologyMonitor] Psychology Alert [revenge_trading]: 連続損失が18回続いています。 {
        severity: 'high',
        recommendation: '一時的に取引を停止し、戦略を見直してください。',
        timestamp: 2026-02-08T08:48:23.268Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.269Z] [WARN] [PsychologyMonitor] Psychology Alert [fear]: 感情的な取引パターンが検出されました。スコア: 100 {
        severity: 'high',
        recommendation: '冷静さを取り戻し、トレーディングプランに従ってください。',
        timestamp: 2026-02-08T08:48:23.268Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.269Z] [WARN] [PsychologyMonitor] Psychology Alert [fomo]: 短時間に複数の取引が検出されました。FOMO（取り残される恐怖）の可能性があります。 {
        severity: 'high',
        recommendation: '一度立ち止まり、取引計画を確認してください。感情ではなく戦略に基づいて取引してください。',
        timestamp: 2026-02-08T08:48:23.268Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.269Z] [WARN] [PsychologyMonitor] Psychology Alert [loss_aversion]: 連続損失後に同じシンボルを買い増ししています。損失嫌悪バイアスの可能性があります。 {
        severity: 'high',
        recommendation: '損失を取り戻そうとする心理に注意してください。平均化戦略は慎重に行い、リスク管理を優先してください。',
        timestamp: 2026-02-08T08:48:23.268Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.270Z] [WARN] [PsychologyMonitor] Psychology Alert [revenge_trading]: 連続損失が19回続いています。 {
        severity: 'high',
        recommendation: '一時的に取引を停止し、戦略を見直してください。',
        timestamp: 2026-02-08T08:48:23.270Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.270Z] [WARN] [PsychologyMonitor] Psychology Alert [fear]: 感情的な取引パターンが検出されました。スコア: 100 {
        severity: 'high',
        recommendation: '冷静さを取り戻し、トレーディングプランに従ってください。',
        timestamp: 2026-02-08T08:48:23.270Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.271Z] [WARN] [PsychologyMonitor] Psychology Alert [fomo]: 短時間に複数の取引が検出されました。FOMO（取り残される恐怖）の可能性があります。 {
        severity: 'high',
        recommendation: '一度立ち止まり、取引計画を確認してください。感情ではなく戦略に基づいて取引してください。',
        timestamp: 2026-02-08T08:48:23.270Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.271Z] [WARN] [PsychologyMonitor] Psychology Alert [loss_aversion]: 連続損失後に同じシンボルを買い増ししています。損失嫌悪バイアスの可能性があります。 {
        severity: 'high',
        recommendation: '損失を取り戻そうとする心理に注意してください。平均化戦略は慎重に行い、リスク管理を優先してください。',
        timestamp: 2026-02-08T08:48:23.270Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.271Z] [WARN] [PsychologyMonitor] Psychology Alert [revenge_trading]: 連続損失が20回続いています。 {
        severity: 'high',
        recommendation: '一時的に取引を停止し、戦略を見直してください。',
        timestamp: 2026-02-08T08:48:23.271Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.272Z] [WARN] [PsychologyMonitor] Psychology Alert [fear]: 感情的な取引パターンが検出されました。スコア: 100 {
        severity: 'high',
        recommendation: '冷静さを取り戻し、トレーディングプランに従ってください。',
        timestamp: 2026-02-08T08:48:23.271Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.272Z] [WARN] [PsychologyMonitor] Psychology Alert [fomo]: 短時間に複数の取引が検出されました。FOMO（取り残される恐怖）の可能性があります。 {
        severity: 'high',
        recommendation: '一度立ち止まり、取引計画を確認してください。感情ではなく戦略に基づいて取引してください。',
        timestamp: 2026-02-08T08:48:23.271Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.272Z] [WARN] [PsychologyMonitor] Psychology Alert [loss_aversion]: 連続損失後に同じシンボルを買い増ししています。損失嫌悪バイアスの可能性があります。 {
        severity: 'high',
        recommendation: '損失を取り戻そうとする心理に注意してください。平均化戦略は慎重に行い、リスク管理を優先してください。',
        timestamp: 2026-02-08T08:48:23.271Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:58:27)

    console.warn
      [2026-02-08T08:48:23.280Z] [WARN] [PsychologyMonitor] Psychology Alert [revenge_trading]: 連続損失が3回続いています。 {
        severity: 'medium',
        recommendation: '一時的に取引を停止し、戦略を見直してください。',
        timestamp: 2026-02-08T08:48:23.280Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:83:27)

    console.warn
      [2026-02-08T08:48:23.280Z] [WARN] [PsychologyMonitor] Psychology Alert [fear]: 感情的な取引パターンが検出されました。スコア: 75 {
        severity: 'medium',
        recommendation: '冷静さを取り戻し、トレーディングプランに従ってください。',
        timestamp: 2026-02-08T08:48:23.280Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:83:27)

    console.warn
      [2026-02-08T08:48:23.280Z] [WARN] [PsychologyMonitor] Psychology Alert [fomo]: 短時間に複数の取引が検出されました。FOMO（取り残される恐怖）の可能性があります。 {
        severity: 'high',
        recommendation: '一度立ち止まり、取引計画を確認してください。感情ではなく戦略に基づいて取引してください。',
        timestamp: 2026-02-08T08:48:23.280Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:83:27)

    console.warn
      [2026-02-08T08:48:23.281Z] [WARN] [PsychologyMonitor] Psychology Alert [loss_aversion]: 連続損失後に同じシンボルを買い増ししています。損失嫌悪バイアスの可能性があります。 {
        severity: 'high',
        recommendation: '損失を取り戻そうとする心理に注意してください。平均化戦略は慎重に行い、リスク管理を優先してください。',
        timestamp: 2026-02-08T08:48:23.280Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:83:27)

    console.warn
      [2026-02-08T08:48:23.281Z] [WARN] [PsychologyMonitor] Psychology Alert [revenge_trading]: 連続損失が4回続いています。 {
        severity: 'medium',
        recommendation: '一時的に取引を停止し、戦略を見直してください。',
        timestamp: 2026-02-08T08:48:23.281Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:83:27)

    console.warn
      [2026-02-08T08:48:23.282Z] [WARN] [PsychologyMonitor] Psychology Alert [fear]: 感情的な取引パターンが検出されました。スコア: 90 {
        severity: 'high',
        recommendation: '冷静さを取り戻し、トレーディングプランに従ってください。',
        timestamp: 2026-02-08T08:48:23.281Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:83:27)

    console.warn
      [2026-02-08T08:48:23.282Z] [WARN] [PsychologyMonitor] Psychology Alert [fomo]: 短時間に複数の取引が検出されました。FOMO（取り残される恐怖）の可能性があります。 {
        severity: 'high',
        recommendation: '一度立ち止まり、取引計画を確認してください。感情ではなく戦略に基づいて取引してください。',
        timestamp: 2026-02-08T08:48:23.281Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:83:27)

    console.warn
      [2026-02-08T08:48:23.282Z] [WARN] [PsychologyMonitor] Psychology Alert [loss_aversion]: 連続損失後に同じシンボルを買い増ししています。損失嫌悪バイアスの可能性があります。 {
        severity: 'high',
        recommendation: '損失を取り戻そうとする心理に注意してください。平均化戦略は慎重に行い、リスク管理を優先してください。',
        timestamp: 2026-02-08T08:48:23.281Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:83:27)

    console.warn
      [2026-02-08T08:48:23.283Z] [WARN] [PsychologyMonitor] Psychology Alert [revenge_trading]: 連続損失が5回続いています。 {
        severity: 'high',
        recommendation: '一時的に取引を停止し、戦略を見直してください。',
        timestamp: 2026-02-08T08:48:23.283Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:83:27)

    console.warn
      [2026-02-08T08:48:23.283Z] [WARN] [PsychologyMonitor] Psychology Alert [fear]: 感情的な取引パターンが検出されました。スコア: 100 {
        severity: 'high',
        recommendation: '冷静さを取り戻し、トレーディングプランに従ってください。',
        timestamp: 2026-02-08T08:48:23.283Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:83:27)

    console.warn
      [2026-02-08T08:48:23.283Z] [WARN] [PsychologyMonitor] Psychology Alert [fomo]: 短時間に複数の取引が検出されました。FOMO（取り残される恐怖）の可能性があります。 {
        severity: 'high',
        recommendation: '一度立ち止まり、取引計画を確認してください。感情ではなく戦略に基づいて取引してください。',
        timestamp: 2026-02-08T08:48:23.283Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:83:27)

    console.warn
      [2026-02-08T08:48:23.284Z] [WARN] [PsychologyMonitor] Psychology Alert [loss_aversion]: 連続損失後に同じシンボルを買い増ししています。損失嫌悪バイアスの可能性があります。 {
        severity: 'high',
        recommendation: '損失を取り戻そうとする心理に注意してください。平均化戦略は慎重に行い、リスク管理を優先してください。',
        timestamp: 2026-02-08T08:48:23.283Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:83:27)

    console.warn
      [2026-02-08T08:48:23.285Z] [WARN] [PsychologyMonitor] Psychology Alert [fomo]: 短時間に複数の取引が検出されました。FOMO（取り残される恐怖）の可能性があります。 {
        severity: 'high',
        recommendation: '一度立ち止まり、取引計画を確認してください。感情ではなく戦略に基づいて取引してください。',
        timestamp: 2026-02-08T08:48:23.285Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:107:27)

    console.warn
      [2026-02-08T08:48:23.285Z] [WARN] [PsychologyMonitor] Psychology Alert [fomo]: 短時間に複数の取引が検出されました。FOMO（取り残される恐怖）の可能性があります。 {
        severity: 'high',
        recommendation: '一度立ち止まり、取引計画を確認してください。感情ではなく戦略に基づいて取引してください。',
        timestamp: 2026-02-08T08:48:23.285Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:107:27)

    console.warn
      [2026-02-08T08:48:23.294Z] [WARN] [PsychologyMonitor] Psychology Alert [greed]: 感情的な取引パターンが検出されました。スコア: 80 {
        severity: 'medium',
        recommendation: '冷静さを取り戻し、トレーディングプランに従ってください。',
        timestamp: 2026-02-08T08:48:23.294Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:107:27)

    console.warn
      [2026-02-08T08:48:23.294Z] [WARN] [PsychologyMonitor] Psychology Alert [fomo]: 短時間に複数の取引が検出されました。FOMO（取り残される恐怖）の可能性があります。 {
        severity: 'high',
        recommendation: '一度立ち止まり、取引計画を確認してください。感情ではなく戦略に基づいて取引してください。',
        timestamp: 2026-02-08T08:48:23.294Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:107:27)

    console.warn
      [2026-02-08T08:48:23.302Z] [WARN] [PsychologyMonitor] Psychology Alert [revenge_trading]: 連続損失が3回続いています。 {
        severity: 'medium',
        recommendation: '一時的に取引を停止し、戦略を見直してください。',
        timestamp: 2026-02-08T08:48:23.302Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:238:27)

    console.warn
      [2026-02-08T08:48:23.302Z] [WARN] [PsychologyMonitor] Psychology Alert [fear]: 感情的な取引パターンが検出されました。スコア: 75 {
        severity: 'medium',
        recommendation: '冷静さを取り戻し、トレーディングプランに従ってください。',
        timestamp: 2026-02-08T08:48:23.302Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:238:27)

    console.warn
      [2026-02-08T08:48:23.302Z] [WARN] [PsychologyMonitor] Psychology Alert [fomo]: 短時間に複数の取引が検出されました。FOMO（取り残される恐怖）の可能性があります。 {
        severity: 'high',
        recommendation: '一度立ち止まり、取引計画を確認してください。感情ではなく戦略に基づいて取引してください。',
        timestamp: 2026-02-08T08:48:23.302Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:238:27)

    console.warn
      [2026-02-08T08:48:23.322Z] [WARN] [PsychologyMonitor] Psychology Alert [loss_aversion]: 連続損失後に同じシンボルを買い増ししています。損失嫌悪バイアスの可能性があります。 {
        severity: 'high',
        recommendation: '損失を取り戻そうとする心理に注意してください。平均化戦略は慎重に行い、リスク管理を優先してください。',
        timestamp: 2026-02-08T08:48:23.302Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:238:27)

    console.warn
      [2026-02-08T08:48:23.322Z] [WARN] [PsychologyMonitor] Psychology Alert [revenge_trading]: 連続損失が4回続いています。 {
        severity: 'medium',
        recommendation: '一時的に取引を停止し、戦略を見直してください。',
        timestamp: 2026-02-08T08:48:23.322Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:238:27)

    console.warn
      [2026-02-08T08:48:23.322Z] [WARN] [PsychologyMonitor] Psychology Alert [fear]: 感情的な取引パターンが検出されました。スコア: 90 {
        severity: 'high',
        recommendation: '冷静さを取り戻し、トレーディングプランに従ってください。',
        timestamp: 2026-02-08T08:48:23.322Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:238:27)

    console.warn
      [2026-02-08T08:48:23.323Z] [WARN] [PsychologyMonitor] Psychology Alert [fomo]: 短時間に複数の取引が検出されました。FOMO（取り残される恐怖）の可能性があります。 {
        severity: 'high',
        recommendation: '一度立ち止まり、取引計画を確認してください。感情ではなく戦略に基づいて取引してください。',
        timestamp: 2026-02-08T08:48:23.322Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:238:27)

    console.warn
      [2026-02-08T08:48:23.323Z] [WARN] [PsychologyMonitor] Psychology Alert [loss_aversion]: 連続損失後に同じシンボルを買い増ししています。損失嫌悪バイアスの可能性があります。 {
        severity: 'high',
        recommendation: '損失を取り戻そうとする心理に注意してください。平均化戦略は慎重に行い、リスク管理を優先してください。',
        timestamp: 2026-02-08T08:48:23.322Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:238:27)

    console.warn
      [2026-02-08T08:48:23.323Z] [WARN] [PsychologyMonitor] Psychology Alert [revenge_trading]: 連続損失が5回続いています。 {
        severity: 'high',
        recommendation: '一時的に取引を停止し、戦略を見直してください。',
        timestamp: 2026-02-08T08:48:23.323Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:238:27)

    console.warn
      [2026-02-08T08:48:23.324Z] [WARN] [PsychologyMonitor] Psychology Alert [fear]: 感情的な取引パターンが検出されました。スコア: 100 {
        severity: 'high',
        recommendation: '冷静さを取り戻し、トレーディングプランに従ってください。',
        timestamp: 2026-02-08T08:48:23.323Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:238:27)

    console.warn
      [2026-02-08T08:48:23.324Z] [WARN] [PsychologyMonitor] Psychology Alert [fomo]: 短時間に複数の取引が検出されました。FOMO（取り残される恐怖）の可能性があります。 {
        severity: 'high',
        recommendation: '一度立ち止まり、取引計画を確認してください。感情ではなく戦略に基づいて取引してください。',
        timestamp: 2026-02-08T08:48:23.323Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:238:27)

    console.warn
      [2026-02-08T08:48:23.324Z] [WARN] [PsychologyMonitor] Psychology Alert [loss_aversion]: 連続損失後に同じシンボルを買い増ししています。損失嫌悪バイアスの可能性があります。 {
        severity: 'high',
        recommendation: '損失を取り戻そうとする心理に注意してください。平均化戦略は慎重に行い、リスク管理を優先してください。',
        timestamp: 2026-02-08T08:48:23.323Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:238:27)

    console.warn
      [2026-02-08T08:48:23.331Z] [WARN] [PsychologyMonitor] Psychology Alert [revenge_trading]: 連続損失が3回続いています。 {
        severity: 'medium',
        recommendation: '一時的に取引を停止し、戦略を見直してください。',
        timestamp: 2026-02-08T08:48:23.330Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:295:27)

    console.warn
      [2026-02-08T08:48:23.342Z] [WARN] [PsychologyMonitor] Psychology Alert [fear]: 感情的な取引パターンが検出されました。スコア: 75 {
        severity: 'medium',
        recommendation: '冷静さを取り戻し、トレーディングプランに従ってください。',
        timestamp: 2026-02-08T08:48:23.330Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:295:27)

    console.warn
      [2026-02-08T08:48:23.342Z] [WARN] [PsychologyMonitor] Psychology Alert [fomo]: 短時間に複数の取引が検出されました。FOMO（取り残される恐怖）の可能性があります。 {
        severity: 'high',
        recommendation: '一度立ち止まり、取引計画を確認してください。感情ではなく戦略に基づいて取引してください。',
        timestamp: 2026-02-08T08:48:23.330Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:295:27)

    console.warn
      [2026-02-08T08:48:23.343Z] [WARN] [PsychologyMonitor] Psychology Alert [loss_aversion]: 連続損失後に同じシンボルを買い増ししています。損失嫌悪バイアスの可能性があります。 {
        severity: 'high',
        recommendation: '損失を取り戻そうとする心理に注意してください。平均化戦略は慎重に行い、リスク管理を優先してください。',
        timestamp: 2026-02-08T08:48:23.330Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:295:27)

    console.warn
      [2026-02-08T08:48:23.343Z] [WARN] [PsychologyMonitor] Psychology Alert [revenge_trading]: 連続損失が4回続いています。 {
        severity: 'medium',
        recommendation: '一時的に取引を停止し、戦略を見直してください。',
        timestamp: 2026-02-08T08:48:23.343Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:295:27)

    console.warn
      [2026-02-08T08:48:23.344Z] [WARN] [PsychologyMonitor] Psychology Alert [fear]: 感情的な取引パターンが検出されました。スコア: 90 {
        severity: 'high',
        recommendation: '冷静さを取り戻し、トレーディングプランに従ってください。',
        timestamp: 2026-02-08T08:48:23.343Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:295:27)

    console.warn
      [2026-02-08T08:48:23.344Z] [WARN] [PsychologyMonitor] Psychology Alert [fomo]: 短時間に複数の取引が検出されました。FOMO（取り残される恐怖）の可能性があります。 {
        severity: 'high',
        recommendation: '一度立ち止まり、取引計画を確認してください。感情ではなく戦略に基づいて取引してください。',
        timestamp: 2026-02-08T08:48:23.343Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:295:27)

    console.warn
      [2026-02-08T08:48:23.344Z] [WARN] [PsychologyMonitor] Psychology Alert [loss_aversion]: 連続損失後に同じシンボルを買い増ししています。損失嫌悪バイアスの可能性があります。 {
        severity: 'high',
        recommendation: '損失を取り戻そうとする心理に注意してください。平均化戦略は慎重に行い、リスク管理を優先してください。',
        timestamp: 2026-02-08T08:48:23.343Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:295:27)

    console.warn
      [2026-02-08T08:48:23.344Z] [WARN] [PsychologyMonitor] Psychology Alert [revenge_trading]: 連続損失が5回続いています。 {
        severity: 'high',
        recommendation: '一時的に取引を停止し、戦略を見直してください。',
        timestamp: 2026-02-08T08:48:23.344Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:295:27)

    console.warn
      [2026-02-08T08:48:23.345Z] [WARN] [PsychologyMonitor] Psychology Alert [fear]: 感情的な取引パターンが検出されました。スコア: 100 {
        severity: 'high',
        recommendation: '冷静さを取り戻し、トレーディングプランに従ってください。',
        timestamp: 2026-02-08T08:48:23.344Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:295:27)

    console.warn
      [2026-02-08T08:48:23.345Z] [WARN] [PsychologyMonitor] Psychology Alert [fomo]: 短時間に複数の取引が検出されました。FOMO（取り残される恐怖）の可能性があります。 {
        severity: 'high',
        recommendation: '一度立ち止まり、取引計画を確認してください。感情ではなく戦略に基づいて取引してください。',
        timestamp: 2026-02-08T08:48:23.344Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:295:27)

    console.warn
      [2026-02-08T08:48:23.350Z] [WARN] [PsychologyMonitor] Psychology Alert [loss_aversion]: 連続損失後に同じシンボルを買い増ししています。損失嫌悪バイアスの可能性があります。 {
        severity: 'high',
        recommendation: '損失を取り戻そうとする心理に注意してください。平均化戦略は慎重に行い、リスク管理を優先してください。',
        timestamp: 2026-02-08T08:48:23.344Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:295:27)

    console.warn
      [2026-02-08T08:48:23.351Z] [WARN] [PsychologyMonitor] Psychology Alert [revenge_trading]: 連続損失が3回続いています。 {
        severity: 'medium',
        recommendation: '一時的に取引を停止し、戦略を見直してください。',
        timestamp: 2026-02-08T08:48:23.351Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:316:27)

    console.warn
      [2026-02-08T08:48:23.351Z] [WARN] [PsychologyMonitor] Psychology Alert [fear]: 感情的な取引パターンが検出されました。スコア: 75 {
        severity: 'medium',
        recommendation: '冷静さを取り戻し、トレーディングプランに従ってください。',
        timestamp: 2026-02-08T08:48:23.351Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:316:27)

    console.warn
      [2026-02-08T08:48:23.351Z] [WARN] [PsychologyMonitor] Psychology Alert [fomo]: 短時間に複数の取引が検出されました。FOMO（取り残される恐怖）の可能性があります。 {
        severity: 'high',
        recommendation: '一度立ち止まり、取引計画を確認してください。感情ではなく戦略に基づいて取引してください。',
        timestamp: 2026-02-08T08:48:23.351Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:316:27)

    console.warn
      [2026-02-08T08:48:23.352Z] [WARN] [PsychologyMonitor] Psychology Alert [loss_aversion]: 連続損失後に同じシンボルを買い増ししています。損失嫌悪バイアスの可能性があります。 {
        severity: 'high',
        recommendation: '損失を取り戻そうとする心理に注意してください。平均化戦略は慎重に行い、リスク管理を優先してください。',
        timestamp: 2026-02-08T08:48:23.351Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:316:27)

    console.warn
      [2026-02-08T08:48:23.352Z] [WARN] [PsychologyMonitor] Psychology Alert [revenge_trading]: 連続損失が4回続いています。 {
        severity: 'medium',
        recommendation: '一時的に取引を停止し、戦略を見直してください。',
        timestamp: 2026-02-08T08:48:23.352Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:316:27)

    console.warn
      [2026-02-08T08:48:23.352Z] [WARN] [PsychologyMonitor] Psychology Alert [fear]: 感情的な取引パターンが検出されました。スコア: 90 {
        severity: 'high',
        recommendation: '冷静さを取り戻し、トレーディングプランに従ってください。',
        timestamp: 2026-02-08T08:48:23.352Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:316:27)

    console.warn
      [2026-02-08T08:48:23.353Z] [WARN] [PsychologyMonitor] Psychology Alert [fomo]: 短時間に複数の取引が検出されました。FOMO（取り残される恐怖）の可能性があります。 {
        severity: 'high',
        recommendation: '一度立ち止まり、取引計画を確認してください。感情ではなく戦略に基づいて取引してください。',
        timestamp: 2026-02-08T08:48:23.352Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:316:27)

    console.warn
      [2026-02-08T08:48:23.353Z] [WARN] [PsychologyMonitor] Psychology Alert [loss_aversion]: 連続損失後に同じシンボルを買い増ししています。損失嫌悪バイアスの可能性があります。 {
        severity: 'high',
        recommendation: '損失を取り戻そうとする心理に注意してください。平均化戦略は慎重に行い、リスク管理を優先してください。',
        timestamp: 2026-02-08T08:48:23.352Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:316:27)

    console.warn
      [2026-02-08T08:48:23.357Z] [WARN] [PsychologyMonitor] Psychology Alert [revenge_trading]: 連続損失が5回続いています。 {
        severity: 'high',
        recommendation: '一時的に取引を停止し、戦略を見直してください。',
        timestamp: 2026-02-08T08:48:23.357Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:316:27)

    console.warn
      [2026-02-08T08:48:23.358Z] [WARN] [PsychologyMonitor] Psychology Alert [fear]: 感情的な取引パターンが検出されました。スコア: 100 {
        severity: 'high',
        recommendation: '冷静さを取り戻し、トレーディングプランに従ってください。',
        timestamp: 2026-02-08T08:48:23.357Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:316:27)

    console.warn
      [2026-02-08T08:48:23.358Z] [WARN] [PsychologyMonitor] Psychology Alert [fomo]: 短時間に複数の取引が検出されました。FOMO（取り残される恐怖）の可能性があります。 {
        severity: 'high',
        recommendation: '一度立ち止まり、取引計画を確認してください。感情ではなく戦略に基づいて取引してください。',
        timestamp: 2026-02-08T08:48:23.357Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:316:27)

    console.warn
      [2026-02-08T08:48:23.358Z] [WARN] [PsychologyMonitor] Psychology Alert [loss_aversion]: 連続損失後に同じシンボルを買い増ししています。損失嫌悪バイアスの可能性があります。 {
        severity: 'high',
        recommendation: '損失を取り戻そうとする心理に注意してください。平均化戦略は慎重に行い、リスク管理を優先してください。',
        timestamp: 2026-02-08T08:48:23.357Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:316:27)

    console.warn
      [2026-02-08T08:48:23.360Z] [WARN] [PsychologyMonitor] Psychology Alert [revenge_trading]: 連続損失が3回続いています。 {
        severity: 'medium',
        recommendation: '一時的に取引を停止し、戦略を見直してください。',
        timestamp: 2026-02-08T08:48:23.360Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:341:27)

    console.warn
      [2026-02-08T08:48:23.361Z] [WARN] [PsychologyMonitor] Psychology Alert [fear]: 感情的な取引パターンが検出されました。スコア: 75 {
        severity: 'medium',
        recommendation: '冷静さを取り戻し、トレーディングプランに従ってください。',
        timestamp: 2026-02-08T08:48:23.360Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:341:27)

    console.warn
      [2026-02-08T08:48:23.361Z] [WARN] [PsychologyMonitor] Psychology Alert [fomo]: 短時間に複数の取引が検出されました。FOMO（取り残される恐怖）の可能性があります。 {
        severity: 'high',
        recommendation: '一度立ち止まり、取引計画を確認してください。感情ではなく戦略に基づいて取引してください。',
        timestamp: 2026-02-08T08:48:23.360Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:341:27)

    console.warn
      [2026-02-08T08:48:23.366Z] [WARN] [PsychologyMonitor] Psychology Alert [loss_aversion]: 連続損失後に同じシンボルを買い増ししています。損失嫌悪バイアスの可能性があります。 {
        severity: 'high',
        recommendation: '損失を取り戻そうとする心理に注意してください。平均化戦略は慎重に行い、リスク管理を優先してください。',
        timestamp: 2026-02-08T08:48:23.360Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:341:27)

    console.warn
      [2026-02-08T08:48:23.366Z] [WARN] [PsychologyMonitor] Psychology Alert [revenge_trading]: 連続損失が4回続いています。 {
        severity: 'medium',
        recommendation: '一時的に取引を停止し、戦略を見直してください。',
        timestamp: 2026-02-08T08:48:23.366Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:341:27)

    console.warn
      [2026-02-08T08:48:23.366Z] [WARN] [PsychologyMonitor] Psychology Alert [fear]: 感情的な取引パターンが検出されました。スコア: 90 {
        severity: 'high',
        recommendation: '冷静さを取り戻し、トレーディングプランに従ってください。',
        timestamp: 2026-02-08T08:48:23.366Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:341:27)

    console.warn
      [2026-02-08T08:48:23.367Z] [WARN] [PsychologyMonitor] Psychology Alert [fomo]: 短時間に複数の取引が検出されました。FOMO（取り残される恐怖）の可能性があります。 {
        severity: 'high',
        recommendation: '一度立ち止まり、取引計画を確認してください。感情ではなく戦略に基づいて取引してください。',
        timestamp: 2026-02-08T08:48:23.366Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:341:27)

    console.warn
      [2026-02-08T08:48:23.367Z] [WARN] [PsychologyMonitor] Psychology Alert [loss_aversion]: 連続損失後に同じシンボルを買い増ししています。損失嫌悪バイアスの可能性があります。 {
        severity: 'high',
        recommendation: '損失を取り戻そうとする心理に注意してください。平均化戦略は慎重に行い、リスク管理を優先してください。',
        timestamp: 2026-02-08T08:48:23.366Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:341:27)

    console.warn
      [2026-02-08T08:48:23.367Z] [WARN] [PsychologyMonitor] Psychology Alert [revenge_trading]: 連続損失が5回続いています。 {
        severity: 'high',
        recommendation: '一時的に取引を停止し、戦略を見直してください。',
        timestamp: 2026-02-08T08:48:23.367Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:341:27)

    console.warn
      [2026-02-08T08:48:23.368Z] [WARN] [PsychologyMonitor] Psychology Alert [fear]: 感情的な取引パターンが検出されました。スコア: 100 {
        severity: 'high',
        recommendation: '冷静さを取り戻し、トレーディングプランに従ってください。',
        timestamp: 2026-02-08T08:48:23.367Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:341:27)

    console.warn
      [2026-02-08T08:48:23.368Z] [WARN] [PsychologyMonitor] Psychology Alert [fomo]: 短時間に複数の取引が検出されました。FOMO（取り残される恐怖）の可能性があります。 {
        severity: 'high',
        recommendation: '一度立ち止まり、取引計画を確認してください。感情ではなく戦略に基づいて取引してください。',
        timestamp: 2026-02-08T08:48:23.367Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:341:27)

    console.warn
      [2026-02-08T08:48:23.368Z] [WARN] [PsychologyMonitor] Psychology Alert [loss_aversion]: 連続損失後に同じシンボルを買い増ししています。損失嫌悪バイアスの可能性があります。 {
        severity: 'high',
        recommendation: '損失を取り戻そうとする心理に注意してください。平均化戦略は慎重に行い、リスク管理を優先してください。',
        timestamp: 2026-02-08T08:48:23.367Z
      }

      84 |     const formatted = this.formatMessage('warn', message, context);
      85 |     if (this.config.enableConsole) {
    > 86 |       console.warn(formatted, data ?? '');
         |               ^
      87 |     }
      88 |     this.addLog({ timestamp: new Date(), level: 'warn', message, context, data });
      89 |   }

      at Logger.warn (app/core/logger.ts:86:15)
      at warn (app/lib/risk/PsychologyMonitor.ts:725:14)
          at Array.forEach (<anonymous>)
      at PsychologyMonitor.forEach [as notifyAlerts] (app/lib/risk/PsychologyMonitor.ts:724:12)
      at PsychologyMonitor.notifyAlerts [as recordTrade] (app/lib/risk/PsychologyMonitor.ts:218:12)
      at Object.recordTrade (app/lib/risk/__tests__/PsychologyMonitor.test.ts:341:27)

FAIL app/lib/optimization/__tests__/ParameterOptimizer.test.ts
  ● ParameterOptimizer › Grid Search › should find approximate optimal parameters

    expect(received).toBeCloseTo(expected, precision)

    Expected: 5
    Received: 4.444444444444445

    Expected precision:    0
    Expected difference: < 0.5
    Received difference:   0.5555555555555554

      38 |
      39 |       // Should be close to (5, 3)
    > 40 |       expect(result.bestParameters.x).toBeCloseTo(5, 0);
         |                                       ^
      41 |       expect(result.bestParameters.y).toBeCloseTo(3, 0);
      42 |       expect(result.bestScore).toBeCloseTo(0, 1);
      43 |       expect(result.iterations).toBeGreaterThan(0);

      at Object.toBeCloseTo (app/lib/optimization/__tests__/ParameterOptimizer.test.ts:40:39)

  ● ParameterOptimizer › Cross-Validation › should perform cross-validation when enabled

    expect(received).toBeLessThanOrEqual(expected)

    Expected: <= 1
    Received:    1.0647646998979476

      219 |       expect(result.stabilityScore).toBeDefined();
      220 |       expect(result.stabilityScore).toBeGreaterThanOrEqual(0);
    > 221 |       expect(result.stabilityScore).toBeLessThanOrEqual(1);
          |                                     ^
      222 |     });
      223 |   });
      224 |

      at Object.toBeLessThanOrEqual (app/lib/optimization/__tests__/ParameterOptimizer.test.ts:221:37)

FAIL app/lib/utils/__tests__/calculations.test.ts
  ● calculations › calculateRsiImpact › should return positive score for oversold RSI

    TypeError: (0 , _calculations.calculateRsiImpact) is not a function

      23 |   describe('calculateRsiImpact', () => {
      24 |     it('should return positive score for oversold RSI', () => {
    > 25 |       expect(calculateRsiImpact(15)).toBe(RSI_CONSTANTS.EXTREME_SCORE);
         |                                ^
      26 |       expect(calculateRsiImpact(19)).toBe(RSI_CONSTANTS.EXTREME_SCORE);
      27 |     });
      28 |

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:25:32)

  ● calculations › calculateRsiImpact › should return negative score for overbought RSI

    TypeError: (0 , _calculations.calculateRsiImpact) is not a function

      28 |
      29 |     it('should return negative score for overbought RSI', () => {
    > 30 |       expect(calculateRsiImpact(85)).toBe(-RSI_CONSTANTS.EXTREME_SCORE);
         |                                ^
      31 |       expect(calculateRsiImpact(81)).toBe(-RSI_CONSTANTS.EXTREME_SCORE);
      32 |     });
      33 |

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:30:32)

  ● calculations › calculateRsiImpact › should return zero for neutral RSI

    TypeError: (0 , _calculations.calculateRsiImpact) is not a function

      33 |
      34 |     it('should return zero for neutral RSI', () => {
    > 35 |       expect(calculateRsiImpact(50)).toBe(0);
         |                                ^
      36 |       expect(calculateRsiImpact(30)).toBe(0);
      37 |       expect(calculateRsiImpact(70)).toBe(0);
      38 |     });

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:35:32)

  ● calculations › calculateRsiImpact › should handle boundary values

    TypeError: (0 , _calculations.calculateRsiImpact) is not a function

      39 |
      40 |     it('should handle boundary values', () => {
    > 41 |       expect(calculateRsiImpact(20)).toBe(0);
         |                                ^
      42 |       expect(calculateRsiImpact(80)).toBe(0);
      43 |     });
      44 |   });

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:41:32)

  ● calculations › calculateMomentumScore › should return positive score for strong positive momentum

    TypeError: (0 , _calculations.calculateMomentumScore) is not a function

      46 |   describe('calculateMomentumScore', () => {
      47 |     it('should return positive score for strong positive momentum', () => {
    > 48 |       expect(calculateMomentumScore(3.0)).toBe(MOMENTUM_CONSTANTS.SCORE);
         |                                    ^
      49 |       expect(calculateMomentumScore(2.5)).toBe(MOMENTUM_CONSTANTS.SCORE);
      50 |     });
      51 |

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:48:36)

  ● calculations › calculateMomentumScore › should return negative score for strong negative momentum

    TypeError: (0 , _calculations.calculateMomentumScore) is not a function

      51 |
      52 |     it('should return negative score for strong negative momentum', () => {
    > 53 |       expect(calculateMomentumScore(-3.0)).toBe(-MOMENTUM_CONSTANTS.SCORE);
         |                                    ^
      54 |       expect(calculateMomentumScore(-2.5)).toBe(-MOMENTUM_CONSTANTS.SCORE);
      55 |     });
      56 |

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:53:36)

  ● calculations › calculateMomentumScore › should return zero for weak momentum

    TypeError: (0 , _calculations.calculateMomentumScore) is not a function

      56 |
      57 |     it('should return zero for weak momentum', () => {
    > 58 |       expect(calculateMomentumScore(0)).toBe(0);
         |                                    ^
      59 |       expect(calculateMomentumScore(1.5)).toBe(0);
      60 |       expect(calculateMomentumScore(-1.5)).toBe(0);
      61 |     });

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:58:36)

  ● calculations › calculateMomentumScore › should respect custom threshold

    TypeError: (0 , _calculations.calculateMomentumScore) is not a function

      62 |
      63 |     it('should respect custom threshold', () => {
    > 64 |       expect(calculateMomentumScore(1.5, 1.0)).toBe(MOMENTUM_CONSTANTS.SCORE);
         |                                    ^
      65 |       expect(calculateMomentumScore(-1.5, 1.0)).toBe(-MOMENTUM_CONSTANTS.SCORE);
      66 |     });
      67 |

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:64:36)

  ● calculations › calculateMomentumScore › should handle boundary values

    TypeError: (0 , _calculations.calculateMomentumScore) is not a function

      67 |
      68 |     it('should handle boundary values', () => {
    > 69 |       expect(calculateMomentumScore(2.0)).toBe(0);
         |                                    ^
      70 |       expect(calculateMomentumScore(-2.0)).toBe(0);
      71 |     });
      72 |   });

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:69:36)

  ● calculations › calculateContinuousMomentumScore › should calculate proportional score

    TypeError: (0 , _calculations.calculateContinuousMomentumScore) is not a function

      74 |   describe('calculateContinuousMomentumScore', () => {
      75 |     it('should calculate proportional score', () => {
    > 76 |       expect(calculateContinuousMomentumScore(3.0)).toBe(1.0);
         |                                              ^
      77 |       expect(calculateContinuousMomentumScore(6.0)).toBe(2.0);
      78 |     });
      79 |

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:76:46)

  ● calculations › calculateContinuousMomentumScore › should cap at max score

    TypeError: (0 , _calculations.calculateContinuousMomentumScore) is not a function

      79 |
      80 |     it('should cap at max score', () => {
    > 81 |       expect(calculateContinuousMomentumScore(15.0)).toBe(MOMENTUM_CONSTANTS.MAX_SCORE);
         |                                              ^
      82 |       expect(calculateContinuousMomentumScore(100.0)).toBe(MOMENTUM_CONSTANTS.MAX_SCORE);
      83 |     });
      84 |

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:81:46)

  ● calculations › calculateContinuousMomentumScore › should handle negative momentum

    TypeError: (0 , _calculations.calculateContinuousMomentumScore) is not a function

      84 |
      85 |     it('should handle negative momentum', () => {
    > 86 |       expect(calculateContinuousMomentumScore(-3.0)).toBe(-1.0);
         |                                              ^
      87 |       expect(calculateContinuousMomentumScore(-15.0)).toBe(-MOMENTUM_CONSTANTS.MAX_SCORE);
      88 |     });
      89 |

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:86:46)

  ● calculations › calculateContinuousMomentumScore › should handle zero momentum

    TypeError: (0 , _calculations.calculateContinuousMomentumScore) is not a function

      89 |
      90 |     it('should handle zero momentum', () => {
    > 91 |       expect(calculateContinuousMomentumScore(0)).toBe(0);
         |                                              ^
      92 |     });
      93 |   });
      94 |

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:91:46)

  ● calculations › calculateSmaScore › should return full score for both positive SMAs

    TypeError: (0 , _calculations.calculateSmaScore) is not a function

       95 |   describe('calculateSmaScore', () => {
       96 |     it('should return full score for both positive SMAs', () => {
    >  97 |       expect(calculateSmaScore(1.0, 1.0)).toBe(
          |                               ^
       98 |         SMA_CONSTANTS.BULL_SCORE + SMA_CONSTANTS.BEAR_SCORE
       99 |       );
      100 |     });

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:97:31)

  ● calculations › calculateSmaScore › should return bull score only for positive sma5

    TypeError: (0 , _calculations.calculateSmaScore) is not a function

      101 |
      102 |     it('should return bull score only for positive sma5', () => {
    > 103 |       expect(calculateSmaScore(1.0, 0)).toBe(SMA_CONSTANTS.BULL_SCORE);
          |                               ^
      104 |       expect(calculateSmaScore(1.0, -1.0)).toBe(SMA_CONSTANTS.BULL_SCORE);
      105 |     });
      106 |

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:103:31)

  ● calculations › calculateSmaScore › should return bear score only for positive sma20

    TypeError: (0 , _calculations.calculateSmaScore) is not a function

      106 |
      107 |     it('should return bear score only for positive sma20', () => {
    > 108 |       expect(calculateSmaScore(0, 1.0)).toBe(SMA_CONSTANTS.BEAR_SCORE);
          |                               ^
      109 |       expect(calculateSmaScore(-1.0, 1.0)).toBe(SMA_CONSTANTS.BEAR_SCORE);
      110 |     });
      111 |

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:108:31)

  ● calculations › calculateSmaScore › should return zero for both negative SMAs

    TypeError: (0 , _calculations.calculateSmaScore) is not a function

      111 |
      112 |     it('should return zero for both negative SMAs', () => {
    > 113 |       expect(calculateSmaScore(0, 0)).toBe(0);
          |                               ^
      114 |       expect(calculateSmaScore(-1.0, -1.0)).toBe(0);
      115 |     });
      116 |   });

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:113:31)

  ● calculations › calculateWeightedSmaScore › should calculate weighted average

    TypeError: (0 , _calculations.calculateWeightedSmaScore) is not a function

      118 |   describe('calculateWeightedSmaScore', () => {
      119 |     it('should calculate weighted average', () => {
    > 120 |       const score = calculateWeightedSmaScore(10, 10);
          |                                              ^
      121 |       const expected = (10 * SMA_CONSTANTS.SMA5_WEIGHT + 10 * SMA_CONSTANTS.SMA20_WEIGHT) / SMA_CONSTANTS.DIVISOR;
      122 |       expect(score).toBeCloseTo(expected, 5);
      123 |     });

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:120:46)

  ● calculations › calculateWeightedSmaScore › should give more weight to sma5

    TypeError: (0 , _calculations.calculateWeightedSmaScore) is not a function

      124 |
      125 |     it('should give more weight to sma5', () => {
    > 126 |       const score1 = calculateWeightedSmaScore(10, 0);
          |                                               ^
      127 |       const score2 = calculateWeightedSmaScore(0, 10);
      128 |       expect(score1).toBeGreaterThan(score2);
      129 |     });

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:126:47)

  ● calculations › calculateWeightedSmaScore › should handle negative values

    TypeError: (0 , _calculations.calculateWeightedSmaScore) is not a function

      130 |
      131 |     it('should handle negative values', () => {
    > 132 |       const score = calculateWeightedSmaScore(-10, -10);
          |                                              ^
      133 |       expect(score).toBeLessThan(0);
      134 |     });
      135 |

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:132:46)

  ● calculations › calculateWeightedSmaScore › should handle zero

    TypeError: (0 , _calculations.calculateWeightedSmaScore) is not a function

      135 |
      136 |     it('should handle zero', () => {
    > 137 |       expect(calculateWeightedSmaScore(0, 0)).toBe(0);
          |                                       ^
      138 |     });
      139 |   });
      140 |

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:137:39)

  ● calculations › calculateRsiConfidenceBonus › should return bonus for very extreme RSI

    TypeError: (0 , _calculations.calculateRsiConfidenceBonus) is not a function

      141 |   describe('calculateRsiConfidenceBonus', () => {
      142 |     it('should return bonus for very extreme RSI', () => {
    > 143 |       expect(calculateRsiConfidenceBonus(10)).toBe(CONFIDENCE_CONSTANTS.RSI_EXTREME_BONUS);
          |                                         ^
      144 |       expect(calculateRsiConfidenceBonus(90)).toBe(CONFIDENCE_CONSTANTS.RSI_EXTREME_BONUS);
      145 |     });
      146 |

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:143:41)

  ● calculations › calculateRsiConfidenceBonus › should return zero for moderate RSI

    TypeError: (0 , _calculations.calculateRsiConfidenceBonus) is not a function

      146 |
      147 |     it('should return zero for moderate RSI', () => {
    > 148 |       expect(calculateRsiConfidenceBonus(50)).toBe(0);
          |                                         ^
      149 |       expect(calculateRsiConfidenceBonus(20)).toBe(0);
      150 |       expect(calculateRsiConfidenceBonus(80)).toBe(0);
      151 |     });

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:148:41)

  ● calculations › calculateRsiConfidenceBonus › should handle boundary values

    TypeError: (0 , _calculations.calculateRsiConfidenceBonus) is not a function

      152 |
      153 |     it('should handle boundary values', () => {
    > 154 |       expect(calculateRsiConfidenceBonus(15)).toBe(0);
          |                                         ^
      155 |       expect(calculateRsiConfidenceBonus(85)).toBe(0);
      156 |     });
      157 |   });

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:154:41)

  ● calculations › calculateMomentumConfidenceBonus › should return bonus for strong momentum

    TypeError: (0 , _calculations.calculateMomentumConfidenceBonus) is not a function

      159 |   describe('calculateMomentumConfidenceBonus', () => {
      160 |     it('should return bonus for strong momentum', () => {
    > 161 |       expect(calculateMomentumConfidenceBonus(3.0)).toBe(CONFIDENCE_CONSTANTS.MOMENTUM_BONUS);
          |                                              ^
      162 |       expect(calculateMomentumConfidenceBonus(-3.0)).toBe(CONFIDENCE_CONSTANTS.MOMENTUM_BONUS);
      163 |     });
      164 |

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:161:46)

  ● calculations › calculateMomentumConfidenceBonus › should return zero for weak momentum

    TypeError: (0 , _calculations.calculateMomentumConfidenceBonus) is not a function

      164 |
      165 |     it('should return zero for weak momentum', () => {
    > 166 |       expect(calculateMomentumConfidenceBonus(1.0)).toBe(0);
          |                                              ^
      167 |       expect(calculateMomentumConfidenceBonus(-1.0)).toBe(0);
      168 |     });
      169 |

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:166:46)

  ● calculations › calculateMomentumConfidenceBonus › should respect custom threshold

    TypeError: (0 , _calculations.calculateMomentumConfidenceBonus) is not a function

      169 |
      170 |     it('should respect custom threshold', () => {
    > 171 |       expect(calculateMomentumConfidenceBonus(1.5, 1.0)).toBe(CONFIDENCE_CONSTANTS.MOMENTUM_BONUS);
          |                                              ^
      172 |     });
      173 |
      174 |     it('should handle boundary values', () => {

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:171:46)

  ● calculations › calculateMomentumConfidenceBonus › should handle boundary values

    TypeError: (0 , _calculations.calculateMomentumConfidenceBonus) is not a function

      173 |
      174 |     it('should handle boundary values', () => {
    > 175 |       expect(calculateMomentumConfidenceBonus(2.0)).toBe(0);
          |                                              ^
      176 |       expect(calculateMomentumConfidenceBonus(-2.0)).toBe(0);
      177 |     });
      178 |   });

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:175:46)

  ● calculations › calculatePredictionConfidenceBonus › should return bonus for large predictions

    TypeError: (0 , _calculations.calculatePredictionConfidenceBonus) is not a function

      180 |   describe('calculatePredictionConfidenceBonus', () => {
      181 |     it('should return bonus for large predictions', () => {
    > 182 |       expect(calculatePredictionConfidenceBonus(3.0)).toBe(CONFIDENCE_CONSTANTS.PREDICTION_BONUS);
          |                                                ^
      183 |       expect(calculatePredictionConfidenceBonus(-3.0)).toBe(CONFIDENCE_CONSTANTS.PREDICTION_BONUS);
      184 |     });
      185 |

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:182:48)

  ● calculations › calculatePredictionConfidenceBonus › should return zero for small predictions

    TypeError: (0 , _calculations.calculatePredictionConfidenceBonus) is not a function

      185 |
      186 |     it('should return zero for small predictions', () => {
    > 187 |       expect(calculatePredictionConfidenceBonus(1.0)).toBe(0);
          |                                                ^
      188 |       expect(calculatePredictionConfidenceBonus(-1.0)).toBe(0);
      189 |     });
      190 |

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:187:48)

  ● calculations › calculatePredictionConfidenceBonus › should respect custom threshold

    TypeError: (0 , _calculations.calculatePredictionConfidenceBonus) is not a function

      190 |
      191 |     it('should respect custom threshold', () => {
    > 192 |       expect(calculatePredictionConfidenceBonus(1.5, 1.0)).toBe(CONFIDENCE_CONSTANTS.PREDICTION_BONUS);
          |                                                ^
      193 |     });
      194 |   });
      195 |

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:192:48)

  ● calculations › calculateConfidence › should return base confidence for neutral indicators

    TypeError: (0 , _calculations.calculateConfidence) is not a function

      196 |   describe('calculateConfidence', () => {
      197 |     it('should return base confidence for neutral indicators', () => {
    > 198 |       const confidence = calculateConfidence(50, 0, 0);
          |                                             ^
      199 |       expect(confidence).toBe(CONFIDENCE_CONSTANTS.BASE);
      200 |     });
      201 |

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:198:45)

  ● calculations › calculateConfidence › should add RSI bonus for extreme RSI

    TypeError: (0 , _calculations.calculateConfidence) is not a function

      201 |
      202 |     it('should add RSI bonus for extreme RSI', () => {
    > 203 |       const confidence = calculateConfidence(10, 0, 0);
          |                                             ^
      204 |       expect(confidence).toBe(CONFIDENCE_CONSTANTS.BASE + CONFIDENCE_CONSTANTS.RSI_EXTREME_BONUS);
      205 |     });
      206 |

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:203:45)

  ● calculations › calculateConfidence › should add momentum bonus for strong momentum

    TypeError: (0 , _calculations.calculateConfidence) is not a function

      206 |
      207 |     it('should add momentum bonus for strong momentum', () => {
    > 208 |       const confidence = calculateConfidence(50, 3.0, 0);
          |                                             ^
      209 |       expect(confidence).toBe(CONFIDENCE_CONSTANTS.BASE + CONFIDENCE_CONSTANTS.MOMENTUM_BONUS);
      210 |     });
      211 |

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:208:45)

  ● calculations › calculateConfidence › should add prediction bonus for large prediction

    TypeError: (0 , _calculations.calculateConfidence) is not a function

      211 |
      212 |     it('should add prediction bonus for large prediction', () => {
    > 213 |       const confidence = calculateConfidence(50, 0, 3.0);
          |                                             ^
      214 |       expect(confidence).toBe(CONFIDENCE_CONSTANTS.BASE + CONFIDENCE_CONSTANTS.PREDICTION_BONUS);
      215 |     });
      216 |

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:213:45)

  ● calculations › calculateConfidence › should add all bonuses when all conditions met

    TypeError: (0 , _calculations.calculateConfidence) is not a function

      216 |
      217 |     it('should add all bonuses when all conditions met', () => {
    > 218 |       const confidence = calculateConfidence(10, 3.0, 3.0);
          |                                             ^
      219 |       expect(confidence).toBe(
      220 |         CONFIDENCE_CONSTANTS.BASE +
      221 |         CONFIDENCE_CONSTANTS.RSI_EXTREME_BONUS +

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:218:45)

  ● calculations › calculateConfidence › should cap at maximum confidence

    TypeError: (0 , _calculations.calculateConfidence) is not a function

      228 |       // Max bonuses: RSI_EXTREME(10) + MOMENTUM(8) + PREDICTION(5) = 23 + BASE(50) = 73
      229 |       // This is the max we can get with current constants
    > 230 |       const confidence = calculateConfidence(10, 10.0, 10.0);
          |                                             ^
      231 |       expect(confidence).toBe(73);
      232 |
      233 |       // Test that clamp function would cap it at MAX

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:230:45)

  ● calculations › calculateConfidence › should not go below minimum confidence

    TypeError: (0 , _calculations.calculateConfidence) is not a function

      236 |
      237 |     it('should not go below minimum confidence', () => {
    > 238 |       const confidence = calculateConfidence(50, 0, 0);
          |                                             ^
      239 |       expect(confidence).toBeGreaterThanOrEqual(CONFIDENCE_CONSTANTS.MIN);
      240 |     });
      241 |   });

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:238:45)

  ● calculations › clampConfidence › should not change values within range

    TypeError: (0 , _calculations.clampConfidence) is not a function

      243 |   describe('clampConfidence', () => {
      244 |     it('should not change values within range', () => {
    > 245 |       expect(clampConfidence(60)).toBe(60);
          |                             ^
      246 |       expect(clampConfidence(75)).toBe(75);
      247 |     });
      248 |

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:245:29)

  ● calculations › clampConfidence › should cap at maximum

    TypeError: (0 , _calculations.clampConfidence) is not a function

      248 |
      249 |     it('should cap at maximum', () => {
    > 250 |       expect(clampConfidence(100)).toBe(CONFIDENCE_CONSTANTS.MAX);
          |                             ^
      251 |       expect(clampConfidence(150)).toBe(CONFIDENCE_CONSTANTS.MAX);
      252 |     });
      253 |

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:250:29)

  ● calculations › clampConfidence › should floor at minimum

    TypeError: (0 , _calculations.clampConfidence) is not a function

      253 |
      254 |     it('should floor at minimum', () => {
    > 255 |       expect(clampConfidence(30)).toBe(CONFIDENCE_CONSTANTS.MIN);
          |                             ^
      256 |       expect(clampConfidence(0)).toBe(CONFIDENCE_CONSTANTS.MIN);
      257 |     });
      258 |

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:255:29)

  ● calculations › clampConfidence › should respect custom bounds

    TypeError: (0 , _calculations.clampConfidence) is not a function

      258 |
      259 |     it('should respect custom bounds', () => {
    > 260 |       expect(clampConfidence(60, 0, 100)).toBe(60);
          |                             ^
      261 |       expect(clampConfidence(150, 0, 100)).toBe(100);
      262 |       expect(clampConfidence(-10, 0, 100)).toBe(0);
      263 |     });

      at Object.<anonymous> (app/lib/utils/__tests__/calculations.test.ts:260:29)

FAIL app/lib/psychology/__tests__/DisciplineScoreCalculator.test.ts
  ● DisciplineScoreCalculator › calculateDisciplineScore › should return zero score for empty data

    expect(received).toBe(expected) // Object.is equality

    Expected: 0
    Received: 40

      20 |       const score = calculator.calculateDisciplineScore([], []);
      21 |
    > 22 |       expect(score.overall).toBe(0);
         |                             ^
      23 |       expect(score.planAdherence).toBe(0);
      24 |       expect(score.emotionalControl).toBe(0);
      25 |       expect(score.lossManagement).toBeGreaterThan(0); // Full score when no losses

      at Object.toBe (app/lib/psychology/__tests__/DisciplineScoreCalculator.test.ts:22:29)

  ● DisciplineScoreCalculator › edge cases › should handle mixed results

    expect(received).toBeGreaterThan(expected)

    Expected: > 0
    Received:   0

      243 |       expect(score.overall).toBeGreaterThan(0);
      244 |       expect(score.overall).toBeLessThan(100);
    > 245 |       expect(score.planAdherence).toBeGreaterThan(0); // 50% adherence
          |                                   ^
      246 |       expect(score.planAdherence).toBeLessThan(30); // Not perfect
      247 |     });
      248 |   });

      at Object.toBeGreaterThan (app/lib/psychology/__tests__/DisciplineScoreCalculator.test.ts:245:35)

FAIL app/domains/prediction/models/ml/__tests__/FeatureEngineering.test.ts
  ● FeatureEngineering › calculateAllFeatures › should calculate all features successfully

    Invalid price data at index 26: close (1068.477993164015) must be between low (1062.9167271248457) and high (1067.2240704009755)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at Object.calculateAllFeatures (app/domains/prediction/models/ml/__tests__/FeatureEngineering.test.ts:49:56)

  ● FeatureEngineering › calculateAllFeatures › should include macro and sentiment features when provided

    Invalid price data at index 13: close (997.5257792189341) must be between low (998.3159432834514) and high (1001.1776880922309)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at Object.calculateAllFeatures (app/domains/prediction/models/ml/__tests__/FeatureEngineering.test.ts:90:56)

  ● FeatureEngineering › calculateAllFeatures › should use default values when macro and sentiment are not provided

    Invalid price data at index 1: close (990.5286170648784) must be between low (991.6764689032614) and high (995.1097797510021)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at Object.calculateAllFeatures (app/domains/prediction/models/ml/__tests__/FeatureEngineering.test.ts:101:56)

  ● FeatureEngineering › data quality assessment › should assess data quality as EXCELLENT for good data

    Invalid price data at index 4: close (992.2556028177248) must be between low (988.947496751628) and high (992.063302343298)

      214 |
      215 |       if (point.close < point.low || point.close > point.high) {
    > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
          |               ^
      217 |       }
      218 |
      219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at Object.calculateAllFeatures (app/domains/prediction/models/ml/__tests__/FeatureEngineering.test.ts:240:56)

  ● FeatureEngineering › edge cases › should handle data with zeros gracefully

    expect(received).not.toThrow()

    Error name:    "Error"
    Error message: "Invalid price data at index 0: close (994.8441716439955) must be between low (0) and high (0)"

          214 |
          215 |       if (point.close < point.low || point.close > point.high) {
        > 216 |         throw new Error(`Invalid price data at index ${i}: close (${point.close}) must be between low (${point.low}) and high (${point.high})`);
              |               ^
          217 |       }
          218 |
          219 |       if (point.open < point.low || point.open > point.high) {

      at FeatureEngineering.validateOHLCVData (app/domains/prediction/models/ml/FeatureEngineering.ts:216:15)
      at FeatureEngineering.validateOHLCVData [as calculateAllFeatures] (app/domains/prediction/models/ml/FeatureEngineering.ts:317:10)
      at calculateAllFeatures (app/domains/prediction/models/ml/__tests__/FeatureEngineering.test.ts:264:28)
      at Object.toThrow (app/domains/prediction/models/ml/__tests__/FeatureEngineering.test.ts:265:14)
      at Object.toThrow (app/domains/prediction/models/ml/__tests__/FeatureEngineering.test.ts:265:14)

PASS app/lib/ml/__tests__/FeatureEngineering.test.ts
PASS app/lib/backtest/__tests__/PartialFillSimulator.test.ts
PASS app/lib/trading/__tests__/behavioralBiasGuard.test.ts
PASS app/domains/market-data/__tests__/SmartDataCache.test.ts
PASS app/lib/data/__tests__/SmartDataCache.test.ts
PASS app/lib/nlp/__tests__/NLPProcessor.test.ts
PASS app/lib/data/__tests__/DataQualityChecker.test.ts
PASS app/domains/market-data/__tests__/DataQualityChecker.test.ts
FAIL app/lib/__tests__/BacktestService.test.ts
  ● Test suite failed to run

    TypeError: Cannot read properties of undefined (reading 'mock')

       9 |
      10 | // Mock mlPredictionService
    > 11 | vi.mock('../mlPrediction', () => ({
         |    ^
      12 |   mlPredictionService: {
      13 |     calculateIndicators: vi.fn(() => ({ rsi: 50, macd: 0, adx: 25, bbUpper: 110, bbLower: 90, sma: 100 })),
      14 |     predict: vi.fn(() => ({ confidence: 0.7, trend: 'UP' as const })),

      at Object.mock (app/lib/__tests__/BacktestService.test.ts:11:4)
