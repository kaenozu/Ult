diff --git a/trading-platform/app/__tests__/stocks-data.test.ts b/trading-platform/app/__tests__/stocks-data.test.ts
index a4661557..9188776c 100644
--- a/trading-platform/app/__tests__/stocks-data.test.ts
+++ b/trading-platform/app/__tests__/stocks-data.test.ts
@@ -122,10 +122,25 @@ describe('stocks data', () => {
             expect(result).toEqual([]);
         });
 
-        it('fetchSignal delegates to marketClient', async () => {
-            (marketClient.fetchSignal as jest.Mock).mockResolvedValue({ data: 'signal' });
-            const result = await fetchSignal({ symbol: '7203' } as any);
-            expect(result).toBe('signal');
-        });
+        it('fetchSignal delegates to marketClient', async () => {
+          const mockSignal = {
+            symbol: '7203',
+            type: 'BUY',
+            confidence: 80,
+            targetPrice: 100,
+            stopLoss: 90,
+            reason: 'test',
+            predictedChange: 10,
+            predictionDate: '2023-01-01'
+          } as const;
+          const mockResponse = {
+            success: true,
+            data: mockSignal,
+            source: 'api' as const
+          };
+          (marketClient.fetchSignal as jest.Mock).mockResolvedValue(mockResponse);
+          const result = await fetchSignal({ symbol: '7203' } as any);
+          expect(result).toEqual(mockResponse);
+        });
     });
 });
diff --git a/trading-platform/app/api/trading/route.ts b/trading-platform/app/api/trading/route.ts
index 259b5f82..0d8bd29a 100644
--- a/trading-platform/app/api/trading/route.ts
+++ b/trading-platform/app/api/trading/route.ts
@@ -298,10 +298,6 @@ export async function POST(req: NextRequest) {
         const side = validateOrderSide(body.side);
         const quantity = validateNumber(body.quantity, 'quantity', { positive: true });
         
-        if (typeof quantity !== 'number') {
-          return quantity; // Return validation error response
-        }
-        
         await platform.placeOrder(symbol, side, quantity, body.options);
         return NextResponse.json({ success: true });
       
@@ -317,10 +313,6 @@ export async function POST(req: NextRequest) {
         const operator = mapToAlertOperator(validateOperator(body.operator));
         const value = validateNumber(body.value, 'value', { finite: true });
         
-        if (typeof alertSymbol !== 'string' || typeof value !== 'number') {
-          return alertSymbol; // Return validation error response
-        }
-        
         platform.createAlert(name, alertSymbol, type as AlertType, operator, value);
         return NextResponse.json({ success: true });
       
diff --git a/trading-platform/app/components/StockChart/StockChart.tsx b/trading-platform/app/components/StockChart/StockChart.tsx
index b1f9872f..1f52a187 100644
--- a/trading-platform/app/components/StockChart/StockChart.tsx
+++ b/trading-platform/app/components/StockChart/StockChart.tsx
@@ -144,6 +144,7 @@ export const StockChart = memo(function StockChart({
   }), [
     extendedData.labels,
     extendedData.prices,
+    actualData.prices,
     normalizedIndexData,
     forecastDatasets,
     ghostForecastDatasets,
diff --git a/trading-platform/app/components/StockChart/hooks/useChartOptions.ts b/trading-platform/app/components/StockChart/hooks/useChartOptions.ts
index 5056b932..ffdf7f74 100644
--- a/trading-platform/app/components/StockChart/hooks/useChartOptions.ts
+++ b/trading-platform/app/components/StockChart/hooks/useChartOptions.ts
@@ -1,4 +1,4 @@
-﻿import { useMemo } from 'react';
+import { useMemo } from 'react';
 import { ChartOptions, TooltipItem } from 'chart.js';
 import { OHLCV, Signal } from '@/app/types';
 import { formatCurrency } from '@/app/lib/utils';
@@ -209,7 +209,6 @@ padding: {
     }
   }), [
     market,
-    extendedData.labels,
     hoveredIdx,
     yAxisRange,
     setHoveredIndex,
diff --git a/trading-platform/app/data/stocks.ts b/trading-platform/app/data/stocks.ts
index 39897488..2c42882d 100644
--- a/trading-platform/app/data/stocks.ts
+++ b/trading-platform/app/data/stocks.ts
@@ -1,4 +1,4 @@
-import { Stock, OHLCV, Signal } from '../types';
+import { Stock, OHLCV, Signal, APIResponse } from '../types';
 import { marketClient } from '@/app/lib/api/data-aggregator';
 
 export const JAPAN_STOCKS: Stock[] = [
@@ -152,9 +152,9 @@ export async function fetchOHLCV(
   return result.data || [];
 }
 
-export async function fetchSignal(stock: Stock, signal?: AbortSignal, interval?: string): Promise<Signal | null> {
+export async function fetchSignal(stock: Stock, signal?: AbortSignal, interval?: string): Promise<APIResponse<Signal>> {
   const result = await marketClient.fetchSignal(stock, signal, interval);
-  return result.data;
+  return result;
 }
 
 /**
diff --git a/trading-platform/app/hooks/__tests__/useStockData.test.ts b/trading-platform/app/hooks/__tests__/useStockData.test.ts
index 21c4e5d4..8eea01ff 100644
--- a/trading-platform/app/hooks/__tests__/useStockData.test.ts
+++ b/trading-platform/app/hooks/__tests__/useStockData.test.ts
@@ -18,8 +18,21 @@ describe('useStockData', () => {
             selectedStock: null,
             setSelectedStock: mockSetSelectedStock
         }));
-        (fetchOHLCV as jest.Mock).mockResolvedValue([{ date: '2023-01-01', close: 100 }]);
-        (fetchSignal as jest.Mock).mockResolvedValue({ type: 'BUY' });
+        (fetchOHLCV as jest.Mock).mockResolvedValue([{ date: '2023-01-01', close: 100 }]);
+        (fetchSignal as jest.Mock).mockResolvedValue({
+          success: true,
+          data: {
+            symbol: mockStock.symbol,
+            type: 'BUY',
+            confidence: 80,
+            targetPrice: 2500,
+            stopLoss: 2000,
+            reason: 'test reason',
+            predictedChange: 10,
+            predictionDate: '2023-01-01'
+          },
+          source: 'api'
+        });
     });
 
     it('initializes with default values', () => {
@@ -51,11 +64,11 @@ describe('useStockData', () => {
 
         const { result } = renderHook(() => useStockData());
 
-        await waitFor(() => {
-            expect(result.current.loading).toBe(false);
-            expect(result.current.chartData).toHaveLength(1);
-            expect(result.current.chartSignal).toEqual({ type: 'BUY' });
-        });
+         await waitFor(() => {
+             expect(result.current.loading).toBe(false);
+             expect(result.current.chartData).toHaveLength(1);
+             expect(result.current.chartSignal?.type).toBe('BUY');
+         });
 
         expect(fetchOHLCV).toHaveBeenCalledTimes(3); // Stock + Index + Background Sync
     });
diff --git a/trading-platform/app/hooks/usePerformance.ts b/trading-platform/app/hooks/usePerformance.ts
index eae9465e..9002b32e 100644
--- a/trading-platform/app/hooks/usePerformance.ts
+++ b/trading-platform/app/hooks/usePerformance.ts
@@ -368,10 +368,11 @@ export function usePropsMemo<T extends Record<string, unknown>>(
   const prevProps = useRef<T>(props);
   
   const hasChanged = useMemo(() => {
-    return keys.some((key) => {
+    const currentKeys = Object.keys(props) as (keyof T)[];
+    return currentKeys.some((key) => {
       return prevProps.current[key] !== props[key];
     });
-  }, keys.map((key) => props[key]));
+  }, Object.values(props));
   
   useEffect(() => {
     if (hasChanged) {
diff --git a/trading-platform/app/hooks/useStockData.ts b/trading-platform/app/hooks/useStockData.ts
index 562a1890..eaceae61 100644
--- a/trading-platform/app/hooks/useStockData.ts
+++ b/trading-platform/app/hooks/useStockData.ts
@@ -117,43 +117,46 @@ export function useStockData() {
               forecastCone: !!signalResult.data.forecastCone
             });
             setChartSignal(signalResult.data);
-          } else {
-            console.warn('[useStockData] Signal fetch returned unsuccessful:', signalResult.error);
-            // Fallback: generate consensus signal locally using technical analysis
-            try {
-              const fallbackSignal = consensusSignalService.generateConsensus(data);
-              console.log('[useStockData] Fallback signal generated:', {
-                type: fallbackSignal.type,
-                confidence: fallbackSignal.confidence,
-                accuracy: fallbackSignal.accuracy,
-                targetPrice: fallbackSignal.targetPrice,
-                forecastCone: !!fallbackSignal.forecastCone
-              });
-              setChartSignal(fallbackSignal);
-            } catch (fallbackErr) {
-              console.error('[useStockData] Fallback signal generation failed:', fallbackErr);
-            }
-          }
+           } else {
+             console.warn('[useStockData] Signal fetch returned unsuccessful:', signalResult.error);
+             // Fallback: generate consensus signal locally using technical analysis
+             try {
+               const fallbackSignal = consensusSignalService.generateConsensus(data);
+               console.log('[useStockData] Fallback signal generated:', {
+                 type: fallbackSignal.type,
+                 confidence: fallbackSignal.confidence,
+                 probability: fallbackSignal.probability,
+                 strength: fallbackSignal.strength,
+                 reason: fallbackSignal.reason
+               });
+               // Convert ConsensusSignal to Signal
+               const signal = consensusSignalService.convertToSignal(fallbackSignal, stock.symbol, data);
+               setChartSignal(signal);
+             } catch (fallbackErr) {
+               console.error('[useStockData] Fallback signal generation failed:', fallbackErr);
+             }
+           }
         }
-      } catch (signalErr) {
-        console.warn('[useStockData] Signal fetch threw error, using fallback consensus:', signalErr);
-        try {
-          const fallbackSignal = consensusSignalService.generateConsensus(data);
-          console.log('[useStockData] Fallback signal generated after error:', {
-            type: fallbackSignal.type,
-            confidence: fallbackSignal.confidence,
-            accuracy: fallbackSignal.accuracy,
-            targetPrice: fallbackSignal.targetPrice,
-            forecastCone: !!fallbackSignal.forecastCone
-          });
-          if (!controller.signal.aborted && isMountedRef.current) {
-            setChartSignal(fallbackSignal);
-          }
-        } catch (fallbackErr) {
-          console.error('[useStockData] Fallback also failed:', fallbackErr);
-          // Keep chartSignal as null if fallback fails
-        }
-      }
+       } catch (signalErr) {
+         console.warn('[useStockData] Signal fetch threw error, using fallback consensus:', signalErr);
+         try {
+           const fallbackSignal = consensusSignalService.generateConsensus(data);
+           console.log('[useStockData] Fallback signal generated after error:', {
+             type: fallbackSignal.type,
+             confidence: fallbackSignal.confidence,
+             probability: fallbackSignal.probability,
+             strength: fallbackSignal.strength,
+             reason: fallbackSignal.reason
+           });
+           const signal = consensusSignalService.convertToSignal(fallbackSignal, stock.symbol, data);
+           if (!controller.signal.aborted && isMountedRef.current) {
+             setChartSignal(signal);
+           }
+         } catch (fallbackErr) {
+           console.error('[useStockData] Fallback also failed:', fallbackErr);
+           // Keep chartSignal as null if fallback fails
+         }
+       }
 
       // 5. Background sync for long-term data (keep independent)
       fetchOHLCV(stock.symbol, stock.market, undefined, controller.signal, apiInterval).catch(e => {
diff --git a/trading-platform/app/lib/ConsensusSignalService.ts b/trading-platform/app/lib/ConsensusSignalService.ts
index 1c00ac1c..fdbaace5 100644
--- a/trading-platform/app/lib/ConsensusSignalService.ts
+++ b/trading-platform/app/lib/ConsensusSignalService.ts
@@ -7,7 +7,7 @@
  * - 売買の強さを0-1の確率として表現
  */
 
-import { OHLCV } from '../types';
+import { OHLCV, Signal } from '../types';
 import { technicalIndicatorService } from './TechnicalIndicatorService';
 import { RSI_CONFIG, BOLLINGER_BANDS } from './constants';
 
@@ -353,6 +353,44 @@ class ConsensusSignalService {
     return ((clamped - inMin) / (inMax - inMin)) * (outMax - outMin) + outMin;
   }
 
+  /**
+   * ConsensusSignal を Signal に変換する
+   * フォールバック用の簡易実装
+   */
+  convertToSignal(consensus: ConsensusSignal, symbol: string, data: OHLCV[]): Signal {
+    const currentPrice = data[data.length - 1].close;
+    const adjustment = consensus.confidence / 100 * 0.05; // 5% adjustment based on confidence
+    
+    let targetPrice: number;
+    let stopLoss: number;
+    if (consensus.type === 'BUY') {
+      targetPrice = currentPrice * (1 + adjustment);
+      stopLoss = currentPrice * (1 - adjustment * 1.5);
+    } else if (consensus.type === 'SELL') {
+      targetPrice = currentPrice * (1 - adjustment);
+      stopLoss = currentPrice * (1 + adjustment * 1.5);
+    } else {
+      targetPrice = currentPrice;
+      stopLoss = currentPrice;
+    }
+    
+    const predictedChange = ((targetPrice - currentPrice) / currentPrice) * 100;
+    const now = new Date();
+    const predictionDate = now.toISOString().split('T')[0];
+    
+    return {
+      symbol,
+      type: consensus.type,
+      confidence: consensus.confidence,
+      targetPrice,
+      stopLoss,
+      reason: consensus.reason,
+      predictedChange,
+      predictionDate,
+      // optional fields omitted
+    };
+  }
+
   /**
    * マルチ時間枠分析を使用した強化コンセンサスシグナル生成
    * 
diff --git a/trading-platform/app/lib/security/AuditLogger.ts b/trading-platform/app/lib/security/AuditLogger.ts
index c20ad8b4..04a76c8f 100644
--- a/trading-platform/app/lib/security/AuditLogger.ts
+++ b/trading-platform/app/lib/security/AuditLogger.ts
@@ -284,7 +284,6 @@ class AuditLogger {
       return [];
     }
   }
-  }
   
   /**
    * ログを検索
@@ -331,9 +330,6 @@ class AuditLogger {
     
     return JSON.stringify(logs, null, 2);
   }
-    
-    return JSON.stringify(logs, null, 2);
-  }
   
   // ========================================================================
   // 改ざん検知
diff --git a/trading-platform/app/lib/validation.ts b/trading-platform/app/lib/validation.ts
index 1cbb1304..9a4277d7 100644
--- a/trading-platform/app/lib/validation.ts
+++ b/trading-platform/app/lib/validation.ts
@@ -3,16 +3,7 @@
  * APIルートで使用する入力検証を共通化
  */
 
-import { NextResponse } from 'next/server';
-import { validationError } from './error-handler';
-
-// Simple ValidationError class for internal use
-class ValidationError extends Error {
-  constructor(message: string, public field?: string) {
-    super(message);
-    this.name = 'ValidationError';
-  }
-}
+import { ValidationError } from './errors';
 
 // ============================================================================
 // 基本バリデーション関数
@@ -21,9 +12,9 @@ class ValidationError extends Error {
 /**
  * 必須文字列の検証
  */
-export function validateRequiredString(value: unknown, fieldName: string): string | Response {
+export function validateRequiredString(value: unknown, fieldName: string): string {
   if (!value || typeof value !== 'string' || value.trim().length === 0) {
-    return validationError(`Invalid ${fieldName}: must be a non-empty string`, fieldName);
+    throw new ValidationError(fieldName, `must be a non-empty string`);
   }
   return value.trim();
 }
@@ -36,25 +27,25 @@ export function validateNumber(value: unknown, fieldName: string, options: {
   finite?: boolean;
   min?: number;
   max?: number;
-} = {}): number | Response {
+} = {}): number {
   if (typeof value !== 'number') {
-    return validationError(`Invalid ${fieldName}: must be a number`, fieldName);
+    throw new ValidationError(fieldName, `must be a number`);
   }
   
   if (options.finite && !isFinite(value)) {
-    return validationError(`Invalid ${fieldName}: must be a finite number`, fieldName);
+    throw new ValidationError(fieldName, `must be a finite number`);
   }
   
   if (options.positive && value <= 0) {
-    return validationError(`Invalid ${fieldName}: must be positive`, fieldName);
+    throw new ValidationError(fieldName, `must be positive`);
   }
   
   if (options.min !== undefined && value < options.min) {
-    return validationError(`Invalid ${fieldName}: must be at least ${options.min}`, fieldName);
+    throw new ValidationError(fieldName, `must be at least ${options.min}`);
   }
   
   if (options.max !== undefined && value > options.max) {
-    return validationError(`Invalid ${fieldName}: must be at most ${options.max}`, fieldName);
+    throw new ValidationError(fieldName, `must be at most ${options.max}`);
   }
   
   return value;
@@ -63,9 +54,9 @@ export function validateNumber(value: unknown, fieldName: string, options: {
 /**
  * 真偽値の検証
  */
-export function validateBoolean(value: unknown, fieldName: string): boolean | Response {
+export function validateBoolean(value: unknown, fieldName: string): boolean {
   if (typeof value !== 'boolean') {
-    return validationError(`Invalid ${fieldName}: must be a boolean`, fieldName);
+    throw new ValidationError(fieldName, `must be a boolean`);
   }
   return value;
 }
@@ -73,9 +64,9 @@ export function validateBoolean(value: unknown, fieldName: string): boolean | Re
 /**
  * 配列の検証
  */
-export function validateArray<T>(value: unknown, fieldName: string, itemValidator?: (item: unknown) => T): T[] | Response {
+export function validateArray<T>(value: unknown, fieldName: string, itemValidator?: (item: unknown) => T): T[] {
   if (!Array.isArray(value)) {
-    return validationError(`Invalid ${fieldName}: must be an array`, fieldName);
+    throw new ValidationError(fieldName, `must be an array`);
   }
 
   if (itemValidator) {
@@ -84,7 +75,7 @@ export function validateArray<T>(value: unknown, fieldName: string, itemValidato
         return itemValidator(item);
       } catch (error: unknown) {
         const message = error instanceof Error ? error.message : 'Unknown error';
-        return validationError(`Invalid ${fieldName}[${index}]: ${message}`, fieldName);
+        throw new ValidationError(fieldName, `Invalid ${fieldName}[${index}]: ${message}`);
       }
     }) as T[];
   }
@@ -95,9 +86,9 @@ export function validateArray<T>(value: unknown, fieldName: string, itemValidato
 /**
  * オブジェクトの検証
  */
-export function validateObject(value: unknown, fieldName: string): Record<string, unknown> | Response {
+export function validateObject(value: unknown, fieldName: string): Record<string, unknown> {
   if (!value || typeof value !== 'object' || Array.isArray(value)) {
-    return validationError(`Invalid ${fieldName}: must be an object`, fieldName);
+    throw new ValidationError(fieldName, `must be an object`);
   }
   return value as Record<string, unknown>;
 }
@@ -113,12 +104,12 @@ export function validateSymbol(symbol: unknown): string {
   const validatedSymbol = validateRequiredString(symbol, 'symbol');
   
   if (typeof validatedSymbol !== 'string') {
-    throw validationError('Invalid symbol: must be a string', 'symbol');
+    throw new ValidationError('symbol', 'Invalid symbol: must be a string');
   }
   
   // シンボル形式の検証（英数字、ドット、カンマ、キャレット）
   if (!/^[A-Z0-9.,^]+$/.test(validatedSymbol.toUpperCase())) {
-    throw validationError('Invalid symbol format', 'symbol');
+    throw new ValidationError('symbol', 'Invalid symbol format');
   }
   
   // シンボル長の検証（DoS対策）
@@ -126,7 +117,7 @@ export function validateSymbol(symbol: unknown): string {
   const maxLength = isBatch ? 1000 : 20;
   
   if (validatedSymbol.length > maxLength) {
-    throw validationError('Symbol too long', 'symbol');
+    throw new ValidationError('symbol', 'Symbol too long');
   }
   
   return validatedSymbol.toUpperCase();
@@ -139,11 +130,11 @@ export function validateOrderSide(side: unknown): 'BUY' | 'SELL' {
   const validatedSide = validateRequiredString(side, 'side');
   
   if (typeof validatedSide !== 'string') {
-    throw validationError('Invalid side: must be a string', 'side');
+    throw new ValidationError('side', 'Invalid side: must be a string');
   }
   
   if (!['BUY', 'SELL'].includes(validatedSide)) {
-    throw validationError('Invalid side: must be BUY or SELL', 'side');
+    throw new ValidationError('side', 'Invalid side: must be BUY or SELL');
   }
   
   return validatedSide as 'BUY' | 'SELL';
@@ -156,11 +147,11 @@ export function validateOrderType(orderType: unknown): 'MARKET' | 'LIMIT' {
   const validatedType = validateRequiredString(orderType, 'orderType');
   
   if (typeof validatedType !== 'string') {
-    throw validationError('Invalid orderType: must be a string', 'orderType');
+    throw new ValidationError('orderType', 'Invalid orderType: must be a string');
   }
   
   if (!['MARKET', 'LIMIT'].includes(validatedType)) {
-    throw validationError('Invalid orderType: must be MARKET or LIMIT', 'orderType');
+    throw new ValidationError('orderType', 'Invalid orderType: must be MARKET or LIMIT');
   }
   
   return validatedType as 'MARKET' | 'LIMIT';
@@ -175,7 +166,7 @@ export function validateMarketType(market: unknown): 'japan' | 'usa' {
   const validatedMarket = validateRequiredString(market, 'market');
   
   if (!['japan', 'usa'].includes(validatedMarket)) {
-    throw validationError('Invalid market: must be japan or usa', 'market');
+    throw new ValidationError('market', 'Invalid market: must be japan or usa');
   }
   
   return validatedMarket as 'japan' | 'usa';
@@ -193,7 +184,7 @@ export function validateTradingAction(action: unknown): string {
   ];
   
   if (!validActions.includes(validatedAction)) {
-    throw validationError('Unknown action', 'action');
+    throw new ValidationError('action', 'Unknown action');
   }
   
   return validatedAction;
@@ -206,7 +197,7 @@ export function validateDataType(type: unknown): 'history' | 'quote' {
   const validatedType = validateRequiredString(type, 'type');
   
   if (!['history', 'quote'].includes(validatedType)) {
-    throw validationError('Invalid type parameter. Use "history" or "quote".', 'type');
+    throw new ValidationError('type', 'Invalid type parameter. Use "history" or "quote".');
   }
   
   return validatedType as 'history' | 'quote';
@@ -223,7 +214,7 @@ export function validateInterval(interval: unknown): string {
   const validIntervals = ['1m', '5m', '15m', '1h', '4h', '1d', '1wk', '1mo'];
   
   if (!validIntervals.includes(validatedInterval)) {
-    throw validationError('Invalid interval. Use 1m, 5m, 15m, 1h, 4h, 1d, 1wk, or 1mo', 'interval');
+    throw new ValidationError('interval', 'Invalid interval. Use 1m, 5m, 15m, 1h, 4h, 1d, 1wk, or 1mo');
   }
   
   return validatedInterval;
@@ -237,7 +228,7 @@ export function validateDate(date: unknown, fieldName: string = 'date'): string
   
   // YYYY-MM-DD形式の検証
   if (!/^\d{4}-\d{2}-\d{2}$/.test(validatedDate) || isNaN(Date.parse(validatedDate))) {
-    throw validationError(`Invalid ${fieldName} format. Use YYYY-MM-DD.`, fieldName);
+    throw new ValidationError(fieldName, `Invalid ${fieldName} format. Use YYYY-MM-DD.`);
   }
   
   return validatedDate;
@@ -252,7 +243,7 @@ export function validateOperator(operator: unknown): '>' | '<' | '>=' | '<=' | '
   const validOperators = ['>', '<', '>=', '<=', '==', 'above', 'below', 'crosses_above', 'crosses_below', 'equals', 'between'] as const;
   
   if (!validOperators.includes(validatedOperator as any)) {
-    throw validationError('Invalid operator: must be >, <, >=, <=, ==, above, below, crosses_above, crosses_below, equals, or between', 'operator');
+    throw new ValidationError('operator', 'Invalid operator: must be >, <, >=, <=, ==, above, below, crosses_above, crosses_below, equals, or between');
   }
   
   return validatedOperator as any;
@@ -271,7 +262,7 @@ export function validateMode(mode: unknown): 'live' | 'paper' | 'backtest' {
   const validatedMode = validateRequiredString(mode, 'mode');
   
   if (!['live', 'paper', 'backtest'].includes(validatedMode)) {
-    throw validationError('Invalid mode: must be live, paper, or backtest', 'mode');
+    throw new ValidationError('mode', 'Invalid mode: must be live, paper, or backtest');
   }
   
   return validatedMode as 'live' | 'paper' | 'backtest';
diff --git a/trading-platform/docs/TYPE_ERROR_RESOLUTION_GUIDE.md b/trading-platform/docs/TYPE_ERROR_RESOLUTION_GUIDE.md
new file mode 100644
index 00000000..aadfccaa
--- /dev/null
+++ b/trading-platform/docs/TYPE_ERROR_RESOLUTION_GUIDE.md
@@ -0,0 +1,233 @@
+# TypeScript 型エラー解消ガイドライン
+
+このドキュメントは、TypeScript プロジェクトで型エラーを体系的に解消するための標準化された手順です。
+
+## 原則
+
+### 最小限の変更原則
+- ✅ 影響のある関数のみを編集
+- ❌ ファイル全体を書き換えない
+- ✅ 既存の定義を再利用する（重複定義禁止）
+
+### 即時検証原則
+- 1つの修正ごとに `tsc --noEmit` を実行
+- 0エラーを確認してから次に進む
+- エラー発生時は即時ロールバック
+
+### 依存関係の可視化原則
+```
+変更対象
+    ↓ 影響を受ける関数
+    ↓ その関数を使用するコンポーネント
+    ↓ テストファイル
+```
+
+## 手順
+
+### ステップ1: 事前確認フェーズ
+
+```bash
+# 1. 現在のエラーを収集
+npx tsc --noEmit | tee /tmp/tsc-errors.txt
+
+# 2. エラーを分類（致命的・警告・情報）
+grep "error TS" /tmp/tsc-errors.txt > critical-errors.txt
+
+# 3. 変更対象の使用箇所を特定
+grep -r "validateRequiredString" --include="*.ts" --include="*.tsx"
+
+# 4. 既存の類似実装を検索
+grep -r "class.*Error.*extends Error" --include="*.ts" | head -5
+```
+
+### ステップ2: 影響範囲の特定
+
+```bash
+# 変更する関数の依存を追跡
+grep -r "import.*validateSymbol" --include="*.ts" --include="*.tsx"
+
+# 使用箇所のファイルリスト
+grep -rl "validateSymbol" --include="*.ts" --include="*.tsx"
+
+# テストファイルの特定
+find . -name "*.test.ts" -o -name "*.spec.ts" | xargs grep -l "validateSymbol"
+```
+
+### ステップ3: 最小限の修正
+
+**優先順位:**
+1. 既存のクラス定義をインポート
+2. 新規定義を避ける
+3. 型を維持する
+
+**例:**
+```typescript
+// ❌ 悪い例
+class ValidationError extends Error { ... }
+
+// ✅ 良い例
+import { ValidationError } from './errors';
+```
+
+### ステップ4: 即時検証ループ
+
+```bash
+# 修正前
+npx tsc --noEmit  # エラー: 5件
+
+# 修正1: validation.ts のみ
+npx tsc --noEmit  # エラー: 3件
+
+# 修正2: route.ts のみ
+npx tsc --noEmit  # エラー: 1件
+
+# 修正3: useStockData.ts のみ
+npx tsc --noEmit  # エラー: 0件 ✅
+```
+
+### ステップ5: 自動化可能なチェック
+
+```bash
+# テストモックの整合性
+for file in app/**/__tests__/*.ts; do
+  grep -l "mockResolvedValue" "$file" | while read testfile; do
+    # モックと実装の型が一致するかチェック
+    ...
+  done
+done
+```
+
+## ワークフロー
+
+```
+┌─────────────────────────────────────────────────────┐
+│ 1. エラー収集                                   │
+│    npx tsc --noEmit                            │
+└──────────────────┬──────────────────────────────────┘
+                   ↓
+┌─────────────────────────────────────────────────────┐
+│ 2. 分類と優先度決定                             │
+│    - 致命的エラー: 即時対応                      │
+│    - 警告: 並列対応可能                         │
+└──────────────────┬──────────────────────────────────┘
+                   ↓
+┌─────────────────────────────────────────────────────┐
+│ 3. 影響範囲の特定                               │
+│    grep -r <関数名>                             │
+└──────────────────┬──────────────────────────────────┘
+                   ↓
+┌─────────────────────────────────────────────────────┐
+│ 4. 最小限の修正                                 │
+│    既存の再利用を優先                             │
+└──────────────────┬──────────────────────────────────┘
+                   ↓
+┌─────────────────────────────────────────────────────┐
+│ 5. 即時検証                                    │
+│    npx tsc --noEmit                            │
+└──────────────────┬──────────────────────────────────┘
+                   ↓
+              エラー0?
+                   ↓
+            Yes  No
+            ↓    ↓
+         完成   修正→検証
+```
+
+## チェックリスト
+
+### 事前
+- [ ] 現在のエラー一覧を取得
+- [ ] 影響範囲を特定
+- [ ] 既存の定義を検索
+
+### 実行中
+- [ ] 最小限の変更のみ
+- [ ] 既存の定義を再利用
+- [ ] 修正ごとに検証
+
+### 事後
+- [ ] 0エラーを確認
+- [ ] ESLint を実行
+- [ ] テストを実行
+- [ ] 変更をコミット（1変更=1コミット）
+
+## よくあるパターン
+
+### パターン1: バリデーション関数の変更
+```typescript
+// 変更前
+export function validateX(value: unknown): string | Response {
+  if (!valid) return errorResponse;
+  return value;
+}
+
+// 変更後
+export function validateX(value: unknown): string {
+  if (!valid) throw new ValidationError(...);
+  return value;
+}
+```
+
+**影響:** 使用箇所すべての早期リターン削除が必要
+
+### パターン2: 型の変更
+```typescript
+// 変更前
+export function fetchSignal(): Promise<Signal | null>
+
+// 変更後
+export function fetchSignal(): Promise<APIResponse<Signal>>
+```
+
+**影響:** テストモック、呼び出し元、型アサーション
+
+### パターン3: React Hooks の依存配列
+```typescript
+// ❌ 悪い例
+const hasChanged = useMemo(() => {
+  return prevRef.current !== props.value;
+}, props.value); // ref アクセス中
+
+// ✅ 良い例
+const hasChanged = useMemo(() => {
+  const prevValue = prevRef.current;
+  return prevValue !== props.value;
+}, [props.value]);
+```
+
+## ツール
+
+| 目的 | コマンド | 出力 |
+|------|---------|------|
+| エラー収集 | `npx tsc --noEmit 2>&1 \| tee errors.txt` | エラー一覧 |
+| 影響検索 | `grep -r "functionName" --include="*.ts"` | 使用箇所 |
+| 依存グラフ | `ts-node dependency-graph.ts` | 可視化 |
+
+## 学んだ教訓
+
+### 過ちと回避策
+
+| 過ち | 回避策 |
+|------|--------|
+| ファイル全体を書き換え | 最小限の修正原則 |
+| 既存の定義を見つけず新規作成 | `grep` で既存定義を検索 |
+| まとめて修正してから検証 | 1修正1検証のループ |
+| ロールバックが困難 | Git ブランチで作業 |
+
+### 改善フィードバック
+
+1. なぜその変更が必要だったか
+2. どの原則が適用されたか
+3. 今後どう回避できるか
+4. ドキュメントの更新が必要か
+
+## 更新履歴
+
+| 日付 | 内容 |
+|------|------|
+| 2026-02-06 | 初版作成 |
+
+## 関連ドキュメント
+
+- [TypeScript 公式ドキュメント](https://www.typescriptlang.org/docs/)
+- [ESLint React Hooks ルール](https://github.com/facebook/react/issues/14920)
